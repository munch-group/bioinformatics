[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bioinformatics and Programming",
    "section": "",
    "text": "Welcome\nThis is the homepage for the AU course Bioinformatics and programming (Bioinformatik og programmering). You will find all course content here. The Brightspace course page is only used for communication, and assignments.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#week-1",
    "href": "index.html#week-1",
    "title": "Bioinformatics and Programming",
    "section": "Week 1",
    "text": "Week 1\n\nReading:\n\nLecture notes: chapter 1  Preface\nLecture notes: chapter 2  Before you begin\nLecture notes: chapter 21  Appendix: PyMol for BSF\nLecture notes: chapter 3  Writing a program\nLecture notes: chapter 4  Dealing with values\nLecture notes: chapter 5  The order of events\nLecture notes: chapter 6  Course tools\n\nMake sure you have installed Python and VScode for the first lecture.\n\n\nLectures:\n\nIn the first lecture, I will outline how the course is organized and how you will get the most out of your efforts in learning programming.\nIn the first lecture, I will also talk about how a Python program works and about values, math, and logic.\nIn the second lecture, I will talk about variables, operators, substitution, and reduction.\n\n\n\nExercises:\nIf you have yet to do so at home, you will install Python and the text editor. To do this, follow the instructions in 2  Before you begin. Then, start doing the exercises in chapter 3  Writing a program, chapter 4  Dealing with values, and chapter 5  The order of events. You will also have time to do these exercises in the TA session of week two, so go slow. It is important to properly absorb the basic concepts at the beginning of the course; otherwise, it will become too difficult later on. Have a look\nAnd make sure to familiarize yourself with the Myiagi game and the print-steps tool described in chapter 6  Course tools. These are useful companions in the course.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#week-2",
    "href": "index.html#week-2",
    "title": "Bioinformatics and Programming",
    "section": "Week 2",
    "text": "Week 2\n\nReading:\n\nLecture notes: chapter 7  Controlling behavior\nLecture notes: chapter 8  Organizing code\n\nI will cover chapters 8-9 in the lecture notes.\n\n\nLectures:\n\nIn the first lecture, I will talk about how to use logic to control which statements in your program that get executed.\nIn the first lecture, I will also talk about how you can efficiently organize your code using functions.\nIn the second lecture, I will talk more about functions.\n\n\n\nExercises:\nThe topics for this week’s exercises are statements, variables, operators, expressions, substitution, reduction, and logic. You will work on the rest of the exercises in chapter 3  Writing a program, chapter 4  Dealing with values, chapter 5  The order of events, and chapter 6  Course tools. Do what you can at home and do the rest at the TA session.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#week-3",
    "href": "index.html#week-3",
    "title": "Bioinformatics and Programming",
    "section": "Week 3",
    "text": "Week 3\n\nReading:\n\nLecture notes: chapter 9  Values are objects\nLecture notes: chapter 10  Lists of things\nLecture notes: chapter 11  Pairs of things\nLecture notes: chapter 12  Grouping values\n\n\n\nLectures:\n\nIn the first lecture, I will talk about objects and methods.\nIn the first lecture, I will also talk about lists.\nIn the second lecture, I will talk about dictionaries and a bit about tuples.\n\n\n\nExercises:\nThe topics for this week’s exercises are if, else, logic, and functions. You are meant to complete all the exercises in chapter 7  Controlling behavior and chapter 8  Organizing code. Do what you can at home and do the rest at the TA session.\n\n\nWeek 4\n\nReading:\n\nLecture notes: chapter 13  Iterating values\nLecture notes: chapter 14  Working with files\n\n\n\nLectures:\n\nIn the first lecture, I will talk about iteration and lists.\nIn the second lecture, I will talk about how your code can interact with files on your computer.\n\n\n\nExercises:\n\n\n\n\n\n\nNote\n\n\n\nOnly MO and Bio classes attend the exercises this week. MM classes do not. The exercise is repeated next week for the MM classes to attend*\n\n\nThe topics for this week are objects, methods, strings, lists, tuples, and dictionaries. You are meant to complete all the exercises in chapters 9  Values are objects, 10  Lists of things, 11  Pairs of things, and 12  Grouping values. Do what you can at home and do the rest at the TA session.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Course description\nAfter the course, the participants will have basic knowledge of computer methods and applications for analyzing biological sequence data and insight into principles and techniques for constructing simple programs. Participants will acquire practical experience with analyzing problems in bioinformatics and related fields and implementing programs to solve such problems using the Python programming language.\nThe participants must, at the end of the course, be able to:",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#course-description",
    "href": "about.html#course-description",
    "title": "About",
    "section": "",
    "text": "Apply fundamental constructs of a programming language.\nAnalyse data and construct data structures for the representation of data.\nAnalyse simple computational problems and construct programs for their solution.\nDescribe and relate essential methods in bioinformatics analysis.\nApply bioinformatics software to biological data.\nJudge the reliability of results obtained using Bioinformatics software.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#course-contents",
    "href": "about.html#course-contents",
    "title": "About",
    "section": "Course contents",
    "text": "Course contents\nThe course introduces programming and its practical applications in bioinformatics. The course also outlines and discusses bioinformatics algorithms, and the most common tools for bioinformatics analysis of sequence data are presented and demo nstrated. The participant will acquire and train basic programming skills during the first seven weeks. The last seven weeks introduce key topics in bioinformatics, focusing on applying bioinformatical software and developing programming skills. Subjects for lectures and exercises include bioinformatics databases, sequence alignment, genome annotation, sequence evolution, and phylogenetic analysis.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "curriculum.html",
    "href": "curriculum.html",
    "title": "Curriculum",
    "section": "",
    "text": "The curriculum for programming is the lecture notes on these pages (a PDF version is available by clicking the PDF icon in the top left corner). I will develop my own lecture notes and add them to this page as the course progress.",
    "crumbs": [
      "Curriculum"
    ]
  },
  {
    "objectID": "chapters/python/preface.html",
    "href": "chapters/python/preface.html",
    "title": "1  Preface",
    "section": "",
    "text": "These lecture notes are inspired by the many books and resources I have used in this course. “Learning Python the Hard Way” and “How to Think Like a Computer Scientist” have inspired my own notes on programming. These implement the following ideas, which I think best support learning in an introduction to programming:\n\nEach topic and concept is introduced so that it can be applied immediately on top of what you know.\nThe introduction of each topic covers only the most basic facts and rules required to learn the rest through practical exercises.\n\nI would like to improve these notes as much as I can. If you find errors in exercises, poorly explained concepts, redundant information, missing items, or exercises that would work better in a different order, please let me know. You can do this by reporting an issue.\nHappy coding, Kasper Munch",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "chapters/python/before_you_begin.html",
    "href": "chapters/python/before_you_begin.html",
    "title": "2  Before you begin",
    "section": "",
    "text": "Install Python\nThis chapter serves to get the practicalities out of the way so you can start programming. Read the whole chapter once carefully before you install anything\nIn this course, we use the Python programming language and you need to install the Python program to run the code we will write. I have automated the installation procedure, which include a few other tools that you will also need later in the course:\nIf you see any red text during the installation, the installation was not successful. In that case take a screenshot and send it to kaspermunch@birc.au.dk.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Before you begin</span>"
    ]
  },
  {
    "objectID": "chapters/python/before_you_begin.html#install-python",
    "href": "chapters/python/before_you_begin.html#install-python",
    "title": "2  Before you begin",
    "section": "",
    "text": "Mac Windows\n\n\n\nClick the clipboard icon at the right end of the box below to copy the command to your clipboard.\nOpen your Terminal application.\nPaste the command into the Terminal window and press Enter. You will be prompted several times for either your user password or permissions of the installed apps.\n\n\ncurl -fsSL https://pixi.sh/install.sh | sh\nRestart your Terminal app and run this command:\npixi global install python\n\n\nInstall Pixi by downloading and running this interactive installer.\nOnce the Pixi installation has completed sucecssfully, you can install Python by opening Windows Powershell and paste this command into the window and press enter.\npixi global install python",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Before you begin</span>"
    ]
  },
  {
    "objectID": "chapters/python/before_you_begin.html#the-text-editor",
    "href": "chapters/python/before_you_begin.html#the-text-editor",
    "title": "2  Before you begin",
    "section": "The text editor",
    "text": "The text editor\nYou will also need a text editor. A text editor is where you write your Python code. For this course, we will use Visual Studio Code - or VScode for short. You can download it from this page. If you open VScode, you should see something like Figure 2.1. You may wonder why we cannot use Word to create and edit files with programming code. The reason is that a text editor made for programming, such as VScode, only saves the actual characters you type. So, unlike Word, it does not silently save all kinds of formatting, like margins, boldface text, headers, etc. With VScode, what you type is exactly in the file when you save it. In addition, where Word is made for prose, VScode is made for programming and has many features that will make your programming life easier.\n\n\n\n\n\n\nFigure 2.1: Visual Studio Code (VScode)",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Before you begin</span>"
    ]
  },
  {
    "objectID": "chapters/python/before_you_begin.html#the-terminal",
    "href": "chapters/python/before_you_begin.html#the-terminal",
    "title": "2  Before you begin",
    "section": "The terminal",
    "text": "The terminal\nThe last thing you need is a tool to make Python run the programs you write. Fortunately, that is already installed. On OSX, this is an application called Terminal. You can find it by typing “Terminal” in Spotlight Search. When you start, you will see something like Figure 2.2. You may be presented with the following text:\nThe default interactive shell is now zsh.\nTo update your account to use zsh, please run `chsh -s /bin/zsh`.\nFor more details, please visit https://support.apple.com/kb/HT208050.\n\n\n\n\n\n\nFigure 2.2: The Terminal app on Mac\n\n\n\n\n\n\n\n\n\nFigure 2.3: Anaconda Powershell Prompt app on Windows\n\n\n\nDo not update your account after you install Anaconda (see below). If you do, Terminal will not be able to find the Anaconda Python (If you did so by mistake, you change back using this command: chsh -s /bin/bash.\nOn Windows, the tool you need is called the Anaconda Powershell Prompt, which was installed along with Anaconda Python. You should be able to find it from the Start menu. Ensure you open Anaconda Powershell Prompt and not Anaconda Powershell Prompt. They are different programs. If you open Anaconda Powershell Prompt, you should see something like Figure 2.3.\nWhat is Anaconda Powershell Prompt and this Terminal thing? Both programs are what we call terminal emulators. They are used to run other programs, like the ones you will write yourself. I will informally refer to both Terminal and Anaconda Powershell Prompt as “the terminal.” So if I write something like “open the terminal,” you should open Anaconda Powershell Prompt if you are running Windows and the Terminal application if you are running OS X.\nThe terminal is a very useful tool. However, to use it, you need to know a few basics. First of all, a terminal lets you execute commands on your computer. You type the command you want and then hit enter. The place where you type is called a prompt (or command prompt), and it may look a little different depending on which terminal emulator you use. In this book, we represent the prompt with the character $. So, a command in the examples below is the line of text to the left of the $. When you open the terminal, you’ll be redirected to a folder. You can see which folder you are in by typing pwd, and then press Enter on the keyboard. When you press Enter, you tell the terminal to execute your written command. In this case, the command you typed tells you the path to the folder we are in. If I do it, I get:\n\n\nTerminal\n\n$ pwd\n/Users/kasper/programming\n\nIf I had been on a Windows machine, it would have looked something like this:\n\n\nTerminal\n\n$ cd\nC:\\Users\\kasper\\programming\n\nSo, right now, I am in the programming folder. /Users/kasper/programming is the folder’s path or “full address” with dashes (or backslashes on Windows) separating nested folders. So programming is a subfolder of kasper, a subfolder of Users. That way, you know which folder you are in and where that folder is. Let us see what is in this folder. You can use the ls command (l as in Lima and s as in Sierra). When I do that and press Enter I get the following:\n\n\nTerminal\n\n$ ls\nnotes projects\n\nThere seem to be two other folders, one called notes and another called projects. If you are curious about what is inside the notes folder, you can “walk” into the folder with the cd command. To use this command, you must specify which folder you want to walk into (in this case, notes). We do this by typing cd, then a space, and then the folder’s name. When I press Enter I get the following:\n\n\nTerminal\n\n$ cd notes\n$\n\nIt seems that nothing really happened, but if I run the pwd command now to see which folder I am in, I get the following:\n\n\nTerminal\n\n$ pwd\n/Users/kasper/programming/notes\n\nJust to keep track of what is happening: before we ran the cd command, we were in the directory /Users/kasper/programming folder, and now we’re in /Users/kasper/programming/notes. This means that we can now use the ls command to see what is in the notes folder:\n\n\nTerminal\n\n$ ls\n$\n\nAgain, it seems like nothing happened. Well, ls and dir do not show anything if the folder we are in is empty. So notes must be empty. Let us go back to where we came from. To walk “back” or “up” to /Users/kasper/programming, we again use the cd command, but we do not need to name a folder this time. Instead, we use the special name .. to say that we wish to go to the parent folder called programming, i.e., the folder we just came from:\n\n\nTerminal\n\n$ cd ..\n$ pwd\n/Users/kasper/programming\n\nWhen we run the pwd command, we see that we are back where we started. Let us see if the two folders are still there:\n\n\nTerminal\n\n$ ls\nnotes projects\n\nThey are!\nHopefully, you can now navigate your folders and see what is in them. You will need this later to access the folders with the code you write for the exercises and projects during the course.\n\n\n\nAction\nOSX\n\n\n\n\nShow current folder\npwd\n\n\nList folder content\nls\n\n\nGo to subfolder “notes”\ncd notes\n\n\nGo to parent folder\ncd ..",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Before you begin</span>"
    ]
  },
  {
    "objectID": "chapters/python/before_you_begin.html#create-a-conda-environment-for-the-course",
    "href": "chapters/python/before_you_begin.html#create-a-conda-environment-for-the-course",
    "title": "2  Before you begin",
    "section": "Create a conda environment for the course",
    "text": "Create a conda environment for the course\nIn bioinformatics, we install packages and programs to use them in our analyses and pipelines. Sometimes, however, the packages you need for one project conflict with the ones you need for other projects you work on in parallel. Such conflicts seem like an unsolvable problem. If only you could create a small insulated world for each project that only contained the packages you needed for that particular project. If each project lived in an isolated world, then there would be no such version conflicts. Fortunately, a tool lets you do just that, and its name is Conda.\n\nConda is an open-source environment management system for installing multiple versions of software packages and their dependencies and easily switching between them.\n\nThe small worlds that Conda creates are called “environments”. You can create as many environments as you like and then use each for a separate bioinformatics project, a course, a bachelor project, or whatever you want to insulate from everything else. Conda also downloads and installs the packages for you, ensuring that the software packages you install in each environment are compatible. It even makes sure that packages needed by packages (dependencies) are also installed. Conda is truly awesome.\nWhen you install Anaconda, Conda makes a single base environment for you. It is called “base”, and this is why it says “(base)” on your terminal.\nIn this course, you must install programs and Python libraries that could conflict with the packages you need for other courses or future projects. So, we will create an isolated Conda environment for Bioinformatics and Programming to avoid such conflicts. Conda is a program you run from the command line, like python or cd. So open your terminal (i.e., the “Terminal” program if you are on a Mac and the “Anaconda Powershell Prompt” program if you are on Windows). Now copy/paste these command lines into the terminal one at a time and press return (enter) after pasting each one:\n\n\nTerminal\n\nconda create -y -n bioprog\nconda activate bioprog\nconda config --env --add channels conda-forge\nconda config --env --add channels sepandhaghighi\nconda config --env --add channels kaspermunch\nconda install -y 'python=3.9' pygments textual rich art bp-help\n\nThis command runs the Conda program and tells it to create a new environment named “bioprog” and install the packages we need in that environment. Once you hit enter on the last command, Conda works for some time and then writes a long list of packages in your terminal. These are all the packages and dependencies required in versions that fit together.\nNotice how the command prompt changed from “(base)” to “(bioprog)” to show that you are now in the bioprog environment. It looks like nothing has changed, but now you can access unavailable terminal commands in the base environment. You’ll be able to learn about these later. Try this command:\nconda deactivate\nNotice how it again says “(base)” on your command prompt. That is because you are back in your base environment. When you start a new terminal window, you must run conda activate bioprog to activate the environment and access the course tools.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Before you begin</span>"
    ]
  },
  {
    "objectID": "chapters/python/before_you_begin.html#you-are-all-set",
    "href": "chapters/python/before_you_begin.html#you-are-all-set",
    "title": "2  Before you begin",
    "section": "You are all set",
    "text": "You are all set\nWell done! You are all set to start the course. Have a cup of coffee, and look forward to your first program. While you sip your coffee, I need you to take an oath (one of three you will take during this course). Raise your right hand! (put the coffee on your left).\n\nOath 1: I swear never to copy and paste code examples from this book into my text editor. I will always read the examples and then type them into my editor.\n\nThis serves three purposes (as if one was not enough):\n\nYou will be fully aware of every bit of each example.\nYou will learn to write code correctly and without omissions and mistakes.\nYou will get Python “into your fingers”. It sounds silly, but it will get into your fingers.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Before you begin</span>"
    ]
  },
  {
    "objectID": "chapters/python/writing_a_program.html",
    "href": "chapters/python/writing_a_program.html",
    "title": "3  Writing a program",
    "section": "",
    "text": "Hello World\nLet’s get you started…\nDive in and make your first program. Create a new file in your editor (VScode) and save it as hello.py. The .py suffix tells your editor that this file contains Python code. As you will see, this makes your life a whole lot easier. Such a file with Python code is usually called a script, but we can also call it a program.\nNow write exactly this in the file (hello.py):\nYour editor will color your code differently, but that is unimportant. Save your file with the added code and have your first program! Of course, there is not much point in having a program if it just sits there on your computer. To run your program, do the following:\nYou should see something like Figure 3.1.\nThis is where you shout, “It’s alive!” toss your head back, and do the insane scientist laugh.\nOkay, what just happened? You wrote a program by creating a file in which you wrote one line of code. You then ran the program using Python, and it wrote (printed) Hello world in the terminal. Do not worry about the parentheses and quotes for now; just enjoy your new life as a programmer.\nMaybe you wonder why we write print and not write or something else. That goes back to when computers were enormous, clunky things with no screens attached. They could only interact with the user by printing things on an actual physical paper printer. Back then, the output you now see on the screen was printed onto a piece of paper that the programmer could then look at. These days, print shows up in the terminal, but the story should help you remember that print spits text out of your program just like a printer.\nNow try to add another line of code like this:\nSave the file and run it again by typing python hello.py into your terminal and hitting Enter.\nYou should see this:\nNow your program prints Hello world and then prints I am your first program. The then-part is important. That is how a Python program works. Python (the python you write in front of hello.py) reads your hello.py file and then executes the code, one line after another, until it reaches the end of the file. This is essential, so reread from the beginning of the paragraph. Now, read it once more. It may seem trivial, but it is fundamental to remember that this is how Python runs your code. So here is Oath 2:\nWhen you write Python code, you always follow this workflow:\nMake sure you get the hang of this in the following exercises.\nImportant: The examples and exercises in this course are designed to work if you execute your scripts from their stored folder. So, you’ll need to go ahead and navigate the relevant folder before you’re done with your script. If your script is called hello.py, you must always execute it precisely like this: python hello.py. If you do it any other way, you may use a different Python version than you think. On some computers, it is possible to type hello.py without python in front of it. Don’t do that. Do not “drag” the script file into the Terminal either. In VScode, you can press a small play icon on the top right to execute the code. Don’t do that either. There are many other things you should not do, but you get the drift.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Writing a program</span>"
    ]
  },
  {
    "objectID": "chapters/python/writing_a_program.html#hello-world",
    "href": "chapters/python/writing_a_program.html#hello-world",
    "title": "3  Writing a program",
    "section": "",
    "text": "print(\"Hello world\")\n\n\nOpen the terminal and navigate to the folder (directory) where you saved hello.py. Use the cd command to do so. If you do not remember how, reread the previous chapter.\nType python hello.py in the terminal and hit Enter.\n\n\n\n\n\n\n\n\nFigure 3.1: Hello world\n\n\n\n\n\n\n\nprint(\"Hello world\")\nprint(\"I am your first program\")\n\n\nHello world\nI am your first program\n\n\nOath 2: I swear to always remember that each line of code in my script is executed one after another, starting from the first line and ending at the last line.\n\n\n\nChange the code in the file.\nSave the file.\nExecute the code in the file using the terminal.\nStart over.\n\n\n\n\nExercise 3-1\nTry swapping the two lines of code in the file and rerun the program. What does it print now?\n\n\nExercise 3-2\nTry to make the program print a greeting to yourself. Something like this:\nHello Sarah!\n– if your name is Sarah, of course.\n\n\nExercise 3-3\nAdd more lines of code to your program to make it print something else. Can you make your program print the same thing ten times?",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Writing a program</span>"
    ]
  },
  {
    "objectID": "chapters/python/writing_a_program.html#error-messages",
    "href": "chapters/python/writing_a_program.html#error-messages",
    "title": "3  Writing a program",
    "section": "Error Messages",
    "text": "Error Messages\nDid you get everything right with your first program, or did you get error messages when executing your code with python? Maybe you wrote the following code (adding an extra closing parenthesis):\nprint(\"Hello world\"))\n– and then got an error like this:\n  File \"hello.py\", line 1\n    print('Hello world'))\n                        ^\nSyntaxError: invalid syntax\nThis is Python’s way of telling you that the hello.py script has an error in line 1. If you write something that does not conform to the proper syntax for Python code, you will get a SyntaxError. Python will do its best to figure out where the problem is and point to it with a ^ character.\nYou will see many error messages in your new life as a programmer. So you must practice reading them. At first, they will be hard to decipher, but once you get used to them, they will help you quickly identify where the problem is. If there is an error message that you do not understand, the internet is your friend. Just paste the error message into Google’s search field, and you will see that you are not the only one on the internet getting started on Python programming. It is okay if you do not know how to fix the problem right now, but it is essential to remember that these error messages are Python’s way of helping you understand what you did wrong.\n\nExercise 3-4\nTry to break your new shiny program and make it produce an error message when you run it. An easy way of doing this is to remove or change random characters from the program. If you run this (with a missing end-parenthesis:\nprint(\"Hello world\"\nprint(\"I am your first program\")\nYou will get this error:\n  File \"hello.py\", line 2\n    print(\"I am your first program\")\n        ^\nSyntaxError: invalid syntax\nThe ^ character tells you when your code stops making sense to Python. Sometimes, that is a bit after where you made your mistake.\nTry to make other kinds of errors. Which error messages do you see? Do you always see the same error message, or are they different? Try googling the error messages you get. Can you figure out why the change you made broke the program? How many other error messages can you produce?",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Writing a program</span>"
    ]
  },
  {
    "objectID": "chapters/python/writing_a_program.html#strings",
    "href": "chapters/python/writing_a_program.html#strings",
    "title": "3  Writing a program",
    "section": "Strings",
    "text": "Strings\nIn programs, text values are called strings, and you have already used strings a lot in your first program. A string is simply a text, but we call it a string because it is a “string of characters”. In Python, we represent a string like this:\n\"this is a string\"\nor like this:\n'Hello world'\nThat is, we take the text we wish to use as our value and put quotes around it. We can use double quotes (the first example) or single quotes (the second example). We can mix them like this:\nprint('this is \"some text\" with a quote')\n– but not like this:\nprint(\"this is a broken string')\nCan you see why and how handy it is to have single and double quotes? If we did not have both, we could not have text with quotes. However, you must use the same kind of quotes at each end of the string. Running the latter example gives an error message telling you that Python cannot find the quote that was supposed to end the string:\n  File \"broken.py\", line 1\n    print(\"this is a broken string')\n                                   ^\nSyntaxError: EOL while scanning string literal\nIt is Python’s way of saying, ” I reached the end of the line (EOL) without finding a matching end quote.”",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Writing a program</span>"
    ]
  },
  {
    "objectID": "chapters/python/writing_a_program.html#comments",
    "href": "chapters/python/writing_a_program.html#comments",
    "title": "3  Writing a program",
    "section": "Comments",
    "text": "Comments\nYou have already learned that Python reads and executes one line of code at a time until your program has no more lines of code.\nHowever, we can make a line invisible to Python by putting a # symbol in front of it, like this:\n# print(\"Hello world\")\nprint(\"Greetings from your first program\")\nWhen you do that, Python does not read that line. It is not part of the program. Rerun the program. You will notice that now only the second line is part of your program:\n$ python hello.py\nGreetings from your first program\nThis is useful in two ways:\n\nIt lets you disable certain lines of your code by keeping Python from reading them. For example, see what happens if that line of code is not executed to understand how your program works.\nIt allows you to write notes in your Python code to help you remember how it works.\n\nLines with a # in front are called “comments” because we usually use them to write comments about our code. If you ask for help with some problem, you will often hear your instructor say: try to “comment out” in line two. When your instructor says that, it simply means that you should add a # in front of line two to see what then happens.\n\nExercise 3-5\nWhat happens if I put a # in the middle of a line of code? Try it out!\n\n\nExercise 3-6\nTry this:\n# Note to self: the lines below print stuff\nprint(\"Hello world\")\nprint(\"Greetings from your first program\")\n\n\nExercise 3-7\nTry this:\nprint(\"Hello world\") # actually, everything after a # is ignored\nprint(\"Greetings from your first program\")\nWhat did you learn? Which parts of each line are considered part of the program?\n\n\nExercise 3-8\nNow try this:\nprint(\"Hello # world\")\nprint(\"Greetings from your first program\")\nWhat did you learn about # characters in strings? #### Exercise Try this:\nprint(\"Hello world\"#)\nprint(\"Greetings from your first program\")\nDid you expect this to work? Why? Why not? What error message did you get?",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Writing a program</span>"
    ]
  },
  {
    "objectID": "chapters/python/dealing_with_values.html",
    "href": "chapters/python/dealing_with_values.html",
    "title": "4  Dealing with values",
    "section": "",
    "text": "Math\nThis chapter is about values and variables, the two most central concepts in programming.\nMuch programming is done to compute stuff. In Python, the usual math operations are done using these arithmetic operators:\nYou are probably quite familiar with these - except perhaps for integer division, exponentiation, and modulo. Let us take some of the operators for a spin. Remember to carefully write the whole thing in an empty file in VScode. Do not copy-paste. Then save the file as mathandlogic.py and run it from the terminal. Do not call your file math.py. It may bite you later. Just trust me on that one.\nNotice how you can print more than one thing at a time if you put commas between the values you want to print? We can group computations using parentheses, just like in normal math. Try this:\nIn addition to the regular math operators, there are a few extra operators that we call comparison operators because they are used to compare two values, e.g., two numbers.\nTry this:\nAs you may have noticed, running this code and comparing things using these operators, we always produce either True or False. E.g., the following\nprints the value True because 5 is smaller than 7. True and False are special values in Python that we can use (and print if we like) just like any other Python value:",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dealing with values</span>"
    ]
  },
  {
    "objectID": "chapters/python/dealing_with_values.html#math",
    "href": "chapters/python/dealing_with_values.html#math",
    "title": "4  Dealing with values",
    "section": "",
    "text": "Operator\nOperation\n\n\n\n\n+\nplus\n\n\n-\nminus\n\n\n/\ndivision\n\n\n//\ninteger division\n\n\n*\nmultiplication\n\n\n**\nexponentiation\n\n\n%\nmodulo (remainder)\n\n\n\n\nprint(\"Four times two is\",  4 * 2)\n\nprint(\"10 / (2 + 3) is\", 10 / (2 + 3))\nprint(\"(10 / 2) + 3 is\", (10 / 2) + 3)\n\n\n\n\nOperator\nOperation\n\n\n\n\n&lt;\nless-than\n\n\n&gt;\ngreater-than\n\n\n&lt;=\nless-than-or-equal\n\n\n&gt;=\ngreater-than-or-equal\n\n\n==\nequal\n\n\n!=\nnot equal\n\n\n\n\nprint(\"Is 5 greater than -2?\", 5 &gt; -2)\nprint(\"Is 5 greater or equal to -2?\", 5 &gt;= -2)\nprint(\"Is 5 less or equal to -2?\", 5 &lt;= -2)\nprint(\"Is 5 less than 7 - 2?\", 5 &lt; 7 - 2)\nprint(\"Is 5 equal to 7 - 2?\", 5 == 7 - 2)\n\nprint(5 &lt; 7)\n\nprint(True)\nprint(False)\n\nExercise 4-1\nTry to write and run the code below. Compare each line to what is printed when you run the code. Make sure you understand why.\nprint(\"I have\", 25 + 30 / 6, \"of something\")\nprint(\"I have\", 100 - 25 * 3 % 4, \"of something else\")\n\nprint(\"Is it true that 3 + 2 &lt; 5 - 7?\")\nprint(3 + 2.1 &lt; 5.4 - 7)\n\nprint(\"3 + 2.1 is\", 3 + 2.1)\nprint(\"5.4 - 7 is\", 5.4 - 7)\n\nprint(\"Oh, that's why it's False.\")\n\n\nExercise 4-2\nAn additional comparison operator even tests if something is a part of something else. That operator is called in. One use of it is to test if one string is part of another string. Try this to figure out how it works:\nprint(\"Hell\" in \"Hello world\")\nprint(\"Hello world\" in \"Hello world\")\nprint(\"Hello world\" in \"Hell\")\nprint(\"lo wo\" in \"Hello world\")\nprint(\"Artichoke\" in \"Hello world\")\n\n\nExercise 4-3\nSay the supermarket has chocolate bars for 7 kr. Write a small Python program (in a file called chocolate.py) that prints how many chocolate bars you can get for your 30 kr. You should run it like this;\nFor example, it could output something like this:\n$ python chocolate.py\nto have it print something like this:\nI can buy 4.285714285714286 chocolate bars!\n\n\nExercise 4-4\nWe mentioned a special operator called modulo. Google it if you do not remember what it does. How about integer division. Explain both to a fellow student (or to yourself out loud).\n\n\nExercise 4-5\nYou obviously cannot go buy 4.3 chocolate bars in a store. You will have to settle for 4. Can you change the program you made in Section 4.0.0.3 to print the number of bars you can buy and the change you then have left? Use the modulo and integer division operators. Something like:\nI can buy 4 chocolate bars, leaving me with 2 kr in change.\n\n\nExercise 4-6\nWhat happens if you try to run the following program?\nprint( 1 / 0 )\nIf you get an error? What kind of error? Why do you think you get that error? Do you think it makes sense?\n\n\nExercise 4-7\nYou probably know the Pythagorean theorem for computing a right-angled triangle’s hypotenuse (the longest side). The Pythagorean theorem looks like this: \\(a^2 + b^2 = c^2\\). Here \\(c\\) is the length of the hypotenuse, and \\(a\\) and \\(b\\) are the lengths of the triangle’s two legs. So if we have a triangle where \\(a = 5\\) and \\(b = 2\\) and we want to find \\(c^2\\) we can do this in Python:\nprint(\"The squared length of the hypotenuse is:\", 5**2 + 2**2)\n\n\nExercise 4-8\nHowever, we are rarely interested in the squared length of the hypotenuse. Can you modify the code you wrote in Section 4.0.0.7 so you compute \\(c\\) instead of \\(c^2\\)? Taking the square root of a number is the same as taking that number and exponentiating it to 0.5, so the square root of \\(x\\) is \\(x^{0.5}\\). Do you know of a Python operator that does exponentiation?",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dealing with values</span>"
    ]
  },
  {
    "objectID": "chapters/python/dealing_with_values.html#logic",
    "href": "chapters/python/dealing_with_values.html#logic",
    "title": "4  Dealing with values",
    "section": "Logic",
    "text": "Logic\nNow you know how to use the comparison operations to produce a True or False value. There are three additional operators that let you express more elaborate “True/False” statements than with the comparison operators alone. These are the logical operators: and, or and not.\n\nExercise 4-9\nGo through the code below and see if you can figure out what each line does. Then, write the code into your editor and run it to see what happens.\nprint(2 &lt; 3)\nprint(10 &lt; 12)\nprint(8 &gt; 100)\nprint(2 &lt; 3 and 10 &lt; 12)\nprint(8 &gt; 100 and 2 &lt; 3)\nprint(8 &gt; 100 or 2 &lt; 3)\nprint(not 8 &gt; 100 and 2 &lt; 3)\nprint(not 8 &gt; 100 and not 2 &gt; 3)\nDid it do what you expected? Can you explain each line?\n\n\nExercise 4-10\nWhen exposed to the operators and, or and not, some values are considered true and others are considered false. What happens when you put not in front of something that is considered true or false? Decide what you think and why before you write the code and try it out.\nprint(not True)\nprint(not False)\nprint(not 0)\nprint(not -4)\nprint(not 0.0000000)\nprint(not 3.14159265359)\nprint(not \"apple\")\nprint(not \"\")\nFrom the code above, try to find out which values Python considers true and which it considers false. Can you come up with a rule?\n\n\nExercise 4-11\nThe logical operator and takes two values (the one to the left of the operator and the one to the right) and figures out whether both the left and the right expression are true. It boils down to this:\n\n\n\nLeft expression\n Right expression\n Result\n\n\n\n\nTrue\nTrue\n True\n\n\nTrue\n False\n False\n\n\nFalse\n True\n False\n\n\nFalse\nFalse\n False\n\n\n\nWrite some code to confirm that the table above is correct using Python. For example, to test the first case, do this:\nprint(True and True)\n\n\nExercise 4-12\nPython will only do the necessary work to determine if a logical expression is true. That means that if the value left of and is considered false by Python, then there is no reason to look at the right value since it is already established that they are not both considered true. In this case the expression reduces to the left value. I.e. False and True reduces to False.\nIf Python considers the value left of and true, then It needs to look at the right value, too, to establish if they are both considered true. In this case, the expression reduces to the value on the right. I.e., True and False reduces to False.\nA rule of thumb is that the whole expression reduces to the last value that Python needs to consider to decide if the whole expression is true or false. Use that rationale to explain how the two last combinations in Section 4.0.0.11 are evaluated.\n\n\nExercise 4-13\nLike the and operator, the or operator also takes two values. However, the or operator determines whether one of the two values is true. Thus, the or operator boils down to this:\n\n\n\nLeft expression\n Right expression\n Result\n\n\n\n\nTrue\nTrue\n True\n\n\nTrue\n False\n True\n\n\nFalse\n True\n True\n\n\nFalse\nFalse\n False\n\n\n\nWrite some code using Python to confirm that the table above is correct. For example, to test the first case, do this:\nprint(True or True)\n\n\nExercise 4-14\nAs with the and operator, Python will not do any more work than absolutely necessary when evaluating an expression with ‘or’. So if the value left of or is considered true by Python, then there is no reason to look at the right value since it is already established that at least one of them is considered true. In this case the expression reduces to the left value. I.e. True or False reduces to True.\nIf the value left of or is considered false by Python, then Python still needs to look at the right value to establish if at least one of them is considered true. In this case, the expression reduces to the right value. I.e., False or True reduces to True.\nAgain, the whole expression reduces to the last value that Python needs to consider to decide if the whole expression is true or false. Use that same rationale to explain to yourself how the two last combinations in Section 4.0.0.13 are evaluated.\n\n\nExercise 4-15\nRemember what you learned in Section 4.0.0.10 about which values are considered true and which are considered false. Combine that with what you learned in Section 4.0.0.11 and Section 4.0.0.13 about what logical expressions reduce to and see if you can figure out what is printed below and why. Use the rule-of-thumb from Section 4.0.0.14. Decide what you think before you write the code and try it out.\nprint(True and 4)\nprint(0 and 7)\nprint(-27 and 0.5)\nprint(42 and 0)\nprint(\"apple\" and \"orange\")\nprint(\"apple\" and \"\")\nprint(42 or 0)\nprint(\"apple\" and \"\")\nprint(\"apple\" or \"\")\nIf you were surprised by what was printed, maybe go back and look at Section 4.0.0.11 and Section 4.0.0.13 again.\n\n\nExercise 4-16\nRecall the in operator from Section 4.0.0.2? There is also an operator called not in. I guess you can imagine what that tests. Try it out.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dealing with values</span>"
    ]
  },
  {
    "objectID": "chapters/python/dealing_with_values.html#variables",
    "href": "chapters/python/dealing_with_values.html#variables",
    "title": "4  Dealing with values",
    "section": "Variables",
    "text": "Variables\n\nBy now, you probably feel the first signs of brain overload. If you do not take breaks, your brain may overheat and explode - we have seen that happen. One of the nice things about the brain is that it works when you rest. Archiving and understanding a lot of new information takes time, and force-feeding your brain will not help. The last part of this chapter is very important so now might be a good time for a good long break.\n\nThis section is about variables and is where the fun begins. A variable is a way of assigning a name to a value. 8700000 is just a value, but if we assign a name to it, then it gets a special meaning:\nnumber_of_species = 8700000\nprint(number_of_species)\nIn this case, the variable number_of_species represents the estimated number of eukaryotic species on the planet, which is 8700000. So 8700000 is the value, and “number_of_species” is the variable name. Write the code above into a file and run it. Notice how this lets us refer to the value using the variable name. What appears in the terminal when you do that? Do you see number_of_species or 8700000?\nAs you can see in the small program above, one of two different things happens when a variable name appears in Python code:\n\nAssignment: When a variable name appears to the left of an equal sign, a value is assigned to the variable. This happens in the first line where number_of_species is assigned the value 8700000.\nSubstitution: In all other contexts, the variable is substituted for its value. This happens in the second line where Python substitutes the variable name number_of_species for its value 8700000 and then prints that.\n\nThat is it, but let us take the example further and create another variable to which we assign the value 1200000. That is the number of species discovered so far. Now, let us add this to the program and use it to compute the number of species we have yet to identify. Start by reading the code below super carefully. Remember that a variable is either assigned a value or substituted for the value it represents. For each occurrence of the variables below, determine if they are being assigned a value or if they are substituted for their value.\nnumber_of_species = 8700000\nnumber_discovered = 1200000\nnumber_unidentified = number_of_species - number_discovered\nprint(number_unidentified)\nNow write the code into a file and run it. Take some time to let it sink in that variables are extremely useful for two reasons:\n\nVariables give meaning to a value. Without the variable name, the value of 1200000 could just as well be the number of people that live in Copenhagen. However, by giving the value a meaningful name, it becomes clear what it represents.\nWe can assign new values to variables (that is why they are called variables). For example, we can change the value of number_discovered as new species are discovered.\n\nYour variable names can be pretty much anything, but they have to start with a letter or an underscore (_), and the rest of the name has to be either letters, numbers, or underscores. To be clear, a space is not any of those things, so do not use spaces in variable names. Above all, be careful in your choice of variable names. Variable names are case-sensitive, meaning that count and Count are different variables. Stick to lowercase variable names. That makes your code easier to read.\n\nExercise 4-17\nFor each occurrence of the variables below, determine if they are being assigned a value or if they are substituted for their value.\nbreeding_birds = 4\nprint(breeding_birds)\nbreeding_birds = 5\nprint(breeding_birds)\n\n\nExercise 4-18\nFor each occurrence of the variables below, determine if they are being assigned a value or if they are substituted for their value.\nbreeding_birds = 4\nprint(breeding_birds)\nbreeding_birds = breeding_birds + 1\nprint(breeding_birds)\n\n\nExercise 4-19\nWhat happens if you take the first example in this section and swap the two lines? So, going from this:\nnumber_of_species = 8700000\nprint(number_of_species)\nto this:\nprint(number_of_species)\nnumber_of_species = 8700000\nExplain to yourself what happens in each case. What kind of error do you get with version two, and why? Remember Oath 2!\n\n\nExercise 4-20\nWrite the following code in a file, save it, and run it.\nincome = 45000\ntaxpercentage = 0.43\ntax_amount = tax_percentage * income\nincome_after_tax = income - tax_amount\nprint('Income after tax is', income_after_tax)\nYou should get an error that looks at lot like this one:\nTraceback (most recent call last):\n  File \"tax.py\", line 3, in &lt;module&gt;\n    tax_amount = tax_percentage * income\nNameError: name 'tax_percentage' is not defined\nIt says that the error is on line 3. Can you figure out what is wrong? Hopefully, you will now appreciate how much attention to detail is required when programming. Every tiny, little symbol or character in your code is essential.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dealing with values</span>"
    ]
  },
  {
    "objectID": "chapters/python/dealing_with_values.html#different-types-of-values",
    "href": "chapters/python/dealing_with_values.html#different-types-of-values",
    "title": "4  Dealing with values",
    "section": "Different types of values",
    "text": "Different types of values\nBy now, you probably have a pretty good idea of what a value in Python is. So far, you have seen text like 'Banana', integers like 7, and numbers with a fractional part like 4.25.\nIn Python, a text value is a type of value called a string, which Python denotes as str (abbreviation for “string”). So 'Banana' is a string, and so is 'Banana split'. There are two types of numbers in Python. Integers (7, 42, and 3) are called int. Numbers with a fractional part (like 3.1254 and 4.0) are that are called float (an abbreviation for “floating-point number”).\nAs I mentioned earlier, True and False are Python values too. They are called booleans or bool, named after an English mathematician called George Boole famous for his work on logic.\nSo the different types of values we know so far are:\n\n\n\nName\nType in Python\nExamples\n\n\n\n\nString\nstr\n\"hello\", '9'\n\n\nInteger\nint\n0, 2721, 9\n\n\nFloating-point\nfloat\n1.0, 4.4322\n\n\nBoolean\nbool\nTrue, False\n\n\nNone\nNoneType\nNone\n\n\n\nIn case you did not notice, I added a special type at the end that can only have the value None. I may sound a little weird, but in programming, we sometimes need a value representing nothing or None. For now, just make a mental note that None is also a Python value.\nWhen you do computations in Python, it is no problem to mix integers and floating-point numbers. Try this:\nprint(\"What is 0.5 * 2?\", 0.5 * 2)\nprint(\"What is 3 / 2?\", 3 / 2)\nAs you can see we can also make computations using only integers that result in floating-point numbers.\nSome of the math operators not only work on numbers, but they also work on strings. That way, you can add two strings together. It is no longer math, of course - but quite handy.\nfruit = 'Ba' + 'na' + 'na'\nprint(fruit)\n\nExercise 4-21\nIf you try to combine different types of values in ways that are not allowed in Python, you will get an error. Try each of the following weird calculations, and read each error message carefully.\nx = 3 - '1.5'\nprint(x)\nx = None - 4\nprint(x)\n\n\nExercise 4-22\nWrite these two examples and compare the resulting values of x\nx = '9' + '4'\nprint(x)\nx = 9 + 4\nprint(x)\n\n\nExercise 4-23\nTry these two examples. What happens in each case? Does it make sense?\nx = '72' * 3\nx = '72' * '3'\n\n\nExercise 4-24\nWill this work? Use what you have learned from the other exercises and try to predict what will happen here. Then, write the code and try it out.\nx = 'Ba' + 'na' * 2\nprint(x)\n\n\nExercise 4-25\nSometimes, you may need to change a string to a number. You can do that like this:\nsome_value = \"42\"\nother_value = int(some_value)\nWrite some code that converts strings to numbers and numbers to strings. Remember that numeric values are either integers or float. Use int, float as in the example above. You will notice that only meaningful conversions work. E.g., this will not work: number = int('four'). To convert a number to a string, you can use str.\nHaving completed the above exercises, you should take note of the following four important points:\n\nAll Python values have a type. You know about strings, integers, floating-points, and booleans so far.\nMath operators let you do cool things like concatenating two strings by adding them together.\nThe flip side of that cool coin is that Python will assume you know what you are doing if you add two strings ('4' + '4' is '44' not 8) or multiply a string with an integer ('4' * 4 is '4444' not 16).\nYou can change the type of a value, e.g., '4' to 4 or 1 to 1.0.\nPython will throw a TypeError if you try to combine types values of values in ways that are not allowed.\n\n\nEscape characters: An escape character is a backslash \\ followed by a single character. \\n and \\t are the most commonly used ones.\n\n\n\nExercise 4-26\nWhat do you think is printed here?\nmain_course = 'Duck a la Banana\\n'\ndessert = 'Banana split\\n'\nmenu = main_course + dessert\nprint(menu)\nCan you figure out what the special character \\n represents?\n\n\nExercise 4-27\nWhat do you think is printed here?\n\ndish_one = 'Banana\\t\\tsplit'\ndish_two = 'Chocolate\\tcake'\nprint(dish_one)\nprint(dish_two)\nCan you figure out what the special character \\t represents?",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dealing with values</span>"
    ]
  },
  {
    "objectID": "chapters/python/dealing_with_values.html#mixed-exercises",
    "href": "chapters/python/dealing_with_values.html#mixed-exercises",
    "title": "4  Dealing with values",
    "section": "Mixed exercises",
    "text": "Mixed exercises\nEach chapter in the book ends with a set of mixed exercises meant to allow you to combine what you have learned so far. In this case, they are meant to train your familiarity with the following topics:\n\nStrings\nMath\nLogic\nTypes of values\nVariables\n\n\nExercise 4-28\nWhat happens if you try to run the following program?\nprint(\"What happens now?\", 1 / )\nIf you get an error, why do you think you get that error?\n\n\nExercise 4-29\nWhat happens if you try to run the following program?\nprint(\"What happens now?\", 1 / 3\nIf you get an error, why do you think you get that error? Can you fix it? (Hint: EOF is short for End Of File)\n\n\nExercise 4-30\nDetermine, for each of the eight occurrences of the variable x below, where it is being assigned a value and when it is substituted for its value:\nx = 1\nx = x + 1\nx = x + 1\nx = x + 1\nprint(x)\nThen, figure out what is printed and why (remember oath 2). What value does x represent at each occurrence in the code?\n\n\nExercise 4-31\nSome comparison operators also work with strings. Consider this code:\nprint(\"apples\" == \"pears\")\nWhat is printed here? Write the code and see for yourself once you think you know. If you were wrong, make sure you understand why.\n\n\nExercise 4-32\nConsider this code:\nprint('aaaaaa' &lt; 'b')\nprint('a' &lt; 'b')\nprint('aa' &lt; 'ab')\nprint('99' &gt; '100')\nprint('four bananas' &gt; 'one banana')\nWhat is printed here? Write the code and see for yourself once you think you know. By what rule does Python decide if one string is smaller than another? You may have a clue if you have looked something up in an encyclopedia recently. Also, try to google “ASCII table”.\n\n\nExercise 4-33\nConsider this code:\nprint('banana' &lt; 'Banana')\nWhat is printed here? Write the code and see for yourself once you think you know.\n\n\nExercise 4-34\nDo you think it is allowed to use relational operators on values of different types? Try these out and see for yourself:\nprint('Banana' &gt; 4)\nprint('42' == 43) # this one is dangerous...\nprint(4 in '1234')\nPractice reading this kind of error (TypeError).\n\n\nExercise 4-35\nCan you use the in operator to test if this mini gene is part of the DNA string?\nmini_gene = 'ATGTAG'\ndna_string = 'GCTATGTAGGTA'\n\n\nExercise 4-36\nSay you have two strings \"4\" and \"2\". What happens if you add them like this: \"4\" + \"2\". Can you convert each one to integers so you get 6 when you add them? (have a look at Section 4.0.0.25 if you do not remember).\n\n\nExercise 4-37\nWhat happens if you run this code? Do you get an error? Do you remember why?\n1value = 42\n\n\nExercise 4-38\nWhat happens if you run this code?\nprint('Hi')\nprint('Hi')\nprint('Hi')\nCompare this to what happens when you run this code:\nprint('Hi\\nHi\\nHi')\nDo you remember what \\n represents? What does it tell about what is added at the end every time you print something?\n\n\nExercise 4-39\nMake three exercises for your fellow students. See if you can make them so they test the understanding of (almost) all you have learned so far.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dealing with values</span>"
    ]
  },
  {
    "objectID": "chapters/python/the_order_of_events.html",
    "href": "chapters/python/the_order_of_events.html",
    "title": "5  The order of events",
    "section": "",
    "text": "Precedence of Operators\nThis chapter is about how Python interprets (or evaluates) the code you write. It has a few fancy long words that may seem foreign to you. Do not let that throw you off. They are all just fancy names for something straightforward.\nFear not. Precedence is just a nasty word for something we have already talked about. Precedence just means that some things are done before others or, more correctly, that some operations are performed before others. You already know that multiplication is done before addition. Another way of saying that is that multiplication takes precedence over addition. The expression below obviously reduces to 7 in two steps:\n\\[ 1 + 3 * 2 \\]\nFirst, \\(3 * 2\\) reduces to 6, and then \\(1 + 6\\) reduces to 7. If we wanted to add 1 and 3 first, we would need to enforce this by adding parentheses:\n\\[ (1 + 3) * 2 \\]\nThis is because the multiplication operator (*) has higher precedence than the addition operator (+). Here is the list of the most common operators and their precedence in Python:\nSometimes, a statement contains adjacent operators with the same precedence. In this case, Python evaluates the expression from left to right. I.e., This following expression first reduces to \\(0.5 * 2\\) and then to \\(1\\)\nThe following one first reduces to \\(1 * 4\\) and then to \\(4\\):\nIf you want Python to order the operations in any other way, you need to use parentheses (E.g., 2 / (2 * 4)).",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The order of events</span>"
    ]
  },
  {
    "objectID": "chapters/python/the_order_of_events.html#precedence-of-operators",
    "href": "chapters/python/the_order_of_events.html#precedence-of-operators",
    "title": "5  The order of events",
    "section": "",
    "text": "Level\nCategory\nOperators\n\n\n\n\nHighest\nexponent\n**\n\n\n\npositive / negative\n+x, -x\n\n\n\nmultiplication\n*, /, //, %\n\n\n\naddition\n+, -\n\n\n\nrelational\n!=, ==, &lt;=, &gt;=, &lt;, &gt;, in, not in\n\n\n\nlogical\nnot\n\n\n\nlogical\nand\n\n\nLowest\nlogical\nor\n\n\n\n\n2 / 4 * 2\n\n2 / 2 * 4\n\n\nExercise 5-1\nLook at each expression in the exercises below and use the table above to decide if it evaluates to True or False. Then, write the code and test if you were right. If not, figure out why.\n2 + 4 * 7 == 2 + (4 * 7) \n\n\nExercise 5-2\nDoes this reduce to True or False?\n4 &gt; 3 and 2 &lt; 1 or 7 &gt; 2\n\n\nExercise 5-3\nDoes this reduce to True or False?\n4 &gt; 3 and (2 &lt; 1 or 7 &gt; 2)\n\n\nExercise 5-4\nDoes this reduce to True or False?\n2 * 4 ** 4 + 1 == (2 * 4) ** (4 + 1)",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The order of events</span>"
    ]
  },
  {
    "objectID": "chapters/python/the_order_of_events.html#statements-and-expressions",
    "href": "chapters/python/the_order_of_events.html#statements-and-expressions",
    "title": "5  The order of events",
    "section": "Statements and Expressions",
    "text": "Statements and Expressions\nTo talk concisely about programming (and to receive more useful help from your instructors), you need to have a bit of vocabulary. Statements and expressions are two words you need to know. Distinguishing between statements and expressions will help us discuss our code.\n\nA statement is a line of code that performs an action. Python evaluates each statement until it reaches the end of the file (remember oath 2?). print(y * 7) is a statement, and so is x = 14. They each represent a full line of code and perform an action.\nAn expression is any code that reduces to one value. y * 7 is an expression, and so are y * 7 + 14 - x and 4 &gt; 5.\n\nWe will talk more about how Python handles expressions in the next section, but right now, you must understand that statements do something while expressions are things that reduce to a value. Hopefully, this distinction will be more clear after completing the following exercises.\n\nExercise 5-5\nDid you notice in the above examples that print(y * 7) is a statement and y * 7 is an expression? Yes, expressions can be part of statements. In fact, they most often are. Similarly, expressions are often made up of other smaller expressions. E.g., y * 7 is part of the longer expression y * 7 + 14 - x.\nTake a look at this code:\nx = 5\ny = 20\nz = (x + y) / 2 + 20\nprint(z * 2 + 1)\nh = 2 * x - 9 * 48\nprint(h)\nWrite down the code on a piece of paper. Now, mark all statements and all expressions. Remember that expressions are often made up of smaller expressions so that you can find a lot of them. E.g. (x + y), 2 + 20, and (x + y) / 2 + 20 are all expressions. A single variable (like x) is also a small expression. Discuss with a fellow student. Do you agree on what to find?\n\n\nExercise 5-6\nConsider the following code:\ngreeting = 'Hello' + ' my '\nprint(greeting + 'friend')\nHow many statements are there in this piece of code? How many expressions?",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The order of events</span>"
    ]
  },
  {
    "objectID": "chapters/python/the_order_of_events.html#substitution-and-reduction",
    "href": "chapters/python/the_order_of_events.html#substitution-and-reduction",
    "title": "5  The order of events",
    "section": "Substitution and Reduction",
    "text": "Substitution and Reduction\nAlthough substitution and reduction may not sound like your new best friends, they truly are! If you remember to think about your Python code in terms of substitution and reduction, then programming will make a lot of sense. Understanding and using these simple rules will allow you to read and understand any code. If you do not, you may get by for a while - only to find yourself in big trouble later when things become more complicated.\nYou should remember, from the section on variables in the previous chapter, that variables in Python are either assigned a value or substituted for the value they represent.\nIn the first two lines of code below, the variables x and y are each assigned a value. Now consider the last line in the example:\nx = 4\ny = 3\nz = x * y + 8\nHere, x is substituted by the value 4, and y is substituted by the value 3. So now the expression after the equals sign reads 4 * 3 + 8. Because we multiply before we add, 4 * 3 reduces to 12 so that the expression now reads 12 + 8. Finally, this reduces to the value 20. The very last thing that happens is that the variable z is assigned the value 20.\nYou should do these steps every time you see an expression. You may think this is overdoing things a bit, but it is not. This kind of explicit thinking is what programming is all about, and it will become increasingly important as the course progresses. So make sure you make it a habit while it still seems trivial. Then, over time, it will become second nature.\nNow raise your right hand and read the third and last oath out loud:\n\nOath 3: I now solemnly swear to consciously consider every single substitution and reduction in every Python expression that I read or write from this moment on.\n\nThis was the last of the three oaths, but it is by far the most important one. You can take your hand down now.\nNB: You may not realize this at this point, but the last two subsections are the most important ones in the book. Go back and read them many times as you proceed through the course. If you explicitly think in terms of substitution and reduction, you will be fine. If you do not, you are entering a minefield with snowshoes on.\n\nExercise 5-7\nDo the substitution and reduction steps with pen and paper, then run it to check yourself by inserting a print statement at the end.\nx = 7\ny = 4 + x\n2 + x * x**2 + y - x\n\n\nExercise 5-8\nDo the substitution and reduction steps with pen and paper, then run it to check yourself by inserting a print statement at the end.\na = 4\nb = a\nc = 2\nc = a + b + c\n\n\nExercise 5-9\nDo the substitution and reduction steps with pen and paper, then run it to check yourself by inserting a print statement at the end.\nx = 1\nx = x\n\n\nExercise 5-10\nDo the substitution and reduction steps with pen and paper, then run it to check yourself by inserting a print statement at the end.\nmicrosatellite = \"GTC\" * 41\nSurprised?\n\n\nExercise 5-11\nDo the substitution and reduction steps with pen and paper, then run it to check yourself by inserting a print statement at the end.\nmini_gene = \"ATG\" + \"GCG\" + \"TAA\"\nWhat did you do first here? Does the order of additions matter? What operations does Python perform first when operators have the same precedence? (left to right or right to left)\n\n\nExercise 5-12\nDo the substitution and reduction steps with pen and paper, then run it to check yourself by inserting a print statement at the end.\nnumber = 1 / 1 * 4\nIn what order are reductions made? Does the order of operations matter, and in what order does Python do the reductions?\n\n\nExercise 5-13\nDo the substitution and reduction steps with pen and paper, then run it to check yourself by inserting a print statement at the end.\nx = 4\ny = x + x\n\n\nExercise 5-14\nDo the substitution and reduction steps with pen and paper, then run it to check yourself by inserting a print statement at the end.\nx = 4\nx = x + 1\n\n\nExercise 5-15\nDo the substitution and reduction steps with pen and paper, then run it to check yourself by inserting a print statement at the end.\nx = 4\nx += 1\nCompare the final value of x to that in Section 5.0.0.14. Can you see what += is a shorthand for? Nifty, right?",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The order of events</span>"
    ]
  },
  {
    "objectID": "chapters/python/the_order_of_events.html#general-exercises",
    "href": "chapters/python/the_order_of_events.html#general-exercises",
    "title": "5  The order of events",
    "section": "General exercises",
    "text": "General exercises\nThe following exercises are meant to train your familiarity with the topics we have treated so far – in this case especially:\n\nSubstitution\nReduction\nAssignment\nSimple precedence rules\nComparison operators\nLogical operators\nDistinction between text and numbers\n\nRead each exercise and think hard about the questions before you code anything. Then write the code and try it out. Remember that it is crucial that you type it in – as super dull as it may be (remember oath one). This trains your accuracy and attention to detail, and it builds programming into your brain. Play around with each bit of code. Make small changes and see how it behaves.\nThere is a reason why there are lots of questions in this exercise but no answers. You are supposed to find them yourself if it takes you quite a while. That is the way you build understanding. Some of the questions may seem trivial, but do them anyway. If you only understand these concepts superficially, they will come back and bite you in the ass when things get more complicated.\n\nExercise 5-16\nConsider this code:\n1.2 * 3 + 4 / 5.2\nWhat does that expression evaluate to? Try to explicitly make all the reductions on paper before you write and run the code.\n\n\nExercise 5-17\nConsider this code:\n1.2 * (3 + 4) / 5.2\nWhat does that expression evaluate to? Try to explicitly make all the reductions on paper before you write and run the code.\n\n\nExercise 5-18\nConsider this code:\n10 % 3 - 2\nWhat does that expression evaluate to? Try to explicitly make all the reductions on paper before you write and run the code.\n\n\nExercise 5-19\nConsider this code:\n11 % (7 - 5)**2\nWhat does that expression evaluate to? Try to explicitly make all the reductions on paper before you write and run the code.\n\n\nExercise 5-20\nConsider this code:\na = 5\nx = 9\nbanana = 7\nx + 4 * a &gt; banana\nWhat does the last expression evaluate to? Try to explicitly make all the substitutions and reductions on paper before writing the code. What happens if you write and run the code? Why?\n\n\nExercise 5-21\nConsider this code:\ndance = 'can'\ndance = dance + dance\nprint(\"Do the\", dance)\nWhat is printed? Try to explicitly make all the substitutions and reductions on paper before writing the code. What happens if you write and run the code? Why?\n\n\nExercise 5-22\nConsider this code:\nfoo = 30\nbar = 50\nbaz = bar + foo\nprint(baz)\nbar = 10\nprint(baz)\nThere are two print statements. The first print statement prints 80. But what about the second print statement? Does that print 80 or 40? Find out and make sure you understand why it prints what it prints. If not, reread the section on substitution.\n\n\nExercise 5-23\nConsider this code:\n1 == '1'\nand this:\n1 == 1.0\nWhat does this reduce to? Try printing it and seeing once you think you know. If you were wrong, make sure you figure out why.\n\n\nExercise 5-24\nConsider this code:\na = '1'\nb = '2'\nc  = a + b\nprint(a, b, c)\nprint(a + b == 3)\nWhat is printed here? Write the code and see for yourself once you think you know. If you were wrong, make sure you understand why.\n\n\nExercise 5-25\nConsider this code:\na = 1\nb = 2\nc  = a + b\nprint(a, b, c)\nprint(a + b == 3)\nWhat is printed here? Compare to Section 5.0.0.24. Write the code and see for yourself once you think you know. If you were wrong, make sure you understand why.\n\n\nExercise 5-26\nConsider this code:\nx = 4\nprint(x + 2 and 7)\nprint(x + 2 or 7)\nx = -2\nprint(x + 2 and 7)\nprint(x + 2 or 7)\nWhat is printed here? Write the code and see for yourself once you think you know. If you were wrong, make sure you understand why.\n\n\nExercise 5-27\nI have shuffled the statements in the code below. Put them in the right order to make the code print 100.\nx = x + 4\nprint(x)\nx = x * 5\nx = x * x\nx = 4\n\n\nExercise 5-28\nI have shuffled the statements in the code below. Put them in the right order to make the code print the string `“Banana.”\ny = 'n'\nx = 'B' + y + x\nprint(x)\nx = 'a'\ny = (x + y) * 2\n\n\nExercise 5-29\nMake a puzzle exercise, like the two previous ones, for a fellow student.\n\n\nExercise 5-30\nRemind yourself of the different types of Python values you know. For example, one of them is an integer (int). Make a list.\n\n\nExercise 5-31\nYou already know about several types of data values in Python. Two are integers called int, and decimal numbers (or floating points) called float. When you use an operator like + or &gt; it produces a value. No matter what you put on either side of &gt; it produces a boolean value (bool), True or False. For other operators, the type of value produced depends on which values the operator works on. Try this and see if you print an integer or a float (8 or 8.0):\nx = 4\ny = 2\nresult = x * y\nprint(result)\nNow try to replace 4 with 4.0. What type is the result now? Try to also replace 2 with 2.0. What type is the result now? Can you extract a rule for what the * operator produces depending on what types the two values have?\n\n\nExercise 5-32\nIn Section 5.0.0.31, you investigated what types of values the * operator produces. Redo that exercise with the operators: +, -, /, **, //, and %. What are the rules for what is returned if both values are integers, one value is a float, or both values are floats?\n\n\nExercise 5-33\nMake a list of all the operators you know so far in order of precedence (without looking in the notes). Then check yourself.\n\n\nExercise 5-34\nWhat does his expression reduce to, and what type of value is it?\n3 &gt; 2\n\n\nExercise 5-35\nWhat does his expression reduce to, and what type of value is it? Do all the reduction steps in your head.\n2 - 4 * 5 - 2 * 1/3\n\n\nExercise 5-36\nWhat does his expression reduce to, and what type of value is it? Do all the reduction steps in your head.\n3 &gt; 2 and 2 - 4 * 5 - 2 * 9\n\n\nExercise 5-37\nWhat is printed here and why?:\nprint(True and \"banana\" or \"orange\")\nTry to change the True value to False and see what happens. Can you explain it? If not, look at Section 4.0.0.14 again.\n\n\nExercise 5-38\nWhat does his expression reduce to? Do all the reduction steps in your head.\n0 and 1 or 2\n\n\nExercise 5-39\nWhat does his expression reduce to? Do all the reduction steps in your head.\n4 and 1 or 2\n\n\nExercise 5-40\nIf you understood Section 5.0.0.37, then you should also understand this one:\nweather = 'rain'\nwhat_to_do = weather == 'rain' and 'watch movies' or 'go swimming'\nprint(what_to_do)\nWhat happens if you change 'rain' in the first line to something else (like 'sun')?\n\n\nExercise 5-41\nWhat is the value of results once the code below has run? Do the substitutions, reductions, and assignments in your head before you run the code.\nx = 7\ny = 13\nz = x + y\nx = 0\nresult = x + y + z\n\n\nExercise 5-42\nWhat is the value of results once the code below has run? Do the substitutions, reductions, and assignments in your head before you run the code.\nx = 5\ny = x + 1\nx = y + 1\ny = x + 1\nresult = x + y\n\n\nExercise 5-43\nIn the code below I have shuffled the statements. Put them in the right order to make the code print 9. To do that you must think about which values each variable will in each statement depending on the how you order the statements.\nx = x + 1\ny = 5\ny = y - 1\nprint(y)\nx = 1\ny = y * x\n\n\nExercise 5-44\nIn the code below, I have shuffled the statements. Put them in the right order to make the code print 'Mogens'\nc = b\nprint(c)\na = b + a\nb = 'og'\nb = c + a\nc = 'M'\na = 'ens'\n\n\nExercise 5-45\nMake three exercises that require the knowledge of programming so far. Have your fellow students solve them.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The order of events</span>"
    ]
  },
  {
    "objectID": "chapters/python/course_tools.html",
    "href": "chapters/python/course_tools.html",
    "title": "6  Course tools",
    "section": "",
    "text": "Wax on, wax off\nSeeing the sequence of substitutions and reductions in a Python expression will become natural over time. Until it does, you are in troubled waters, and if you do not practice in time, you may only realize this too late. Considering how simple this is to practice and how crucial it is to your progress, I have written a small companion program called myiagi where you can train this particular skill daily. The program is installed in the conda environment you created for this source, so make sure it is activated as described. To run the program, you execute this command in the terminal:\nIt should look like Figure 6.1, and the simple game is as follows. The program generates a Python expression. From that expression, all the substitution and reduction steps are performed. Each substitution or reduction results in an intermediate expression until only a single Python value remains. Here is an example where the expression is 4 * y + x and the value it reduces to is 37:\nYou do not know what values the y and x variables point to, but you can deduce it from the sequence of expressions that they are 24 and 13. In the game, you are given a series of numbered expressions in the wrong order like this:\nYour task is to put them in the right order so that the original expression is at the top and the single Python value it reduces to is at the bottom. Now, you might grab line 2 by tabbing 2 on your keyboard (the number turns red so you can see it is active). Then, you move the line using the up/down arrow keys. If you move it to the bottom, the list then looks like this:\nNow, you repeat this process until the order is correct (the program will let you know when it is). The fewer lines you grab to produce the right order, the more points you earn. Problems with longer lists of expressions also earn you more points. As problems become harder and include more aspects of Python, solving them also awards more points. Each week has a score goal to guide your effort. Reaching this goal ensures that you practice as much as you should. Practicing a bit every day daily is more effective than practicing a lot a few days a week. To provide an incentive, the points you earn slowly expire, so the easiest way to maintain your score is to practice a bit every day.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Course tools</span>"
    ]
  },
  {
    "objectID": "chapters/python/course_tools.html#wax-on-wax-off",
    "href": "chapters/python/course_tools.html#wax-on-wax-off",
    "title": "6  Course tools",
    "section": "",
    "text": "Mr. Miyagi: First, wash all car. Then wax. Wax on…\nDaniel: Hey, why do I have to…?\nMr. Miyagi: Ah ah! Remember deal! No questions!\nDaniel: Yeah, but…\nMr. Miyagi: Hai! Wax on, right hand. Wax off, left hand. Wax on, wax off. Breathe in through nose, out of mouth. Wax on, wax off. Don’t forget to breathe, very important. [walks away, still making circular motions with hands] Wax on… wax off. Wax on… wax off.\n\n\nmyiagi\n\n\n\n\n\n\nFigure 6.1: Visual Studio Code (VScode)\n\n\n\n\n1.   4 * y + x\n2.   4 * 8 + x\n3.   24 + x\n4.   24 + 13\n5.   37\n\n1.   4 * y + x\n2.   37\n3.   4 * 8 + x\n4.   24 + x\n5.   24 + 13\n\n1.   4 * y + x\n2.   4 * 8 + x\n3.   24 + x\n4.   24 + 13\n5.   37",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Course tools</span>"
    ]
  },
  {
    "objectID": "chapters/python/course_tools.html#a-helping-hand",
    "href": "chapters/python/course_tools.html#a-helping-hand",
    "title": "6  Course tools",
    "section": "A helping hand",
    "text": "A helping hand\nUsing the myiagi, you train your ability to read and understand Python expressions. Seeing a similar breakdown of a Python expression in your code may also be helpful. For that purpose, I have written another tool called print-steps. Say you have some code like the one below and need clarification on how the single value assigned to z is produced (here, you are probably not).\nx = 7\ny = 5\nz = x * y + 4\nAll you need to do is then to add # PRINT STEPS comment to the end of the line like this:\nx = 7\ny = 5\nz = x * y + 4 # PRINT STEPS\nSay your file is called myfile.py, you would normally run the code like this:\n\n\nTerminal\n\npython myfile.py\n\nBut to see the breakdown of expressions marked by # PRINT STEPS, you need to run your code with the print-steps program instead:\n\n\nTerminal\n\nprint-steps myfile.py\n\nThe command prints the following in the terminal:\nLine 4 in test_studentfile.py:\nAs written:      z = x * y + 4\nSubstitution:    z = 7 * y + 4\nSubstitution:    z = 7 * 5 + 4\nReduction:       z = 35 + 4\nReduction:       z = 39\nYou can even mark more than one line like this and have print-steps break down all of them for you:\nx = 7\ny = 5\nz = x * y + 4 # PRINT STEPS\nk = z * 42 # PRINT STEPS\nlike this:\nLine 3 in myfile.py:\nAs written:      z = x * y + 4\nSubstitution:    z = 7 * y + 4\nSubstitution:    z = 7 * 5 + 4\nReduction:       z = 35 + 4\nReduction:       z = 39\n\nLine 4 in myfile.py:\nAs written:      k = z * 42\nSubstitution:    k = 39 * 42\nReduction:       k = 1638\nHowever, it would be best if you used this helping hand sparingly. It is much better to train your ability to do this in your head with the help of Mr. Myagi. Trust me, it works.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Course tools</span>"
    ]
  },
  {
    "objectID": "chapters/python/controlling_behavior.html",
    "href": "chapters/python/controlling_behavior.html",
    "title": "7  Controlling behavior",
    "section": "",
    "text": "If-statement\nThis chapter is about how you make your program do different things under different circumstances. Making functionality dependent on data is what makes programs useful.\nSo far, the small programs you have written run the same sequence of statements (lines). Imagine if you could control which statements were run depending on the circumstances. Then, you would be able to write more flexible and useful programs. Cue the music - and let me introduce the “if-statement”.\nWrite the following carefully into a file. It is a small program that monitors bus passenger status. Notice the colon ending the if-statements. Also, note that the lines below each if-statement are indented with precisely four spaces. While writing the program, figure out what the if-statement does. Then, run the code and see what happens.\nTry changing the values of bus_seats, passengers, and bags and see how the program executes.\nYou have probably realized that the if-statements control which prints statements that are evaluated. A statement nested under an if-statement is only evaluated if the expression between the if keyword and the : reduces to a value Python considers as true. This does not happen if the expression between the if and : reduces to a value Python considers false.\nWhen asked to evaluate something as true or false, Python will interpret zero and empty values (like 0 and '') as False and all other non-zero and non-empty values as True.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Controlling behavior</span>"
    ]
  },
  {
    "objectID": "chapters/python/controlling_behavior.html#if-statement",
    "href": "chapters/python/controlling_behavior.html#if-statement",
    "title": "7  Controlling behavior",
    "section": "",
    "text": "bus_seats = 32\npassengers = 20\nbags = 20\n\nprint(passengers, \"people ride the bus\")\n\nif bus_seats &gt;= passengers + bags:\n    print(\"Smiles, everyone has room for bags\")\n\nif bus_seats &gt;= passengers:\n    print('Everyone gets to sit down, no complaints')\n\nif bus_seats &lt; passengers:\n    print('Some passengers standing, annoyed')\n    \nif bus_seats &lt; passengers / 3:\n    print(\"General dissatisfaction, some swearing too\")\n\n\n\n\nExercise 7-1\nWhich of the following letters are printed: A, B, C, D, E, F, G. Make up your mind before you write and run the code.\nif 0:\n    print('A')\n\nif \"Banana\":\n    print('B')\n\nif 3.14159265359:\n    print('C')\n\nif False:\n    print('D')\n\nif 9 &gt; 5 and 4 &lt; 7:\n    print('E')\n\nif '':\n    print('F')\n\nif False or \"banana\":\n    print('G')\n\n\nExercise 7-2\nWhat happens if you forget to write the : in the if-statement?\nif 4 &gt; 2\n    print('Hi!')\n\n\nExercise 7-3\nWhat happens if you do not indent the code under the if-statement?\nif 4 &gt; 2:\nprint('Hi!')\n\nBy now, you probably know that your text editor is intelligent regarding indentation. If you hit Enter after a statement ending with :, it will indent the next line with four spaces. Also, if you use the tab in Python code, it will produce four spaces for you.\n\n\n\nFAQ\nQ: Isn’t “If” a poem by Rudyard Kipling?\nA: Yes.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Controlling behavior</span>"
    ]
  },
  {
    "objectID": "chapters/python/controlling_behavior.html#else-statement",
    "href": "chapters/python/controlling_behavior.html#else-statement",
    "title": "7  Controlling behavior",
    "section": "Else-statement",
    "text": "Else-statement\nSometimes you not only want your program to do something if an expression reduces to True, you also want it to do something else if it is False. It is as simple as it looks:\ncookies = 3\n\nif cookies &gt; 0:\n    print(\"Uh, I wonder if we have some milk too...\")\nelse:\n    print(\"Sigh!\")\nRemember to put a : after the else keyword. Write the code and change the value of cookies to 0.\n\nExercise 7-4\nTest your understanding about which expressions that reduce to a True or False value. Write the code below and then see how it responds to different values of x. Try to come up with other variations yourself.\nx = 0.0\n# x = '0'\n# x = '   '\n# x = ''\n# x = not 0\n# x = 'zero'\n\nif x:\n    print('x is substituted with True in the if-statement')\nelse:\n    print('x is substituted with False in the if-statement)\n\n\nFAQ\nQ: Isn’t “Else” a poem by Rudyard Kipling?\nA: No.\n\nExercise 7-5\nWhat do you think this code prints? Notice how you can nest if and else-statements under other if and else-statements. This way, you can make your program include only some statements when certain combinations of conditions are met. Just remember that the code below each if or else is indented by four spaces. Try to change the True/False values of milk and cookies.\nmilk = False\ncookies = True\nif milk:\n    if cookies:\n        status = 'Good times!'\n    else:\n        status = 'Not thirsty, thanks or asking'\nelse:\n    if cookies:\n        status = 'How does something like this happen?'\n    else:\n        status = 'Whatever...'\n        \nprint(status)",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Controlling behavior</span>"
    ]
  },
  {
    "objectID": "chapters/python/controlling_behavior.html#blocks-of-code",
    "href": "chapters/python/controlling_behavior.html#blocks-of-code",
    "title": "7  Controlling behavior",
    "section": "Blocks of code",
    "text": "Blocks of code\nIn the examples above, some lines are indented more than others, and you probably already have some idea of how Python interprets this. Indentation defines blocks of code. The if and else statements control each code block’s evaluation when your code runs. The following three rules define individual blocks of code:\n\nAll statements in a code block have the same indentation. That is, they line up vertically.\nA block of code begins at the first line of code at a line that is indented more than the one before it.\nA block ends when it is followed by a less indented line or at the last line of code.\n\nThis way, a block can be nested inside another block by indenting it further to the right, as shown in Figure 7.1. Compare the example in Figure 7.1 to the code example above. Note how a colon at the end of a statement means “this applies the block of code below”. Make sure you understand which print statements are controlled by which if and else statements.\n\n\n\n\n\n\nFigure 7.1: The amount of indentation defines blocks of code",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Controlling behavior</span>"
    ]
  },
  {
    "objectID": "chapters/python/controlling_behavior.html#elif-statement",
    "href": "chapters/python/controlling_behavior.html#elif-statement",
    "title": "7  Controlling behavior",
    "section": "Elif-statement",
    "text": "Elif-statement\nSay you need to test several mutually exclusive scenarios. For example, if a base is equal to A, T, C, or G. You can do that like in the example below, but it is very verbose and shifts your code further and further to the right.\nbase = 'G'\n\nif base == 'A':\n    print('This is adenine')\nelse:\n    if base == 'T':\n        print('This is thymine')\n    else:\n        if base == 'C':\n            print('This is cytosine')\n        else:\n            print('This is guanine')\nThis is where an elif statement can be helpful. It is basically short for “else if.” The correspondence is hopefully obvious if you compare it to the example below.\nbase = 'G'\n\nif base == 'A':\n    print('This is adenine')\nelif base == 'T':\n    print('This is thymine')\nelif base == 'C':\n    print('This is cytosine')\nelse:\n    print('This is guanine')\nHere, we put an else-statement at the end to capture all cases not covered by the if-statement and the two elif-statements.\n\nExercise 7-6\nYou can use logical operators (and, or, not) in the expressions tested in an if-statement. Can you change the program from Section 7.0.0.5 so that there are no nested if-statements - in a way that the program still does the same? You can use if, elif, and else and test if, e.g., milk and cookies are true using and.\n\n\nExercise 7-7\nThe snippet of code below has three blocks with three statements. Which statements belong to which block? Which statements are executed?\nx = 5\nif x &gt; 4:\n    y = 3\n    if x &lt; 1:\n        x = 2\n        y = 7\n        z = 1\n    x = 1\nz = 4\n\n\nExercise 7-8\nCan you see four blocks of code? If not, read the three rules above again. Which statements are executed?\nx = 5\nif x &gt; 4:\n    y = 3\n    if x &lt; 1:\n        x = 2\n        y = 7\n    else:\n        x = 1\n        y = 9\nz = 4",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Controlling behavior</span>"
    ]
  },
  {
    "objectID": "chapters/python/controlling_behavior.html#general-exercises",
    "href": "chapters/python/controlling_behavior.html#general-exercises",
    "title": "7  Controlling behavior",
    "section": "General exercises",
    "text": "General exercises\n\nExercise 7-9\nWill this print You are a superstar!?\nif -4 and 0 or 'banana' and not False:\n    print(\"You are a super star!\")\n\n\nExercise 7-10\nWill this print You are a superstar!?\nif -1 + 16 % 5 == 0 :\n    print(\"You are a super star!\")\n\n\nExercise 7-11\nAssign values to two variables, x and y. Then, write code that prints OK if (and only if) x is smaller than five and y is larger than five. Do it using two if statements:\nx = 3 # or something else\ny = 7 # or something else\n\n# rest of code here...\nNow solve the same problem using only one if statement.\n\n\nExercise 7-12\nAssign values to two variables, x and y. Then, write some code that prints OK if and only if x is smaller than five or y is larger than five. Do it using two if statements:\nx = 3 # or something else\n7 = 7 # or something else\n\n# rest of code here...\nNow solve the same problem using only one if statement and one elif statement.\n\n\nExercise 7-13\nAssign values to two variables, x and y. Then, write some code that prints OK if either x or y is zero but not if both are zero (this is tricky).\nx = 3 # or something else\ny = 7 # or something else\n\n# rest of code here...\n\n\nExercise 7-14\nWhich value of x makes the code below print Banana?\nx = \ns = ''\nif x**2 == 16:\n    s = s + 'Ba'\nif x + 6 == 2:\n    s = s + 'na'\nif 7 == x - 3:\n    s = 'na' * 2\nelse:\n    s = s + 'na'\nprint(s)\n\n\n\nExercise 7-15\nMake three exercises that require the knowledge of programming so far. Have your fellow students solve them.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Controlling behavior</span>"
    ]
  },
  {
    "objectID": "chapters/python/organizing_your_code.html",
    "href": "chapters/python/organizing_your_code.html",
    "title": "8  Organizing code",
    "section": "",
    "text": "Functions\nThis chapter is about organizing your code into chunks that you can call upon to perform well-defined tasks in your program.\nBuckle down for the most powerful and useful thing in programming. Functions! Functions serve as mini-programs that perform small, well-defined tasks in your program.\nI have started to write a song about functions:\nI will add many more verses, and I do not want to write the entire chorus every time. So what would be more natural than to make a function named chorus that takes care of that for us? That way, we can write our song the way lyrics with a chorus are usually written:\nFirst, let us break down the function definition in the top part of this code:\nWhen Python runs this code, each line is executed one by one, starting from the first line (remember oath two?). So, in this case, python first executes the definition of the chorus function. The only thing that happened after Python had executed the first five lines of code was that it assigned the name chorus to the four indented statements. So Python now “knows” about the chorus function (like it “knows” about a variable x after we do x = 4).\nTo use the function, we “call” it by writing its name followed by parentheses: chorus(). When it comes to functions, “use”, “call” and “run” means the same thing. As you can see, we call the function twice in the rest of the code. Each time we do, the following happens:\nSo, the key properties of functions are:",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Organizing code</span>"
    ]
  },
  {
    "objectID": "chapters/python/organizing_your_code.html#functions",
    "href": "chapters/python/organizing_your_code.html#functions",
    "title": "8  Organizing code",
    "section": "",
    "text": "print(\"Functions are super, Functions are cool\")\nprint(\"When writing a program they are a great tool\")\nprint(\"La la dim du da da di\")\nprint(\"Skubi dubi dumdi di\")\nprint(\"Bing di dubi dum da di\")\n\nprint(\"Functions are used to package some code\")\nprint(\"They are not so strange that your head will explode\")\nprint(\"La la dim du da da di\")\nprint(\"Skubi dubi dumdi di\")\nprint(\"Bing di dubi dum da di\")\n\ndef chorus():\n    line1 = \"La la dim du da da di\"\n    line2 = \"Skubi dubi dumdi di\"\n    line3 = \"Bing di dubi dum da di\"\n    return line1 + '\\n' + line2 + '\\n' + line3\n\nprint(\"Functions are super, Functions are cool\")\nprint(\"When writing a program they are a great tool\")\nprint( chorus() )\n\nprint(\"Functions are useful to wrap up some code\")\nprint(\"They are not so strange that your head will explode\")\nprint( chorus() )\n\n\nWe define a function with the def keyword (which is short for “define” in case you wonder).\nAfter def, we write the function chorus. We could name it something else, but like good variable names, good function names can help you remember what your code does.\nAfter the name, you put two parentheses, ().\nThen a colon, :.\nThe statements that are part of the function are nested under the def statement and are indented with four spaces exactly like we do under if-statements.\nThe return statement ends the function. After the return keyword, the expression reduces to a value that the function returns.\n\n\n\n\nWhen a function is called, each statement in the definition is executed one after the other. If you look at the function definition, you can see that our chorus function has four statements.\nThe first statement assigns a string value to the line1 variable.\nThe second statement assigns a string value to the line2 variable.\nThe third statement assigns a string value to the line3 variable.\nThe fourth statement is a return statement. The expression after the return keyword in the final statement is reduced to a value, and this value is substituted for the function call. In this case, that value is the following string:\n\n\"La la dim du da da di\\nSkubi dubi dumdi di\\nBing di dubi dum da di\"\n\n\nA function names a piece of code (some statements) just like variables name values like strings and numbers.\nWe call a function by writing the function name followed by parentheses: chorus(). Just writing the function name will not call the function.\nWhen a function is called, it is substituted by the value that the function returns – exactly like a variable in an expression is substituted by its value. It is crucial that you remember this.\n\n\nExercise 8-1\nNow that we have a chorus function, that part is out of the way, and we can concentrate on our song without worrying about remembering how many “la la”s it has and so on. Try to change the “lyrics” in the chorus a little bit. Notice how you only need to make the change in one place to change all the choruses in the song – cool, right? Without the function, you would have to rely on correctly changing the code in many different places.\n\n\nExercise 8-2\nTry to delete the return statement in the chorus function (the last line in the function) and run the code again. You should see something like this:\nFunctions are super, Functions are cool\nWhen writing a program they are a great tool\nNone\nFunctions are used to wrap up some code\nThey are not so strange that your head will explode\nNone\nThe function call (chorus()) is now substituted with None. How can that be when we did not return anything? The reason is that when you do not specify a return statement, the function returns None by default. This is to honour the rule that variables and a function calls are substituted by a value, and None is simply the value that Python uses to represent “nothing”. None is a value denoting the lack of value. As you just saw, it represents that no value is returned from a function. It can also be assigned to a variable as a placeholder value until another value is assigned:\nx = None\nx = 4\nAlso, None is considered false in a logical context:\nprint(not None)\n\n\nExercise 8-3\nTry this variant to the chorus function. Go through the code slowly and repeat all the steps to break down what happens when a function is called. Remember also to do each substitution and reduction carefully.\ndef chorus():\n    line1 = 'La la'\n    line2 = 'Du bi du'\n    return line1 + '\\n' + line2\nDo the same for this variant:\ndef chorus():\n    line1 = 'La la'\n    line2 = 'Du bi du'\n    chrous_text = line1 + '\\n' + line2\n    return chrorus_text\nand for this variant:\ndef chorus():\n    return \"La la\\nDu bi du\"\n\n\nExercise 8-4\nWhat do you think happens if you move the definition of chorus to the bottom of your file? Decide what you think will happen and why (maybe you remember what happens when you try to use a variable in an expression before defining it?). Then try it out.\nprint(\"Functions are super, Functions are cool\")\nprint(\"When writing a program they are a great tool\")\nprint( chorus() )\n\nprint(\"Functions are useful to wrap up some code\")\nprint(\"They are not so strange that your head will explode\")\nprint( chorus() )\n\ndef chorus():\n    line1 = \"La la dim du da da di\"\n    line2 = \"Skubi dubi dumdi di\"\n    line3 = \"Bing di dubi dum da di\"\n    return line1 + '\\n' + line2 + '\\n' + line3\nEnsure you understand how the error you get relates to how Python runs your script (remember oath two?). If you still need help understanding, do the next exercise and then return to this one.\n\n\nExercise 8-5\nWhich error do you get here, and why? How is that similar to the error in the previous exercise?\nprint(x)\nx = 7\n\n\nExercise 8-6\nConsider the code below. Do all the substitution and reduction steps in your head. Remember that each function call is substituted by the value that the function returns. Then run it.\ndef lucky_number():\n    return 7\n\nx = lucky_number()\ny = lucky_number()\ntwice_as_lucky = x + y\nprint(twice_as_lucky)\nNow, change the code to that below. The code makes the same computation but in fewer steps. Do all the substitution and reduction steps.\ndef lucky_number():\n    return 7\n\ntwice_as_lucky = lucky_number() + lucky_number()\nprint(twice_as_lucky)\nNow, change the code to the one below. The code makes the exact computation but in fewer steps. Do all the substitution and reduction steps.\ndef lucky_number():\n    return 7\n\nprint(lucky_number() + lucky_number())",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Organizing code</span>"
    ]
  },
  {
    "objectID": "chapters/python/organizing_your_code.html#functions-can-take-arguments",
    "href": "chapters/python/organizing_your_code.html#functions-can-take-arguments",
    "title": "8  Organizing code",
    "section": "Functions can take arguments",
    "text": "Functions can take arguments\nThe functions we have written so far are not very flexible because they return the same thing every time they are called. Now write and run this beauty:\ndef square(number):\n    squared_number = number**2\n    return squared_number \n\nresult = square(3)\nprint(result)\nNotice how we put a variable (number) between parentheses in the function definition. This variable is assigned the value we put between the parentheses (3) when we call the function. So when we call like that (square(3)), Python automatically makes the assignment number = 3.\nHere is another example:\ndef divide(numerator, denominator):\n    result = numerator / denominator \n    return result\n\ndivision_result = divide(44, 77)\nprint(division_result)\nWhen the function call divide(44, 77), these two things implicitly happen: numerator = 44 and denominator = 77.\nTake note of the following three important points: 1. The values that we pass to the function in the function call (like 3, 44, and 77) are called arguments. It is crucial to remember that it is values and not variables that are passed to functions. 2. The variables in the definition line of a function, like number, numerator and denominator, are called parameters. They hold the values passed to the function when it is called (the arguments). 3. You can define functions with any number of parameters if you use the same number of arguments when you call the function.\n\nExercise 8-7\nTry to call your divide function like this divide(77, 44). What does it return, and what do you learn from it? Does the order of arguments and parameters correspond?\n\n\nExercise 8-8\nTry to call your divide function like this divide(44). Do you get an error, and what do you learn from that?\n\n\nExercise 8-9\nTry to call your divide function like this divide(44, 77, 33). Do you get a different error message, and what do you learn from that?\n\n\nExercise 8-10\nRead this code and do all substitution and reduction steps from beginning to end.\ndef square(x):\n    return x ** 2\n\nresult = square(9) + square(5)\nprint(\"The result is:\", result)\nNow replace the line return x ** 2 with print(x ** 2). What is printed now and why?\n\n\nExercise 8-11\nAs described above, a return statement ends the function by producing the value that replaces the function call. If a function has more than one return statement, then the function ends when the first one is executed.\ndef assess_number(x):\n    if x &lt; 3:\n        return 'quite a few'\n    if x &lt; 100:\n        return 'a lot'\n    return 'a whole lot'\n\nnr_apples = 2\nprint(nr_apples, \"apples is\", assess_number(nr_apples))\nWhat happens when x is 2, 3, 50, 200? Think about it first.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Organizing code</span>"
    ]
  },
  {
    "objectID": "chapters/python/organizing_your_code.html#functions-and-variables",
    "href": "chapters/python/organizing_your_code.html#functions-and-variables",
    "title": "8  Organizing code",
    "section": "Functions and variables",
    "text": "Functions and variables\nA function call is the temporary little world that only exists when the function is called and until it returns its value. It did not exist before the function was called, and it does not exist after the function returns its value. By necessity, the variables defined in your function are also temporary.\nThis means variables defined inside a function are private to each function call. It also means that variables defined inside functions are unavailable to code outside the function. Running the following example should help you understand this:\ndef make_greeting():\n    greeting = 'Guten tag'\n    name = 'Heinz' \n    message = greeting + \" \" + name\n    return message\n\ngreeting = 'Buongiorno'\nname = 'Giovanni'\nprint( make_greeting() )\nprint(greeting + \" \" + name)\nNotice how Heinz and Giovanni are greeted in their native languages. This means that the variable definitions inside the function do not overwrite the Italian versions already defined outside the function. This is because the variables defined in the function are temporary and private to the function, even if they have the same names as variables outside the function. This is why the function call make_greeting() in the print statement does not change the variables’ values printed in the last line.\nNow try to “comment out” the line greeting = 'Guten tag' and run the example again. All of a sudden, Heinz is greeted in Italian! The reason is that now Python cannot find a definition of greeting inside the function. It then looks outside the function for a definition and finds the Italian version.\nNow try to “comment out” the line greeting = 'Buongiorno' and run the example again. You get an error, but which one? Python complains that it cannot find a definition of greeting. The reason is that once the last print statement is executed, the small world of the function call in the previous line no longer exists.\nYou should learn two rules from the above example:\n\nAll variables you define inside a function are private to the function. If a variable in a function has the same name as a variable in the main script (like greeting above), then these are two separate variables that just happen to have the same name.\nWhen you use a variable like greeting in the function (E.g., message = greeting + \" \" + name), Python checks if the variables have been defined in the function. If that is not the case, then it will look for it outside the function. In the above example, name is found in the function, and greeting is found outside the function. It is good practice to make your functions “self-contained” in the sense that Python should not have to look outside the function for variables.\n\n\nExercise 8-12\nTry this version of the example above. Now, name is defined as a function parameter, but it is still a function variable, just like greeting.\ndef make_greeting(name):\n    greeting = \"Guten tag\"\n    message = greeting + \" \" + name\n    return message\n\ngreeting = 'Buongiorno'\nname = 'Giovanni'\nprint( make_greeting(\"Heinz\") )\nprint(greeting + \" \" + name)\n\n\nExercise 8-13\nConsider the following example:\ndef double(z):\n    return z * 2\n   \nx = 7\nresult = double(x)\nprint(result)\nWhen the function is called (double(x)), the x is substituted by its value 7. That value is passed as the argument and assigned to the function parameter z (z = 7). z is a private function variable and does not exist before or after the function call. Does this change in any way if we use the variable name x instead of z, as shown below?\ndef double(x):\n    return x * 2\n   \nx = 7\nresult = double(x)\nprint(result)\nDo all substations and reductions for each line of code from top to bottom. Keep the sequence of events in mind and remember that a function definition is merely a template describing a mini-world that is created anew every time the function is called.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Organizing code</span>"
    ]
  },
  {
    "objectID": "chapters/python/organizing_your_code.html#builtin-functions",
    "href": "chapters/python/organizing_your_code.html#builtin-functions",
    "title": "8  Organizing code",
    "section": "Builtin functions",
    "text": "Builtin functions\nSo far we have only talked about functions you write yourself, but Python also has built-in functions that are already available to you. They work just like a function you would write yourself. You already know the print function quite well; that is an example of a function that prints something but returns None. There are many other useful built-in functions, but I will tell you about another two: len and type.\n\nExercise 8-14\nTry these examples:\nx = 'Banana'\nprint(\"The value of variable x is of type\", type(x))\nprint(\"The value of variable x has length\", len(x))\nAs you can see, type returns the type of the value passed as the argument, and len returns the length of the value passed as the argument. The type function is handy if you wonder what type a value has, but it is not a function we will use in this course. The len function, however, is your new best friend. You will see why soon enough.\n\n\nExercise 8-15\nTry to change the value of the x in Section 8.0.0.14 to an integer or a float and see what happens when you run it. Do you get an error? Does it make sense that not all types of values can meaningfully be said to have a length?\n\n\nExercise 8-16\nWhat happens if you pass an empty string (\"\") as the argument to the len function?\n\n\nExercise 8-17\nWhat is printed here? Think about it first, and then try it out. Remember to do the substitution and reduction steps.\nreturn_value = print(\"Hello world\")\nprint(return_value)\n\n\nExercise 8-18\nWhat is printed here? Think about it firs,t and then try it out. Remember to do the substitution and reduction steps.\nprint(print(\"Hello world\"))",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Organizing code</span>"
    ]
  },
  {
    "objectID": "chapters/python/organizing_your_code.html#general-exercises",
    "href": "chapters/python/organizing_your_code.html#general-exercises",
    "title": "8  Organizing code",
    "section": "General exercises",
    "text": "General exercises\nThe following exercises treat the areas we have worked on in this and previous chapters. They are meant to train your familiarity with if-statements and functions. Remember that the purpose of the exercises is not to answer the questions but to train the chain of thought that allows you to answer them. Play around with the code for each example and see what happens if you change it a bit.\n\nExercise 8-19\nConsider this function definition that takes a single number as the argument:\ndef square(n):\n    return n**2\nWhat does it do? What does it return? What number does square(2) then represent?\nBelow, I have used it in some printed expressions. Make sure you understand what each expression evaluates to. Make the explicit substitutions and reductions on paper before you run it. Remember that we substitute a function call (like square(2)) for the value it returns, just like a variable x substitutes for the value it points to.\nprint(square(3))\nprint(square(2 + 1))\nprint(square(2) * 2 + square(3))\nprint(square(square(2)))\nprint(square(2 * square(1) + 2))\n\n\nExercise 8-20\nWhat does this function do? How many parameters does it have? How many statements does the function have? What does the function print? Which value does it return?\ndef power(a, b):\n    print(\"This function computes {}**{}\".format(a, b))\n    return a**b\n\nprint(power(4, 2))\nTry (possibly strange) variations of the code like the ones below better to understand the contribution of each line of code. What is the difference between return and print? What happens when Python gets to a return statement in a function? What happens when the function does not have a return statement?\nVariation 1:\ndef power(a, b):\n    print(\"This computes\", a, \"to the power of\", b)\n    print(a**b)\n\nresult = power(4, 2)\nprint(result)\nVariation 2:\ndef power(a, b):\n    print(\"This computes\", a, \"to the power of\", b)\n    return a**b\n\nresult = power(4, 2)\nprint(result)\nVariation 3:\ndef power(a, b):\n    print(\"This computes\", a, \"to the power of\", b)\n    a**b\n\nprint(power(4, 2))\nVariation 4:\ndef power(a, b):\n    return a**b\n    print(\"This computes\", a, \"to the power of\", b)\n\nprint(power(4, 2))\n\n\nExercise 8-21\nDefine a function called diff, with two parameters, x and y. The function must return the difference between the values of x and y.\nExample:\ndef diff(x, y):\n    ...\n\ndiff(8, 2) # should return 6\ndiff(-1, 2) # should return -3\nSave the value returned from the function in a variable. Then, test if the function works correctly by comparing the result to what you know is the true difference (using ==).\n\n\nExercise 8-22\nDefine a function called all_equal that takes five arguments and returns True if all five arguments have the same value and False otherwise. The function should work with any input, for example:\nall_equal(\"Can\", \"Can\", \"Can\", \"Can\", \"Can\")\nall_equal(0, 0, 0, 0, 0)\nall_equal(0.5, 0.5, 0.5, 0.5, 0.5)\nall_equal(True, True, True, True, True)\nHint: You test equality with a == b. Now, think back to what you learned about logic. Which operator can you use to test if a == b and b == c?\n\n\nExercise 8-23\nDefine a function called is_even, which takes one argument and returns True if (and only if) this is an even number and False otherwise (remember the modulo operator?).\nis_even(8) # should return True\nis_even(3) # should return False\n\n\nExercise 8-24\nDefine a function called is_odd, which takes one argument and returns True if (and only if) the argument is an odd number and False otherwise.\nis_odd(8) # should return False\nis_odd(3) # should return True\nCan you complete this exercise using the is_even you defined in Section 8.0.0.23? How? Why is that a good idea?\n\n\nExercise 8-25\nHere is a function that should return True if given an uppercase (English) vowel and False otherwise:\ndef is_uppercase_vowel(c):\n    c == 'A' or c == 'E' or c == I or c == 'O' or c == 'U'\n    \nchar = 'A' \nif is_uppercase_vowel(char):\n    print(char, \"is an uppercase vowel\")\nelse:\n    print(char, \"is NOT an uppercase vowel\")\nNow you can just type the code exactly as shown and run it. Do you get what you expect? Does the code work? If not, try to figure out why. Try to print the value that the function returns. Do you know if that gives you any hints about the cause of the problem?\n\n\nExercise 8-26\nDefine a function called is_nucleotide_symbol, which takes one argument and returns True if this is either A, C, G, T, a, c, g or t, and False in any other case.\nName your parameter something sensible like symbol.\nis_nucleotide_symbol(\"A\") # should return True\nis_nucleotide_symbol(\"B\") # should return False\nis_nucleotide_symbol(\"Mogens\") # should return False\nis_nucleotide_symbol(\"\") # should return False\n\n\nExercise 8-27\nDefine a function called is_base_pair which takes two parameters, base1, base2, and returns True if base2 is the complementary of base1, and False otherwise.\nis_base_pair(\"A\", \"G\") # should return False\nis_base_pair(\"A\", \"T\") # should return True\nis_base_pair(\"T\", \"A\") # should return True\nis_base_pair(\"Preben\", \"A\") # should return False\n\n\nExercise 8-28\nDid you find the bug in Section 8.0.0.25? You were supposed to find that the function did not have a return value. This makes the function return None by default. Do you think the None value is considered true or false in an if-statement?\n\n\nExercise 8-29\nDefine a function called celcius2fahrenheit that converts from celsius to Fahrenheit. You can do this because you know the linear relationship between the two. On Figure 8.1 you can see that the slope is 9 / 5 and the intercept is 32. The function should have one parameter celsius. Inside the function, you should define the variables slope and intercept and give them the appropriate values. Then you can calculate the conversion to Celcius using these variables and return the result.\n\n\n\n\n\n\nFigure 8.1: Temperature conversion\n\n\n\n\n\nExercise 8-30\nTry to change your conversion function so it takes three arguments, corresponding to celsius, slope and intercept so you can call it like this to convert 27 degrees celsius: conversion(37, 9 / 5, 32). Now you have a function that can do any linear conversion that you can put inside another function like this:\ndef celcius2fahrenheit(celsius):\n    return conversion(celsius, 9 / 5, 32)\n\n\nExercise 8-31\nNow try to extend this to a different problem: It has been found that the height and weight of a person are related by a linear equation with slope = 0.55 and intercept = -25. Define a function called predict_weight which takes just one argument, the height of a person, and returns the estimated weight of the person.\n\n\nExercise 8-32\nBy now you know that some of the words in your code have specific purposes. def defines functions, return returns value from a function, and is a logical operator etc. Here is a list of the ones you will see in this course: and, assert, break, continue def, del, elif, else, False, for, from, if, import, in, is, not, or, pass, return, while, True, None (you can see a full list here)\nThese words are reserved for their special purposes in Python and you will not be allowed to assign values to them. Try this to see for yourself:\nNone = 4\nor this:\nand = 2\n\n\nFAQ - Frequently Asked Questions\nQ: Can function names be anything?\nA: Just about. The rules that apply to variable names also apply to function names. Good function names are lower case with underscores (_) to separate words, like in the examples above.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Organizing code</span>"
    ]
  },
  {
    "objectID": "chapters/python/python_values_are_objects.html",
    "href": "chapters/python/python_values_are_objects.html",
    "title": "9  Values are objects",
    "section": "",
    "text": "Methods\nThis chapter introduces the notion of an object, one of the most central aspects of Python. Once you catch your breath, you will love that all Python values are objects.\nIn Python, a value like an integer or string not only holds data. It is also packaged with a lot of useful functionality relevant to the particular type of value. When a value is packaged with such relevant functionality and meta information, programmers call it an object—and in Python, all values are objects.\nThe associated functionality comes in the form of methods. You can think of methods as functions that are packaged together with the value. For example, string values have a method called capitalize. Try it out:\nTo call the method on the string value, you connect the string value and the method call with a dot. So, to call a method on a value, you do the following:\nYou can see that the method call looks just like a function call, and in many ways, calling a method works much like calling a function. The difference is that when we call a function, we say: “Hey function, capitalize this string!”. When we call a method, we say: “Hey string, capitalize yourself!”\nSo why do we need methods? Why do we need them when we have functions? It is very handy to have some relevant and ready-to-use functionality packaged together with the data it works on. You will start to appreciate that sooner than you think.\nMethods are almost always used with variables. So remember to make any substitutions and reductions required. When we put a method call after a variable like below, the variable is first substituted for its value, and then the method is called on the value. Consider the second line of this example:\nHere, x is first substituted by \"banana\" and then the method is called on that value, like this: \"banana\".capitalize().\nNow write and run these examples:\nYou can see what these methods do. For example: upper returns an uppercased copy of the string.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Values are objects</span>"
    ]
  },
  {
    "objectID": "chapters/python/python_values_are_objects.html#methods",
    "href": "chapters/python/python_values_are_objects.html#methods",
    "title": "9  Values are objects",
    "section": "",
    "text": "x = \"banana\".capitalize()\nprint(x)\n\n\nWrite the value (or a variable name that substitutes for a value).\nThen write a ..\nThen write the name of the method (like capitalize).\nThen, write two parentheses to call the method. If the method takes any arguments other than the value it belongs to, then you write those additional values between the parentheses with commas in between, just as when you call a function.\n\n\n\n\nx = \"banana\"\nprint(x.capitalize())\n\n\nmessage = \"Methods Are Cool\"\nprint(message)\n\nshout = message.upper()\nprint(shout)\n\nwhisper = message.lower()\nprint(whisper)\n\nnew_message = message.replace(\"Cool\", \"Fantastic\")\nprint(new_message)\n\n\nExercise 9-1\nWrite and run the following code. What do you think it does?\nline = '\\n\\tSome text\\n'\nprint(\"&gt;{}&lt;\".format(line))\n\nline = line.strip()\nprint(\"&gt;{}&lt;\".format(line))\nMake sure you do the substitution and reduction steps in your head. Be especially careful about the third line of code. Also, what do you think the special \\t character is?\n\n\nExercise 9-2\nThe string methods you have tried so far have all returned a new string. Try this example:\n'ATGACGCGGA'.startswith('ATG')\nand this\n'ATGACGCGGA'.endswith('ATG')\nWhat do the methods do, and what do they return?",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Values are objects</span>"
    ]
  },
  {
    "objectID": "chapters/python/python_values_are_objects.html#using-the-python-documentation",
    "href": "chapters/python/python_values_are_objects.html#using-the-python-documentation",
    "title": "9  Values are objects",
    "section": "Using the Python documentation",
    "text": "Using the Python documentation\nNow that you are well underway to becoming a programmer, you should know your way around the Python documentation. Especially the part called the Python standard library. There is a lot of details in there that we do not cover in this course. These are mainly tools and techniques for writing more efficient, extensible, robust, and flexible code. The parts we cover in this course are the minimal set that will allow you to write a program that can do anything.\n\nExercise 9-3\nThere is a string method that returns a secret agent:\nprint('7'.zfill(3))\nYou can look it up in the Python documentation.\n\n\nExercise 9-4\nBrowse through all the string methods to get an impression of all the functionality that is packaged with string objects.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Values are objects</span>"
    ]
  },
  {
    "objectID": "chapters/python/python_values_are_objects.html#string-formatting",
    "href": "chapters/python/python_values_are_objects.html#string-formatting",
    "title": "9  Values are objects",
    "section": "String formatting",
    "text": "String formatting\nYou have already tried string formatting in Section 9.0.0.1. String formatting is a simple but powerful technique that lets you generate pretty strings from pre-computed values. You may have noticed that many decimals are shown every time we print a floating-point number. It is not very pretty if you are only interested in two decimals. You use the format method (surprise) to format a string. In its most straightforward use, format replaces occurrences of {} with the arguments that are passed to it - like this:\ntaxon = \"genus:{}, species:{}\".format('Homo', 'sapiens')\n\nExercise 9-5\nWhat happens if you try this?\nquestion = \"Was {} {} Swedish?\".format('Carl', 'Linneaus')\nand this?\nquestion = \"Was {} Swedish?\".format('Carl', 'Linneaus')\nand this?\nquestion = \"Was {} {} Swedish?\".format('Carl Linneaus')\nIn the two last examples, the number of {} did not match the number of arguments to format. What happens when there are too few and when there are too many?\n\n\nExercise 9-6\nConsider this code:\ns = \"{} is larger than {}\".format(4, 3)\nprint(s)\nWhat will happen if you run this code? Write the code and see for yourself once you think you know. If you were wrong, make sure you understand why.\n\n\nExercise 9-7\nConsider this code:\nlanguage = 'Python'\ninvention = 'sliced bread'\ns = '{} is the best thing since {}'.format(language, invention)\nprint(s)\nWhat will happen if you run this code? Write the code and see for yourself once you think you know. If you were wrong, make sure you understand why.\n\n\nExercise 9-8\nConsider this code:\nmy_template = '{} is the best thing since {}'\nlanguage = 'Python'\nprint(my_template.format(language, 'sliced bread'))\nprint(my_template.format(language, 1900 + 89))\nWhat will happen if you run this code? Do the substitution and reduction steps in your head.\n\n\nExercise 9-9\nThink back to Section 4.0.0.3, where you calculated how many cookies you could buy for 30 kr. The bars are 7 kr. So your program looked something like this:\nnr_bars = 30 / 7\nprint('I can buy', nr_bars, 'chocolate bars!')\nand it ran like this: python chocolate.py\nI can buy 4.285714285714286 chocolate bars!\nString formatting lets you rewrite the program like this:\nnr_bars = 30 / 7\nmessage = \"I can buy {} chocolate bars!\".format(nr_bars)\nprint(message)\nTry to replace {} with {:.2f}. format reads the stuff after the colon in each set of curly brackets and uses it as directions for formatting the value it inserts. Try it out and see what happens if you change the number 2 to 3, 4, 5 or 10.\n\n\nExercise 9-10\nSee if you can find the documentation for the format function in the Python documentation. It can do wondrous things, for this course we will only try to control the number of digits and padding with spaces. Look at the examples below. Maybe you can figure out how it works.\npi = 3.14159265359\nprint(\"*{}*\".format(pi))\nprint(\"*{:.3f}*\".format(pi))\nprint(\"*{:.6f}*\".format(pi))\nprint(\"*{:&gt;5.3f}*\".format(pi))\nprint(\"*{:&gt;10.3f}*\".format(pi))\n\n\nExercise 9-11\nThis is bonus info rather than an actual exercise. How do you think Python can figure out that adding strings is supposed to work differently than adding numbers? Remember that '1' + '2' is '12' not 3. The answer is that all values you can add with the + operator have a secret method called __add__ that defines how adding works for that type of value:\ns1 = \"11\"\ns2 = \"22\"\nn1 = 11\nn2 = 22\nprint(s1 + s2)\nprint(s1.__add__(s2))\nprint(n1 + n2)\nprint(n1.__add__(n2))\nThis is one of many examples of how objects allow Python to implement functionality that fits each value type. This was to show how Python does this. Like yellow and black stripes in nature means “don’t touch me!” – double underscores (__) is Python’s way of saying “do not use this!”. You are supposed to use the + operator, not the __add__ method.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Values are objects</span>"
    ]
  },
  {
    "objectID": "chapters/python/python_values_are_objects.html#indexing-and-slicing-strings",
    "href": "chapters/python/python_values_are_objects.html#indexing-and-slicing-strings",
    "title": "9  Values are objects",
    "section": "Indexing and slicing strings",
    "text": "Indexing and slicing strings\nAnother feature of string objects is that they allow you to extract individual parts of the string.\nEach character in a string is identified by its index in the string. To access a character in a list, you write brackets after the string. Between those brackets, you specify the index of the character you want. The first character has an index of 0; the second has an index of 1, and so on.\ncodon = 'ATG'\nprint(\"first base is\", codon[0])\nprint(\"second base is\", codon[1])\nprint(\"third base is\", codon[2])\nYou may wonder why the index of the first character is zero and not one. That is simply the convention in programming and is so for good reason. Over time you will begin to find this useful rather than annoying. You should think of the index as the offset from the start of the string.\nThat also means that the index is not the length of the string but the length minus one:\namino_acids = 'ARNDCQEGHILKMFPSTWYV'\nlast_index = len(amino_acids)-1\nprint(\"Last amino acid is\", amino_acids[last_index])\nIf you want a sub-string from a larger string (we call that a slice), you specify a start index and an end index separated by a colon:\nprint(amino_acids[1:4])\nWhen you run that, you can see that amino_acids[1:4] is substituted for 'RND', so the slicing operation produces a sub-string of amino_acids. You may wonder why the value at index 4 is not in the resulting sub-string. That is another programming convention: intervals are ends exclusive. So when you specify an interval with a start index of 1 and an end index of 4, it represents all the characters starting from 1 and up to, but not including, 4. So, the slice 1:4 corresponds to the characters at indexes 1, 2, and 3. The reason programmers handle intervals in this way is that it makes it easier to write clear and simple code as you will see in the exercises.\n\nExercise 9-12\nWhat does this expression reduce to?\n\"Futterwacken\"[7]\n\n\nExercise 9-13\nWhat is printed here? Do all the substitution and reduction steps and compare to the exercise above.\ns = \"Futterwacken\"\nprint(s[7])\n\n\nExercise 9-14\nWhat is printed here? Do all the substitution and reduction steps – and do it twice. Next week you will be happy you did.\ndna = 'TGAC'\ni = 0\nprint(dna[i])\ni = 1\nprint(dna[i])\ni = 2\nprint(dna[i])\n\n\nExercise 9-15\nWhat do you think happens here? Make up your mind and try out the code below:\ns = \"Futterwacken\"\ns[6] = 'W'\nDid you see that coming? Strings are immutable, which means that you cannot change them once you have made them. If you want \"FutterWacken\" you need to produce a new string with that value. Try to figure out how to do that with the replace method of strings.\n\n\nExercise 9-16\nWhen you do not specify a slice’s start and/or end, Python will assume sensible defaults for the start and end indexes. What do you think they are? Make up your mind and try out the code below:\ns = 'abcdefghijklmnopqrstuvxyz'\nprint(s[:11])\nprint(s[11:])\nprint(s[:])\n\n\nExercise 9-17\nFind the documentation for how the slicing of strings works.\n\n\nExercise 9-18\nWhat do you think happens when you specify an index that does not correspond to a value in the list:\nalphabet = 'abcdefghijklmnopqrstuvxyz'\nprint(alphabet[99])\nRead and make sure you understand the error message. You can try to Google the error message.\n\n\nExercise 9-19\nDo you think you also get an error when you specify a slice where the end is too high? Try it out:\nalphabet = 'abcdefghijklmnopqrstuvxyz'\nprint(alphabet[13:99])\nand this:\nalphabet = 'abcdefghijklmnopqrstuvxyz'\nprint(alphabet[10000:10007])\nI guess that is worth remembering.\n\n\nExercise 9-20\nWhich character in a string named alphabet does this expression reduce to?\nalphabet[len(alphabet)-1]\n\n\nExercise 9-21\nBecause intervals are “ends exclusive” ,we can compute the length of a slice as end - start:\ndna = \"ATGAGGTCAAG\"\nstart = 1\nend = 4\nprint(\"{} has length {}\".format(dna[start:end], end-start))\nFigure out what this code would look like if ends were included in intervals.\n\n\nExercise 9-22\nAnother advantage of “ends exclusive” intervals is that you only need one index to split a string in two:\ns = 'Banana'\nidx = 3\nbeginning = s[:idx]\nend = s[idx:]\nprint(beginning + end)\nFigure out what indexes you would need to use to split a sequence in two if ends were included in intervals.\n\n\nExercise 9-23\nDid you look up the details of how slicing works in Section 9.0.0.17? Then you should be able to explain what happens here:\ns = 'zyxvutsrqponmlkjihgfedcba'\nprint(s[::-1])",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Values are objects</span>"
    ]
  },
  {
    "objectID": "chapters/python/python_values_are_objects.html#general-exercises",
    "href": "chapters/python/python_values_are_objects.html#general-exercises",
    "title": "9  Values are objects",
    "section": "General exercises",
    "text": "General exercises\n\nExercise 9-24\nWill this print Bananas rule!? Do all the substitutions and reductions.\nif 'na' * 2 == \"Banana\"[2:]:\n    print(\"Bananas rule!\")\n\n\nExercise 9-25\nWill this print Bananas rule!? Do all the substitutions and reductions.\nif \"{}s\".format('Banana'[1:].capitalize()) == 'Ananas':\n    print(\"Bananas rule!\")\n\n\nExercise 9-26\nWrite a function called even_string that takes a string argument and returns True if the length of the string is an even number and False otherwise. E.g. even_string('Pear') should return True and even_string('Apple') should return False (remember the modulo operator?).\n\n\nExercise 9-27\nLook at the code below and decide what is printed at the end. Then, write the code and test your prediction. If you are wrong, figure out why by revisiting the chapter about functions.\ndef enigma(x):\n    if x == 4:\n        return x\n\nresult = enigma(5)\nprint(result)\n\n\nExercise 9-28\nInspect the code below and determine why it does not print that you are a super star. Test the function using various inputs and identify the mistake.\ndef even_number(x):\n    if x % 2:\n        return False\n\nif even_number(4):\n    print('You are a super star!')",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Values are objects</span>"
    ]
  },
  {
    "objectID": "chapters/python/lists.html",
    "href": "chapters/python/lists.html",
    "title": "10  Lists of things",
    "section": "",
    "text": "Lists\nThis chapter is about lists and dictionaries that are Python values that can contain other Python values. Lists and dictionaries let you build relationships between values, which is what data structures represent.\nFor many kinds of data, the order of things is important. Just like the order of characters is important for the meaning of the text in a string, we sometimes want to specify the order of other things because the relative order of items in the list has some meaning. It could be a grocery list where you have listed the things to buy in the order you get to them in the supermarket. This is where Python lists are helpful. When you print a list, it nicely shows all the values it contains.\nUnlike strings that can only store the order of characters, lists can contain any kind of values, and you can mix different types of values in any way you like. Here is a list that contains an integer, a boolean, a string, and a list:\nBy now, you have probably guessed you will make a list with two square brackets. Between them, you can put values with commas in between. A list is a container of other values, and the value of the list itself does not depend on the values it contains. This makes sense. Otherwise, an empty list would not have a value:\nYou can add single values to the end of a list using the append method of lists. Try it out:\nIf you have a list you want to add to the end of another list, you use the extend method:\nNotice how append and extend modifies the existing list instead of producing a new list with the added element.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists of things</span>"
    ]
  },
  {
    "objectID": "chapters/python/lists.html#lists",
    "href": "chapters/python/lists.html#lists",
    "title": "10  Lists of things",
    "section": "",
    "text": "grocery_list = [\"salad\", \"canned beans\", \"milk\", 'beer', 'candy']\nprint(grocery_list)\n\nmixed_list = [42, True, 'programming', [1, 2, 3] ]\n\nmy_list = []\n\ndesserts = []\nprint(desserts)\ndesserts.append('Crepe suzette')\nprint(desserts)\ndesserts.append('Tiramisu')\nprint(desserts)\ndesserts.append('Creme brulee')\nprint(desserts)\n\ncheeses = ['Gorgonzola', 'Emmentaler', 'Camembert']\ndesserts.extend(cheeses)\nprint(desserts)\n\n\nExercise 10-1\nDo you think this will work?\ncheeses = ['Gorgonzola', \n           'Emmentaler', \n           'Camembert']\nprint(cheeses)\nSurprised? Code inside parentheses, brackets, and braces can span several lines, sometimes making your code easier to read.\n\n\nExercise 10-2\nYou use the’ in’ operator to test if a value is in a list. Try this:\nprint('Tiramisu' in desserts)\nprint('Meatloaf' in desserts)\n\n\nExercise 10-3\nYou can concatenate two lists to produce a new joined list. Make sure you figure out how this works before you try it. Then, experiment with changing the lists. Can you concatenate two empty lists?\nsome_list = [1, 2, 3]\nanother_list = [7, 8, 9]\nmerged_list = some_list + another_list\nprint(merged_list)\nThis is yet another example of how the functionality of Python objects lets them “know” how to behave under different circumstances, such as when adding two objects (see Section 9.0.0.11).\n\n\nExercise 10-4\nWhat do you think is printed here? Make sure you figure out how you think this works before you try it out. What does the append method return?\nmy_list = []\nx = my_list.append(7)\nprint(x)\nprint(my_list)",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists of things</span>"
    ]
  },
  {
    "objectID": "chapters/python/lists.html#indexing-and-slicing-lists",
    "href": "chapters/python/lists.html#indexing-and-slicing-lists",
    "title": "10  Lists of things",
    "section": "Indexing and slicing lists",
    "text": "Indexing and slicing lists\nNow you know how to make lists, but to work with the values in lists, you must also know how to access the individual values a list contains. Fortunately, indexing lists work just like indexing strings: Each value in a list is identified by an index exactly like each character in a string:\nnumbers = [7, 4, 6, 2, 8, 1]\nprint(\"first value is\", numbers[0])\nprint(\"second value is\", numbers[1])\nprint(\"third value is\", numbers[2])\nNotice that the function len can also compute the length of a list. So you also get the last value in a list like this:\nnumbers = [7, 4, 6, 2, 8, 1]\nlast_index = len(numbers)-1\nprint(\"Last element is\", numbers[last_index])\nIf you want a sub-list of values from a list (we also call that a slice), you specify a start index and an end index separated by a colon, just like with strings:\nprint(numbers[1:4])\nWhen you run that, you can see that numbers[1:4] is substituted for [4, 6, 2], so the slicing operation produces a new list of the specified values.\n\nExercise 10-5\nWhat do these two expressions reduce to?\n[11, 12, 13, 14, 15, 16, 17][2]\n\n\nExercise 10-6\nWhat is printed here? Do all the substitution and reduction steps and compare them to the exercise above.\nl = [11, 12, 13, 14, 15, 16, 17] \nprint(l[2])\n\n\nExercise 10-7\nWhat is printed here? Do all the substitution and reduction steps — and do them twice. Next week, you will be happy you did.\nnumbers = [1,2,3]\ni = 0\nprint(number[i])\ni = 1\nprint(number[i])\ni = 2\nprint(number[i])\n\n\nExercise 10-8\nWhat do you think happens here? Make up your mind and try out the code below:\nl = [11, 12, 13, 14, 15, 16, 17] \nl[4] = \"Donald\"\nprint(l)\nWere you surprised by what happened? Compare to Section 9.0.0.15. Lists are not immutable like strings, and you can replace values by assigning a new value to an index in the list.\n\n\nExercise 10-9\nWith your knowledge of slicing, what do you think is printed below:\nl = [11, 12, 13, 14, 15, 16, 17]\nprint(l[:3])\nprint(l[3:])\nprint(l[:])\n\n\nExercise 10-10\nWhat do you think happens when you specify an index that does not correspond to a value in the list:\nl = [11, 12, 13, 14, 15, 16, 17] \nprint(l[7])\nRead and understand the error message. Does it ring a bell?\n\n\nExercise 10-11\nDo you also get an error when you specify a slice where the end is too high? Try it out:\nl = [11, 12, 13, 14, 15, 16, 17]\nprint(l[4:99])\nI guess that is also worth remembering.\n\n\nExercise 10-12\nWhich value in a list named l does this expression reduce to?\nl[len(l)-1]\n\n\nExercise 10-13\nIf you do not like Emmentaler, you can delete it. What does the del keyword do?\ncheeses = ['Gorgonzola', 'Emmentaler', 'Camembert']\nprint(cheeses)\ndel cheeses[1]\nprint(cheeses)\n\n\nExercise 10-14\nBecause intervals are “ends exclusive,” we can compute the length of a slice as end - start:\nl = [7, 4, 6, 2, 8, 1]\nstart = 1\nend = 4\nprint(\"{} has length {}\".format(l[start:end], end-start))\nConsider what this code would look like if ends were included in intervals.\n\n\nExercise 10-15\nAnother advantage of “ends exclusive” intervals is that you only need one index to split a list in two:\nnumbers = [1, 2, 3, 4, 5, 6]\ni = 3\nbeginning = numbers[:i]\nend = numbers[i:]\nprint(beginning + end)\nIf ends were included in intervals, this would be more complex.\n\n\nExercise 10-16\nDo all the substitution and reduction steps in your head (or on paper) before you write any of the following code. Think carefully and decide what you think will be printed below. Remember that the value of a list is a container that holds other values in it. Then, write the code and see if you are right. If you were not, figure out what led you to the wrong conclusion.\nx = 'A'\ny = 'B'\nz = 'C'\nlst = [x, y, z]\nprint(lst)\n\nx = 'Preben'\nprint(lst) # what is printed here? \n\nlst[0] = 'Mogens'\nprint(lst) # what is printed here?\n\n\nExercise 10-17\nDo you remember this trick from string slicing?\nl = [1, 2, 3, 4, 5]\nprint(l[::-1])\n\n\nExercise 10-18\nYou can produce a list by splitting a long string into smaller parts. Think: “Hey string, split yourself on this smaller string”. Try these variations to figure out how it works.\n\"Homo sapiens neanderthalensis\".split(\" \")\n\"Homo sapiens neanderthalensis\".split('en')\n'ATGCTCGTAACGACACTGCACTACTACAATAG'.split('')\n\"1, 2, 3, 5, 3, 2, 5, 3\".split(', ')\n\"1,2,3,5,3,2,5,3\".split(',')\n'ATGCTCGTAACGACACTGCACTACTACAATAG'.split()\n\"Homo sapiens neanderthalensis\".split()\nNotice that the method has a default behavior when no argument is passed to it.\n\n\nExercise 10-19\nYou can produce a string by joining the elements of a list (if all the elements are strings, of course). Think: “Hey string, put yourself between all the strings in this list”.\n\"-\".join(['Homo', 'sapiens', 'neanderthalensis'])\n\"...\".join(['Homo', 'sapiens', 'neanderthalensis'])\n\"\".join(['A', 'T', 'G'])\nNotice how you can join something on an empty string. This is a very useful technique to turn a list of characters into a string.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists of things</span>"
    ]
  },
  {
    "objectID": "chapters/python/lists.html#general-exercises",
    "href": "chapters/python/lists.html#general-exercises",
    "title": "10  Lists of things",
    "section": "General exercises",
    "text": "General exercises\nWhat does this expression reduce to? 'aaaaa', 'BaBaBa', or 'Banan'. Make up your mind, and then run the expression to check.\n'a'.join('Banana'.split('a')[:3] * 4)[-5:]",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists of things</span>"
    ]
  },
  {
    "objectID": "chapters/python/dictionaries.html",
    "href": "chapters/python/dictionaries.html",
    "title": "11  Pairs of things",
    "section": "",
    "text": "Dictionaries\nThis chapter is about dictionaries that, like lists, is another Python value that can contain other Python values. Dictionaries dictionaries let you build relationships between values, which is what data structures represent.\nLists are useful for storing values when the order of the values is important, but they have one drawback: you can only access a value in a list using its index.\nA dictionary called dict in Python, is a much more flexible data type. Like a list, a dictionary is a container for other values, but dictionaries do not store values in sequence. They work more like a database that lets you store individual values. When you store a value, you assign it to a key that you can use to access the stored value. Now, create your first dictionary:\nThis dictionary has three values ('Actor', 'Robert Redford' and 179) and each value is associated with a key. Here 'height' is the key for the value 179. So, when defining a dictionary, you should note the following:\nTo access a value in the dictionary, you put its key in square brackets after the dictionary:\nHere we used strings as keys, but you can also use many types of values as keys (Python will give you an error if you try to use a type that is not allowed):\nA dictionary stores key-value pairs but does not keep track of their order. So, when you print a dictionary, the order of the key-value pairs is arbitrary.\nIf you have a dictionary, you can add key-value pairs in this way:\nNotice that if you assign a value (71) to a key that is already in the dictionary ('age'), then the old value (70) is replaced.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Pairs of things</span>"
    ]
  },
  {
    "objectID": "chapters/python/dictionaries.html#dictionaries",
    "href": "chapters/python/dictionaries.html#dictionaries",
    "title": "11  Pairs of things",
    "section": "",
    "text": "person = {'name': 'Robert Redford', 'height': 179, 'job': 'Actor'}\n\n\nYou make a dictionary using braces.\nyou put key-value pairs separated by a colon between your braces.\nCommas separate the key-value pairs.\nTo make an empty dictionary, write the braces with nothing between them: {}.\n\n\n\"{} is a {} cm {}\".format(person['name'], person['height'], person['job'])\n\nmisc_dict = {42: \"Meaning of life\", \"pi\": 3.14159, True: 7}\n\n\nperson['job'] = 'Retired'\nperson['hair'] = 'uniquely combed'\nprint(person)\n\n\nExercise 11-1\nWhat does this expression evaluate to?\n{'name': 'Robert Redford', 'height': 179, 'job': 'Actor'}['name']\n\n\nExercise 11-2\nAssuming the definition of the person dictionary above, what does this expression evaluate? Compare this to the expression in the previous exercise.\nperson['name']\n\n\nExercise 11-3\nThe in operator also works with dictionaries. Look at what these expressions reduce to and then try to figure out what in does when applied to a dictionary:\n'name' in person\n'height' in person\n'job' in person\n84 in person\n'Actor' in person\n'Robert Redford' in person\n\n\nExercise 11-4\nWrite and run this code with different values of key and read any error messages.\nkey = 3\n# key = 'banana'\n# key = 3.14159\n# key = True\n# key = {}\n# key = []\nd = {}\nd[key] = 7\nAre any of the values not allowed as keys?\n\n\nExercise 11-5\nDo you think this will work?\nperson = {'name': 'Robert Redford', \n                'height': 179,\n                'job': 'Actor'}\nprint(person)",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Pairs of things</span>"
    ]
  },
  {
    "objectID": "chapters/python/dictionaries.html#general-exercises",
    "href": "chapters/python/dictionaries.html#general-exercises",
    "title": "11  Pairs of things",
    "section": "General exercises",
    "text": "General exercises\n\nStart by making dictionaries for (some of) the Trump family:\ndonald = {'name': 'Donald Trump', 'age': 70, 'job': 'President' }\nmelania = {'name': 'Melania Trump', 'age': 70, 'job': 'First lady' }\ntiffany = {'name': 'Tiffany Trump', 'age': 23, 'job': 'Internet personality' }\nivanka = {'name': 'Ivanka Trump', 'age': 35, 'job': 'Top aide' }\n\nExercise 11-6\nWhat do you think the following code produces? Do all of the substitution and reduction steps in your head, and only then try out the code.\ndonald['child'] = tiffany\nmelania['husband'] = donald\n\nprint(melania)\nprint(melania['husband']['child'])\n\n\nExercise 11-7\nA dictionary can contain any kind of Python values, even lists or dictionaries. Consider the code below, where we add a list of ex-wives to the Trump persona. Can you see why we need to check the 'ex-wives' key before we add it to the list of ex-wives?\ndonald = {'name': 'Donald Trump', 'age': 70, 'job': 'President' }\n\nif 'ex-wives' not in donald:\n    donald['ex-wives'] = []\ndonald['ex-wives'].append('Marla Maples')\ndonald['ex-wives'].append('Ivana Trump')\n\nprint(donald)\n\n\nExercise 11-8\nIn case you wonder what the type of value a list is, or a dictionary, try this:\nprint(\"A list has type:\", type([]))\nprint(\"A dictionary has type:\", type({}))\nNow the types list and dict are your friends too.\n\n\nExercise 11-9\nLists can also contain any type of value. Consider this example. What do you think the following code produces? Do all the substitution and reduction steps in your head, and only then try out the code.\ntrump_family = [donald, melania, ivanka, tiffany]\nprint(trump_family)\nprint(trump_family[1]['job'])\n\n\nExercise 11-10\nWrite and run this code\namino_acids = {}\namino_acids['ATG'] = 'met'\namino_acids['TCT'] = 'ser'\namino_acids['TAC'] = 'tyr'\n\ncodon = 'TCT'\nprint(\"{} encodes {}\".format(codon, amino_acids[codon]))\n\nYou have probably noticed that the interpretation of length is different for each type of value. In a string, it is the number of characters; in a list, it is the number of values in the list; in a dictionary, it is the number of key-value pairs. How do you think Python knows which length interpretation to use when the len function is called? This is where objects shine. len(x) returns the value that x.__len__() returns. So the len function is defined roughly like this:\ndef len(x):\n    return x.__len__()\nSimilarly, the in operator calls a secret __contains__ method.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Pairs of things</span>"
    ]
  },
  {
    "objectID": "chapters/python/gluing_values_in_sequence.html",
    "href": "chapters/python/gluing_values_in_sequence.html",
    "title": "12  Grouping values",
    "section": "",
    "text": "Tuples\nA tuple is a sequence of values, just like a list. However, unlike a list, the elements of a tuple can not be changed. You cannot append to a tuple, either. Once a tuple is made, it is immutable (or unchangeable). To make a tuple, you just use round brackets instead of square brackets:\nIt may seem strange that Python has both tuples and lists. One reason is that tuples are more efficient, whereas lists are more flexible. We will not use tuples often, but you must know what they are.\nYou can do most of the operations on a tuple that you can also do on a list. The following exercises should be easy if you remember how to do the same thing on lists:",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Grouping values</span>"
    ]
  },
  {
    "objectID": "chapters/python/gluing_values_in_sequence.html#tuples",
    "href": "chapters/python/gluing_values_in_sequence.html#tuples",
    "title": "12  Grouping values",
    "section": "",
    "text": "fruits = (\"apple\", \"banana\", \"cherry\")\n\n\n\nExercise 12-1\nFind the number of elements in the fruits tuple using the len function.\n\n\nExercise 12-2\nExtract the second element of the fruits tuple (\"banana\") using indexing.\n\n\nExercise 12-3\nTry to change the second element of the fruits tuple to \"apple\" and see what happens. It should be something like this:\nTraceback (most recent call last):\n  File \"script.py\", line 2, in &lt;module&gt;\n    fruits[3] = \"apple\"\nTypeError: 'tuple' object does not support item assignment\nYou cannot change elements of a tuple because they are immutable (once made, they stay that way).",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Grouping values</span>"
    ]
  },
  {
    "objectID": "chapters/python/gluing_values_in_sequence.html#tuple-assignment",
    "href": "chapters/python/gluing_values_in_sequence.html#tuple-assignment",
    "title": "12  Grouping values",
    "section": "Tuple assignment",
    "text": "Tuple assignment\nPython lets you assign a tuple of values to a tuple of variables like this:\nfather, mother, son = (\"Donald\", \"Ivana\", \"Eric\")\nIt does the same as the following three assignments:\nfather = \"Donald\"\nmother = \"Ivana\"\nson = \"Eric\"\nWhen a tuple is made, the values are “packed” in sequence:\nfamily = (\"Donald\", \"Ivana\", \"Eric\")\nUsing the same analogy, values can be “unpacked” using tuple assignment:\nfather, mother, son = family\nThe only requirement is that the number of variables equals the number of values in the tuple.\nOnce in a while, it is useful to swap the values of two variables. With conventional assignment statements, we have to use a temporary variable. For example, to swap a and b:\ntmp = a\na = b\nb = tmp\n\nExercise 12-4\nTry this and read the error message:\nfamily = (\"Donald\", \"Ivana\", \"Eric\")\nfather, mother = family\n\n\nExercise 12-5\nTry this and read the error message:\nfamily = (\"Donald\", \"Ivana\", \"Eric\")\nfather, mother, son, daughter = family\nCompare to the error message in the previous exercise.\n\n\nExercise 12-6\nSay you want to swap the values of two variables, a and b. To do that, you would need to keep one of the values in an extra variable like this:\ntemp = a\na = b\nb = temp\nUsing what you have learned in this chapter, can you devise a simple and pretty way of swapping a and b in one statement? It may occur to you before you realize how it works, so make sure you can connect your solution to the rules of tuples and tuple assignment.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Grouping values</span>"
    ]
  },
  {
    "objectID": "chapters/python/iteration_over_values.html",
    "href": "chapters/python/iteration_over_values.html",
    "title": "13  Iterating values",
    "section": "",
    "text": "The for-loop\nThis chapter is about how you repeat the same code for many different values – and the many reasons why this is useful.\nPrograms often need to do repetitive things. Consider this example below, where x is assigned a value that is then printed:\nYou can see that we do the same thing four times, with the only difference being that the variable x takes a new value each time. Now, carefully write the alternative version below and compare what is printed to what was printed in the above example.\nIt should be the same. What you just wrote is called a for-loop. It is called a for-loop because it does something for each of many values – in this case, for each value in our list.\nThe statements nested under the for-loop are run as many times as there are values in our list, and every time they are run, x is assigned a new value. The first time the statements are run, x is assigned the first value in the list. The second time they run x, the second value is assigned to the list. This continues until x has been assigned all the values in the list.\nThe semantics of a for-loop is as follows:\nWhat is an iterable, you may ask? It is any Python value that knows how to serve one value at a time until there are none left. Only objects with an __iter__ method can do this. You will get an error if you try to iterate over a value that does not have an __iter__ method. Try the code below and see how Python complains that “‘int’ object is not iterable”:\nTry these variations of the for-loop above and notice how the rules 1-5 apply in each case:\nIn each case, the expression after in reduces to the value [1, 5, 3, 7], which then serves as the iterable.\nIt is not only lists that are iterable. Strings are, too. Their ‘iter’ method of a string tells it that it should serve one character at a time. Try this:\nNeat, right?\nIn programming, you often need to iterate over integer values and sometimes quite a few (like the 250 million bases of the human chromosome one). It would be quite annoying if you had to manually make long lists of integers, so Python provides a built-in function called range that helps you out. It returns a special iterator value that lets you iterate over a specified range of numbers. Try the two examples below and compare what is printed:\nYou can see that using range works just like using a list of numbers, but the cool thing about the range is that it does not return a list. It just serves one number at a time until it is done. This is also why you will not see a list if you try to print what range returns:\nThe range function needs three values to know which values to iterate over: “start”, “end” and “step”. It will assume sensible defaults if you do not give it all three arguments. Try this:\nYou can see that the first and last arguments default to 0 and 1. If you give it two arguments, it will assume that they are “start” and “end”. If you only give it one argument, it will assume that it is the “end”.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterating values</span>"
    ]
  },
  {
    "objectID": "chapters/python/iteration_over_values.html#the-for-loop",
    "href": "chapters/python/iteration_over_values.html#the-for-loop",
    "title": "13  Iterating values",
    "section": "",
    "text": "x = 1\nprint(x)\nx = 5\nprint(x)\nx = 3\nprint(x)\nx = 7\nprint(x)\n\nfor x in [1, 5, 3, 7]:\n    print(x)    \n\n\n\n\nFirst, you write for.\nThen, you write the name of the variable that will be assigned a new value for each iteration of the loop (x in the above case).\nThen you write in.\nThe,n you write the name of an iterable or an expression that reduces to one. In the above case, it was the list [1, 5, 3, 7].\nThe statements nested under the for loop are indented with four spaces, just like with if-statements. These statements are executed once for every value in the iterable.\n\n\nfor x in 4:\n    print(x)\n\nfor x in [1, 5, 3, 7]:\n    print(x)    \n\nlist_of_numbers = [1, 5, 3, 7]\nfor x in list_of_numbers:\n    print(x)    \n\nfor x in [1, 5] + [3, 7]:\n    print(x)    \n\n\nfor character in 'banana':\n    print(character)\n\n\ntotal = 0\nfor number in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]:\n    total += number\nprint(total)\n\ntotal = 0\nfor number in range(10):\n    total += number\nprint(total)\n\nnumber_iterator = range(10)\nprint(number_iterator)\n\nfor i in range(0, 10, 1):\n    print(i)\n\nfor i in range(0, 10):\n    print(i)\n\nfor i in range(10):\n    print(i)\n\n\nExercise 13-1\nWhat do you think the third argument to range specifies? Try these variations and see if you can figure it out:\nfor i in range(0, 10, 1):\n    print(i)\n\nfor i in range(0, 10, 2):\n    print(i)\n\nfor i in range(0, 10, 3):\n    print(i)\nCheck the documentation once you have decided.\n\n\nExercise 13-2\nWhat will happen here:\nfor x in []:\n    print(x)  \nand here:\nfor x in range(0):\n    print(x)  \nand here:\nfor x in range(10, 10):\n    print(x)  \n\n\nExercise 13-3\nThe two examples below print the same. Make sure you understand why. Write and experiment with the code on your own.\nlist_of_words = ['one', 'two', 'three']\n\n# example 1\nfor word in list_of_words:\n    print(word)\n\n# example 2\nlist_length = len(list_of_words)\nfor index in range(list_length):\n    print(list_of_words[index])\n\n\nExercise 13-4\nFinish the code below so all the even numbers go into one list, and all the odd numbers go into the other (hint: remember the modulo operator?)\nnumbers = [4, 9, 6, 7, 4, 5, 3, 2, 6]\neven = []\nodd = []\nfor n in numbers:\n    # your code here ...\n    \n    \n\n\nExercise 13-5\nYou can put any statements under the for loop. Here, it includes an if-statement that lets you generate a list of all the a characters in banana (in case you need that).\nresult = []\nfruit = 'banana'\nfor character in fruit:\n    if character == 'a':\n        result.append(character)\nprint(result)\nNow change the code so you instead get the indexes of the ‘a’ characters: [1, 3, 5]. Here are some hints:\n\nYou need a for-loop over a list of numbers.\nrange(len(fruit)) may be relevant numbers :-).\nfruit[1] substitutes for 'a'.\n\n\n\nExercise 13-6\nImagine you want to throw a big party and have rented a place with space for 100 people. Now, you want to start inviting people. What kind of error do you get here, and why?\nfriends = [\"Mogens\", \"Preben\", \"Berit\"]\ninvited = []\nfor index in range(100):\n    invited.append(friends[index])\n\n\nExercise 13-7\nYou can also put a for loop under another for loop, and the rules for each for loop are the same as those explained above. The statements nested under the for loop are indented with four spaces, just like with if statements. These statements are executed once for every value in the iterable. Think carefully about what you think is printed in the example below before you try it out.\nfor i in range(3):\n    for j in range(3):\n        print(i, j)\nMake sure you understand i, j pairs are printed in the order they are.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterating values</span>"
    ]
  },
  {
    "objectID": "chapters/python/working_with_data_files.html",
    "href": "chapters/python/working_with_data_files.html",
    "title": "14  Working with files",
    "section": "",
    "text": "Writing files\nThis chapter covers the bare necessities of making your program read data from a file on your computer and how to create a file to write results.\nTo interact with a file on your hard disk, you need to know its name and whether you want to write to it or read from it. Then, you can use the built-in function open to create a file object that lets you read or write to that file. The open function takes two arguments: The first is a string, which gives the file’s name. The second argument is also a string and should be 'w' for “write” if you want to write to the file or 'r' for “read” if you are going to read from the file. To keep things simple, we will assume that the file you want to open is always in the same folder (directory) as the Python script that calls the open function.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with files</span>"
    ]
  },
  {
    "objectID": "chapters/python/working_with_data_files.html#writing-files",
    "href": "chapters/python/working_with_data_files.html#writing-files",
    "title": "14  Working with files",
    "section": "",
    "text": "Exercise 14-1\nTry to write the code below and run it:\nf = open('workfile.txt', 'w')\nf.write(\"First line\\n\")\nf.write(\"Second line\\n\")\nf.close()\nNow open the workfile.txt in VScode and see what is in it now. It should contain:\nFirst line\nSecond line\nLet’s break down what happened:\n\nYou used the open built-in function to open a file called “workfile.txt” in writing mode using the 'w' as the second argument.\nYou then wrote the string \"First line\\n\" to the file using the write method of the file object.\nYou wrote another string \"Second line\\n\" to the file using the write method of the file object.\nYou closed the file using the close method of the file object.\n\nNote that if you open a file for writing, a file with that name is created. If a file of that name already exists, it is overwritten.\n\n\nExercise 14-2\nClose workfile.txt in VScode again and change your program above to this (removing the \\n characters):\nf = open('workfile.txt', 'w')\nf.write(\"First line\")\nf.write(\"Second line\")\nf.close()\nWhat do you think the content of workfile.txt is now? Decide before you open workfile.txt in VScode again and have a look. What do you think the \\n character represents?\n\n\nExercise 14-3\nClose workfile.txt in VScode and change your program above to this:\nf = open('workfile.txt', 'w')\nf.write(\"First line\\nSecond line\\n\")\nf.close()\nCan you see how that is equivalent to what you did before? Open workfile.txt in VScode again and have a look.\n\n\nExercise 14-4\nYou can also make print write to a file instead of the terminal. That way, your output will end up in the file instead of the terminal. To make print write to a file, you need to use print’s file keyword argument to tell print which file to write to. The argument must be an object that represents the file you want to write to (file=f below). Try to write the code below and run it:\nf = open('workfile.txt', 'w')\nprint(\"First line\", file=f)\nprint(\"Second line, file=f\")\nf.close()\nCompare the code to that in Section 14.0.0.1. Notice how the strings we print end with a newline character \\n. This is because the default behavior for print is to add a new line to the end of what it prints—just like when you print to the terminal.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with files</span>"
    ]
  },
  {
    "objectID": "chapters/python/working_with_data_files.html#reading-files",
    "href": "chapters/python/working_with_data_files.html#reading-files",
    "title": "14  Working with files",
    "section": "Reading files",
    "text": "Reading files\nWhen you want to read a from an existing file, you give the open function the name of that file and specify 'r' for reading as a second argument. If the file you name does not exist, Python will tell you it does not exist (it is nice like that). Before you head into the rest of this section, make sure you redo Section 14.0.0.1 so the content of workfile.txt is:\nFirst line\nSecond line\n\nExercise 14-5\nf = open('workfile.txt', 'r')\nfile_content = f.read()\nprint(file_content)\nf.close()\nLet’s break down what happened:\n\nYou used the open built-in function to open a file called workfile.txt in reading mode using the 'r' as the second argument.\nYou then read the file’s content using the read method, which returns the contents as a string.\nYou printed the string.\nYou closed the file using the close method of the file object.\n\n\n\nExercise 14-6\nTry to read from the file after you close it:\nf = open('workfile', 'r')\nf.close()\nfile_content = f.read()\nDo you get an error? Which one? Do you understand why?\n\n\nExercise 14-7\nYou can use the readline method to read one line at a time. What do you think happens if you run this code:\nf = open('workfile.txt', 'r')\nline = f.readline()\nprint(line)\nline = f.readline()\nprint(line)\nline = f.readline()\nprint(line)\nOnce you decide, try it out. What is printed in the last print statement? The thing is, the file object keeps track of how much of the file it has read. Once it ends, you can read as much as you like- nothing is left. If you want to start reading from the top of the file, you can close it and open it again. Try to insert the following two statements at various places in the code above and see what happens.\nf.close()\nf = open('workfile.txt', 'r')\n\n\nExercise 14-8\nLook at the code below and figure out for yourself what it does:\ninput_file = open('workfile.txt', 'r')\noutput_file = open('results.txt', 'w')\n\nfor line in input_file:\n    line = line.upper()\n    output_file.write(line)\nThen, run it and open results.txt in VScode and see what it produced.\nWere you surprised that the file object can be an iterator in a for-loop? Just like stings can iterate over characters, lists can iterate over values, dictionaries can iterate over keys, and file objects can iterate over the lines in the file.\nTry to modify your code to use the print function instead of the write method (see Section 14.0.0.4).",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with files</span>"
    ]
  },
  {
    "objectID": "chapters/python/working_with_data_files.html#general-exercises",
    "href": "chapters/python/working_with_data_files.html#general-exercises",
    "title": "14  Working with files",
    "section": "General exercises",
    "text": "General exercises\n\nExercise 14-9\nWrite a function read_file that takes the name of a file as an argument. The function should read the content and return it. Like:\ncontent_of_file = read_file('some_file.txt')\n\n\nExercise 14-10\nWrite a function that takes the name of two files as arguments. The file should read the content of the first file and write it to the second file.\ncopy_file('some_file.txt', 'other_file.txt')",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with files</span>"
    ]
  },
  {
    "objectID": "chapters/python/data_structures.html",
    "href": "chapters/python/data_structures.html",
    "title": "15  Structuring data",
    "section": "",
    "text": "Exercise 15-1\nThis section will further train your ability to create such data structures using iteration. Data structures in Python are fundamental tools that allow you to organize, store, and manipulate data effectively. They provide a way to represent and manage data in a structured and organized manner, making it easier to perform various operations on the data. Python offers a variety of built-in data structures, such as lists and dictionaries, with different properties that are useful for different needs. Sometimes, a single list or dictionary is all you need. Still, sometimes you need to combine many lists and dictionaries to make an elaborate data structure. As your programming skills progress, you will find that mastering the use of different data structures is crucial for becoming a proficient Python programmer.\nImagine you want to count how many times each nucleotide appears in a DNA string like this: 'ATGCCGATTAA'. One way to proceed with an account of this is by using a dictionary where the keys represent the different values we want to count (in this case 'A', 'T', 'C' and 'G'). The value associated with each key is the number of times we have seen that key (nucleotide). So, we want to end up with a dictionary like this one (not necessarily with key-value pairs in this order):\nRemind yourself how you assign a value to an existing key in a dictionary. Here is some code to get you going:",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Structuring data</span>"
    ]
  },
  {
    "objectID": "chapters/python/data_structures.html#general-exercises",
    "href": "chapters/python/data_structures.html#general-exercises",
    "title": "15  Structuring data",
    "section": "General exercises",
    "text": "General exercises\n\nBy now, you have learned a lot, and the general exercises, which serve to keep it all current, get more complicated. But remember: even though the code may mix lists, for-loops, and functions, the rules for lists, for-loops, and functions are not mixed. The separate simple rules for a list, a for-loop, and a function are still the same. If you get confused, it is time to revisit the sections about each separate topic. You may have to do that many times during the course.\n\n\nExercise 15-16\nWrite a function, square_numbers, that takes a list of numbers as argument and returns a new list with the numbers squared.\n# write your function definition here ...\n\nnumbers = [1, 5, 3, 7]\n\n# then you can call it like this:\nsquared = squared_numbers(numbers)\n\n\nExercise 15-17\nWrite a function count_characters, which takes a string argument and returns a dictionary with the counts of each character in the string. When you call the function like this:\ncount_characters('banana')\nit must return (not necessarily with key-value pairs in that order):\n{'n': 2, 'b': 1, 'a': 3}\nThe technique you should use is the one you learned in Section 15.0.0.2. Here, we iterate over a string of characters instead of a list of numbers. Here is a bit of code to help you along.\ndef count_characters(text):\n    counts = {}\n    # fill in the missing code ...\n\n    return counts\n\n\nExercise 15-18\nUse the function you made in the previous exercise to construct the following data structure below from this list: ['banana', 'ananas', 'apple'].\n{ 'banana': {'b': 1, 'a': 3, 'n': 2},\n  'apple': {'a': 1, 'e': 1, 'p': 2, 'l': 1}, \n  'ananas': {'a': 3, 's': 1, 'n': 2} }\nHere is some code to help you along:\nmy_database = {}\nfor word in ['banana', 'ananas', 'apple']:\n    my_database[word] =  # you figure this out...\nOnce you are done, what value do you think my_database['banana'] represents? I.e., what will it be reduced to if used in an expression? And what value does my_database['banana']['a'] represent?\n\n\nExercise 15-19\nRead the code below and make sure you understand each step before you write any of it. If necessary, revisit previous sections and look in the Python documentation. Then, write and run the code—and enjoy that it was exactly what you expected.\ndef get_words(text, search_string):\n    hits = []\n    for word in text.split():\n         if search_string in word:\n            hits.append(word)\n    return hits\n    \ns = 'eenie meenie minie moe'\nnie_words = get_words(s, 'nie')\nm_words = get_words(s, 'm')\n\nprint(' '.join(nie_words))\nprint(' '.join(m_words))\n\n\nExercise 15-20\nThis larger will take you through some of the most common string manipulations. A palindrome is a string that is spelled the same way, backward and forwards.\nWrite a function, is_palindrome, which takes one argument:\n\nA string.\n\nThe function must return:\n\nTrue if the string argument is a palindrome and False otherwise.\n\nExample usage:\nis_palindrome('abcba')\nshould return True and\nis_palindrome('foo')\nshould return False\nOne approach to this is to run through s from the first to the middle character, and for each character, check if the character is equal to the character at the same index from the right rather than the left. Remember that the first character of a string is at index 0 and the last at index -1, the second character is at index 1 and the second last at index -2 and so forth.\nSince you need to run through the string from the first to the middle character, you must first figure out how many characters that corresponds to. Say your palindrome is \"ACTGTCA\", then the number of indexes you need to loop over with a for loop is:\ns = \"ACTGTCA\"\nnr_indexes = len(s)//2 \nFigure out how to make range() return indexes to access the characters in the first half of the sequence. Then make a for loop where you iterate over the indexes you get from range(). Try to make the for-loop print out the first half of the characters, just to make sure you are using the right indexes.\nOnce you get this far, you must compare each character from the first half of the corresponding ones, starting from the other end of the palindrome. Figure out how to change each index used for the first half to the corresponding index for the other half so you can compare the relevant pairs. (You need to compare index 0 with -1, 1 with -2 and so on…)\nNow, try to make the for loop print both the character from the first half and the corresponding character from the other end. If you get the indexes right, you will see that the A prints with the A from the other end, the C with the C, and so on.\nWrite an if-statement in the for-loop that tests whether the two corresponding characters are identical. If the string is a palindrome, then each pair is identical. So, as soon as you see a pair that is not identical, you know it is not a palindrome, and you can let your function return False like this:\nif left_character != right_character:\n    return False\nRemember that the function ends when it encounters a return statement.\nIf all pairs pass the test, the string is a palindrome, and the function should return True when exiting the for loop.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Structuring data</span>"
    ]
  },
  {
    "objectID": "chapters/python/unleash_your_functions.html",
    "href": "chapters/python/unleash_your_functions.html",
    "title": "16  Recursion",
    "section": "",
    "text": "Recursion\nAt the time of “printing,” this chapter was unfinished. So I have added some empty pages so you can merge the chapter into the pdf later without messing up the chapter, exercise and page numbers\nPLACEHOLDER PAGE",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Recursion</span>"
    ]
  },
  {
    "objectID": "chapters/python/unleash_your_functions.html#divide-and-conquer",
    "href": "chapters/python/unleash_your_functions.html#divide-and-conquer",
    "title": "16  Recursion",
    "section": "Divide and conquer",
    "text": "Divide and conquer\nPLACEHOLDER PAGE\n\nExercise 16-1\nPLACEHOLDER PAGE",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Recursion</span>"
    ]
  },
  {
    "objectID": "chapters/python/testing_your_code.html",
    "href": "chapters/python/testing_your_code.html",
    "title": "17  Testing your code",
    "section": "",
    "text": "Why test your code?\nThis chapter is about how you figure out if the code you wrote solves the problem in the way you intended. You will be surprised how often that is not the case – even for seasoned programmers.\nThere are tons of reasons why you should test your code. Here are what I think are the two most important ones:\nTesting of code is a big thing in programming. Professionals consistently test their code. You will do it in time, too, but in this course, you will only do the basic testing yourself. Instead, you will have access to readymade testing suites made especially for each of your programming projects.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing your code</span>"
    ]
  },
  {
    "objectID": "chapters/python/testing_your_code.html#why-test-your-code",
    "href": "chapters/python/testing_your_code.html#why-test-your-code",
    "title": "17  Testing your code",
    "section": "",
    "text": "Makes you think: Testing forces you to slow down and think about exactly what the code is supposed to do. By deciding what tests to do before you start coding, you try to anticipate errors and cases that need to be covered by how you want to solve the problem. The notion of falsification is important in science and in coding, too. You should try to prove that your idea is wrong and consider it valid only if this process fails. So, testing motivates you to think about ways to break their code, thereby helping you solve your programming problem in a general and robust way so that it does exactly what you expect it to do.\nGives you peace of mind: Testing increases your confidence that a function you have written works as it is supposed to so that you can now stop thinking about how it is implemented and focus on using it as a component in solving a larger, more complicated problem. Having set up a series of tests also allows you to change and improve your function’s implementation without worrying that it stops working the way it is supposed to. As long as it passes all the tests, it should be ok.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing your code</span>"
    ]
  },
  {
    "objectID": "chapters/python/testing_your_code.html#basic-testing",
    "href": "chapters/python/testing_your_code.html#basic-testing",
    "title": "17  Testing your code",
    "section": "Basic testing",
    "text": "Basic testing\nSay that you are asked to make a function that takes a string argument and returns True if that string is a palindrome and False otherwise (hypothetical example). Then you start thinking about which strings should make the function return True and which return False. Once you have defined your is_palindrome function, you can set up some fairly obvious tests like this:\nprint(is_palindome('123321') == True)\nprint(is_palindome('ATGGTA') == True)\nprint(is_palindome('ATGATG') == False)\nprint(is_palindome('XY') == False)\nBut if you keep thinking, maybe you will come up with more tests to cover all the different types of cases you may encounter:\nprint(is_palindome('12321') == True) # uneven length\nprint(is_palindome('121') == True) # uneven length\nprint(is_palindome('AA') == True)\nprint(is_palindome('A') == True) # single char",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing your code</span>"
    ]
  },
  {
    "objectID": "chapters/python/testing_your_code.html#the-project-testing-utility",
    "href": "chapters/python/testing_your_code.html#the-project-testing-utility",
    "title": "17  Testing your code",
    "section": "The project testing utility",
    "text": "The project testing utility\nTo keep you focused on the programming part, each of the programming projects you will do in this course comes with a ready-made suite of tests of the functions you are asked to implement. So, for each function, you can run tests to ensure it implements the behavior it is supposed to.\nEach project comes with two files that you can download from the course page. They have their names for a good reason, so do not change them. In the first project about translating DNA, they are called translationproject.py and test_translationproject.py.\nTo be able to test your functions, you must write your code in the file called translationproject.py. To run your code, you type this in the Terminal as usual:\n\n\nTerminal\n\npython translationproject.py\n\nTo test the functions as you complete each one, you can run the test script test_translationproject.py like this:\n\n\nTerminal\n\npython test_translationproject.py\n\nThe code in test_translationproject.py reads your code in translationproject.py and performs a series of tests of each function. When you run the test script, four things may happen depending on the state of your code:\nCase 1: If you have not yet implemented all the functions, the test script will remind you (once for each test) that you did not implement the functions with the names required.\n\n\nTerminal\n\n*********************************************************\nATTENTION! The following functions are not defined:\n\n    translate_codon\n    split_codons\n    translate_orf\n\nThese functions are either not correctly named (spelled)\nor not defined at all. They will be marked as FAILED.\nCheck your spelling if this is not what you intend.\n*********************************************************\n\nRan 16 tests in 0.000s\n\nOK (skipped=14)\n\nIf you have implemented a function but misspelled its name, you will also get this type of reminder. The reminders are meant to ensure that you do not hand in the assignment with missing or misspelled function definitions.\nCase 2: If a test for one of the functions you have written fails, the testing is aborted, and the script prints some information to help you understand what the problem could be. Say you wrote the function translate_codon wrongly so that it always returns M for some reason:\ndef translate_codon(codon):\n    return 'M' # crazy\nthen you would get this message:\n\n\nTerminal\n\nFAILED TEST CASE: test_translate_codon_2\n\nMESSAGE:\n    The call:\n\n        translate_codon('TAA')\n\n    returned:\n\n        'M'\n\n    However, it should return:\n\n        '*'\n\n======================================================================\nRan 4 tests in 0.001s\n\nFAILED (failures=1)\n\nIt is now left to you to figure out why your function returns the wrong value when called with these arguments.\nCase 3: If you defined all functions correctly and they all work the way they are supposed to, then the test script just prints:\nRan 14 tests in 0.140s\n\nOK",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing your code</span>"
    ]
  },
  {
    "objectID": "chapters/python/your_own_types_of_objects.html",
    "href": "chapters/python/your_own_types_of_objects.html",
    "title": "18  Your kind of thing",
    "section": "",
    "text": "What defines the type of an object?\nDo you know what type you are? Python objects do, and this chapter is about how they know.\nBy now, you know that Python values are objects and that there are different types of objects. Strings have the type str, integers have the type int, and lists have the type list, to mention a few of the ones we know. Remember that you can use the built-in type function to find out what type an object is. Try this:\nAs you already know, objects are “data with associated functionality.” Some of this functionality is available as methods: for example, the upper and split methods of string objects or the append and extend methods of lists.\nObjects also behave sensibly in different contexts: When if you sum two integers (4 + 6), you get their sum 6, but if you sum two strings ('ban' + 'ana'), you get a concatenation of the two strings 'banana'. The two different types of objects each know how to act with the + operator. Another example is iteration: If you iterate over a string, you get one character at a time in order, but if you iterate over a dictionary, you get the keys in the dictionary (in random order). This super convenient context-aware behavior is, in fact, also defined as methods, but more about that below.\nEach object carries its own data: different numbers, different stings, etc., but their functionality is shared by all objects of the same type. So all string objects refer to the same definition of the upper and split methods in the string type as graphically illustrated in figure Figure 18.1.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Your kind of thing</span>"
    ]
  },
  {
    "objectID": "chapters/python/your_own_types_of_objects.html#what-defines-the-type-of-an-object",
    "href": "chapters/python/your_own_types_of_objects.html#what-defines-the-type-of-an-object",
    "title": "18  Your kind of thing",
    "section": "",
    "text": "print( type('banana') )\nprint( type(4) )\nprint( type([]) )\n\n\n\n\n\n\n\n\n\nFigure 18.1: Objects and type. Each object carries its own data, but refers to the type for a definition of its methods.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Your kind of thing</span>"
    ]
  },
  {
    "objectID": "chapters/python/your_own_types_of_objects.html#making-your-own-objects",
    "href": "chapters/python/your_own_types_of_objects.html#making-your-own-objects",
    "title": "18  Your kind of thing",
    "section": "Making your own objects",
    "text": "Making your own objects\nImagine creating your own types of objects carrying a particular kind of data and functionality. “Data” can be anything. In bioinformatics, it could be an open reading frame, a patient profile, or a tree. Fortunately, Python lets us do this using something called classes. Classes define new kinds of objects and the functionality they provide. So, by defining a new class, you define a new type of object, and the methods you define in that class are available to objects of the type that particular kind (type).\nLet’s define a new class, Point, that represents a point in a two-dimensional coordinate system. As shown in Figure 18.2, each such point has an x-value and a y-value, so we need our new point object to hold two numbers representing those values.\n\n\n\n\n\n\nFigure 18.2: Points\n\n\n\nHere is how we define the Point class:\nclass Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\nLet us break it down: We use the keyword class followed by the name of the class we define. Nested under that statement, we can put a",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Your kind of thing</span>"
    ]
  },
  {
    "objectID": "chapters/python/using_code_from_other_files.html",
    "href": "chapters/python/using_code_from_other_files.html",
    "title": "19  Code in other files",
    "section": "",
    "text": "A module is a file with code\nThis chapter is about …",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Code in other files</span>"
    ]
  },
  {
    "objectID": "chapters/python/on_the_shoulders_of_giants.html",
    "href": "chapters/python/on_the_shoulders_of_giants.html",
    "title": "20  Giant’s shoulders",
    "section": "",
    "text": "Using code in other files\nOn the shoulders of giants\nPython modules",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Giant's shoulders</span>"
    ]
  },
  {
    "objectID": "chapters/python/on_the_shoulders_of_giants.html#standard-library-modules",
    "href": "chapters/python/on_the_shoulders_of_giants.html#standard-library-modules",
    "title": "20  Giant’s shoulders",
    "section": "Standard library modules",
    "text": "Standard library modules",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Giant's shoulders</span>"
    ]
  },
  {
    "objectID": "chapters/python/on_the_shoulders_of_giants.html#biopython",
    "href": "chapters/python/on_the_shoulders_of_giants.html#biopython",
    "title": "20  Giant’s shoulders",
    "section": "BioPython",
    "text": "BioPython\n\nA birds eye view of Biopython to give you an impression of what you can do if you know just a little bit about modules classes",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Giant's shoulders</span>"
    ]
  },
  {
    "objectID": "chapters/python/on_the_shoulders_of_giants.html#a-seq-class",
    "href": "chapters/python/on_the_shoulders_of_giants.html#a-seq-class",
    "title": "20  Giant’s shoulders",
    "section": "A Seq class",
    "text": "A Seq class",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Giant's shoulders</span>"
    ]
  },
  {
    "objectID": "chapters/python/on_the_shoulders_of_giants.html#reading-and-writing-sequence-formats",
    "href": "chapters/python/on_the_shoulders_of_giants.html#reading-and-writing-sequence-formats",
    "title": "20  Giant’s shoulders",
    "section": "Reading and writing sequence formats",
    "text": "Reading and writing sequence formats",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Giant's shoulders</span>"
    ]
  },
  {
    "objectID": "chapters/python/appendix_bsf.html",
    "href": "chapters/python/appendix_bsf.html",
    "title": "21  Appendix: PyMol for BSF",
    "section": "",
    "text": "Install Pixi",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Appendix: PyMol for BSF</span>"
    ]
  },
  {
    "objectID": "chapters/python/appendix_bsf.html#install-pixi",
    "href": "chapters/python/appendix_bsf.html#install-pixi",
    "title": "21  Appendix: PyMol for BSF",
    "section": "",
    "text": "Mac Windows\n\n\n\nClick the clipboard icon at the right end of the box below to copy the command to your clipboard.\nOpen your Terminal application.\nPaste the command into the Terminal window and press Enter. You will be prompted several times for either your user password or permissions of the installed apps.\n\ncurl -fsSL https://pixi.sh/install.sh | sh\n\n\n\nClick the clipboard icon at the right end of the box below to copy the command to your clipboard.\nOpen your PowerShell application.\nPaste the command into the PowerShell window and press Enter. You will be prompted several times to allow the app to make changes to your computer.\n\npowershell -ExecutionPolicy ByPass -c \"irm -useb https://pixi.sh/install.ps1 | iex\"\nIf that fails, you can download this interactive installer and run it.",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Appendix: PyMol for BSF</span>"
    ]
  },
  {
    "objectID": "chapters/python/appendix_bsf.html#install-pymol",
    "href": "chapters/python/appendix_bsf.html#install-pymol",
    "title": "21  Appendix: PyMol for BSF",
    "section": "Install PyMol",
    "text": "Install PyMol\n\n Mac Windows\n\n\n\nCreate a folder on your computer dedicated to the BSF course. Let’s say you call it ‘BSF’ and put it in your ‘Documents’ folder.\nOpen your Terminal application, and navigate to that folder using cd (something like cd Documents and then cd BSF).\nOnce you are in the ‘BSF’ folder, paste the command into the Terminal window and press Enter. You will be prompted several times for either your user password or permissions of the installed apps.\n\npixi init --platform osx-64 -c conda-forge -c anaconda -c schrodinger && pixi config set --local run-post-link-scripts insecure && pixi add pyqt \"pymol-bundle=3.1\" \"vtk-m=1.8\"\n\n\n\nCreate a folder on your computer dedicated to the BSF course. Let’s say you call it ‘BSF’ and put it in your ‘Documents’ folder.\nOpen your PowerShell application, and navigate to that folder using cd (something like cd Documents and then cd BSF).\nOnce you are in the ‘BSF’ folder, paste the command into the PowerShell window and press Enter. You will be prompted several times to allow the app to make changes to your computer.\n\npixi init -c conda-forge -c anaconda -c schrodinger ; pixi config set --local run-post-link-scripts insecure ; pixi add pyqt \"pymol-bundle=3.1\" \"vtk-m=1.8\"",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Appendix: PyMol for BSF</span>"
    ]
  },
  {
    "objectID": "chapters/python/appendix_bsf.html#running-pymol",
    "href": "chapters/python/appendix_bsf.html#running-pymol",
    "title": "21  Appendix: PyMol for BSF",
    "section": "Running PyMol",
    "text": "Running PyMol\nIn your BSF folder, run:\npixi run pymol",
    "crumbs": [
      "Learning Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Appendix: PyMol for BSF</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/preface.html",
    "href": "chapters/bioinformatics/preface.html",
    "title": "22  Preface",
    "section": "",
    "text": "What is bioinformatics\nBioinformatics is an interdisciplinary field that combines biology, computer science, mathematics, and statistics to analyze and interpret biological data, particularly large-scale molecular and genetic information. It involves the application of computational methods and techniques to understand biological processes, enhance our knowledge of genetics, and provide insights into various biological phenomena. With advancements in biotechnology, particularly in genomics, transcriptomics, proteomics, and metabolomics, enormous amounts of biological data are generated. These datasets contain information about genes, proteins, molecules, and their interactions. Typical work for a bioinformatician involves data mining and analysis and applying statistical and machine learning techniques to identify patterns, correlations, and significant features in biological datasets.\nBioinformatics involves the development of databases and software tools to efficiently store, organize, and manage these vast datasets. These resources enable researchers to access and manipulate the data for analysis. One of the core aspects of bioinformatics is the analysis of DNA, RNA, and protein sequences. This includes tasks such as sequence alignment, where sequences are compared to identify similarities and differences. Sequence alignment is crucial for understanding evolutionary relationships, identifying functional elements, and detecting genetic variations.\nStructural bioinformatics predicts and analyzes the three-dimensional structures of proteins, RNA, and other molecules. Understanding the structure of biomolecules is essential for comprehending their functions, interactions, and mechanisms. To this end, bioinformaticians also build tools used to predict the functions of genes, proteins, and other biomolecules. This involves comparing sequences to known functional elements or domains and inferring their roles based on similarities.\nBioinformaticians also develop and use algorithms to cluster sequences and construct trees revealing the history and relationships among different species or genes. A related area is the comparison of genomes across different species, revealing insights into genomic evolution, gene conservation, and functional divergence.\nIn medical research, bioinformatics contributes to drug development by predicting potential drug targets, simulating molecular interactions, and identifying candidate compounds for further experimental testing. Bioinformaticians contribute analyses of individuals’ genetic and molecular data and thus support personalized medicine, where medical treatments and interventions can be tailored to a person’s unique genetic makeup.\nIn essence, bioinformatics provides the tools and methodologies to extract meaningful insights from biological data, advancing our understanding of life sciences, genetics, and various other areas of biology. It is a rapidly evolving field that continues to play a pivotal role in modern biological research and applications.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/preface.html#why-should-i-care",
    "href": "chapters/bioinformatics/preface.html#why-should-i-care",
    "title": "22  Preface",
    "section": "Why should I care?",
    "text": "Why should I care?\nYou may wonder how you find yourself with lecture notes on bioinformatics. The reason is that programming and digital literacy are increasingly important for molecular biologists because of the growing reliance on data-driven approaches, high-throughput technologies, and computational analyses in modern biological research. Programming skills and digital literacy empower molecular biologists to efficiently handle data and perform complex analyses. As biological research becomes more intertwined with computational approaches, these skills have become integral for conducting impactful and innovative research in molecular biology. Here are several reasons why these skills are essential for molecular biologists:\nData Handling and Analysis: Molecular biology research generates vast amounts of data from techniques like DNA sequencing, gene expression profiling, and protein structure determination. Programming skills enable scientists to process, analyze, and extract meaningful insights from these large datasets using computational tools and algorithms.\nEfficiency and Automation: Repetitive tasks like data preprocessing can be automated using programming scripts. This increases efficiency and reduces the chances of human error, allowing researchers to focus more on the scientific interpretation of results.\nCustomized Data Analysis: Pre-existing software tools may not always meet specific research needs. With programming skills, molecular biologists can develop custom scripts and algorithms tailored to their experiments, ensuring optimal analysis and interpretation of results.\nStatistical Analysis: Many biological experiments require statistical analysis to draw meaningful conclusions. Programming allows researchers to implement statistical methods, conduct hypothesis testing, and visualize results effectively.\nCollaboration and Communication: Digital literacy allows researchers to effectively collaborate by sharing data, code, and results online. This promotes transparency, reproducibility, and knowledge sharing within the scientific community.\nKeeping Up with Advancements: Many new technologies and techniques in molecular biology are heavily reliant on computational analyses. Researchers with programming skills can easily adapt to new methodologies and stay current with the rapidly evolving field.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/preface.html#reading-this-book",
    "href": "chapters/bioinformatics/preface.html#reading-this-book",
    "title": "22  Preface",
    "section": "Reading this book",
    "text": "Reading this book\nIn this course, we do not cover all aspects of bioinformatics but focus on aspects that relate to the analysis of genes and genomes. These topics will become increasingly dominant as personalized medicine becomes the norm and introduces many essential bioinformatics concepts, models, and algorithms. Many of you follow the course Biological Structure and Function, teaching structural biology in bioinformatics.\nIn each of the topics we cover, we will spend the lectures building an understanding of the algorithms and inner workings of the relevant bioinformatics tools. We will use the exercises to test out some of the tools in small self-contained bioinformatics projects.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/gwas.html",
    "href": "chapters/bioinformatics/gwas.html",
    "title": "23  Genome-wide association studies",
    "section": "",
    "text": "Genetic disease association",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Genome-wide association studies</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/gwas.html#common-disease-common-variant-hypothesis",
    "href": "chapters/bioinformatics/gwas.html#common-disease-common-variant-hypothesis",
    "title": "23  Genome-wide association studies",
    "section": "Common disease common variant hypothesis",
    "text": "Common disease common variant hypothesis\nThe common disease common variant (CDCV) hypothesis is a concept in human genetics that seeks to explain the genetic basis of common complex diseases by focusing on the prevalence of common genetic variants in the population. This hypothesis contrasts with the “rare variant” hypothesis, which suggests that rare genetic variants with larger effects play a significant role in disease susceptibility.\nHypothesis Explanation:\nThe CDCV hypothesis suggests that the genetic susceptibility to many common complex diseases, such as diabetes, heart disease, and certain types of cancer, is primarily influenced by common genetic variants that are present at relatively high frequencies in the population. Common genetic variants are those that occur in more than 1% of the population. These variants are typically single nucleotide polymorphisms (SNPs), where a single DNA base is substituted with another.\nAccording to this hypothesis, multiple common genetic variants, each with a small effect size, collectively contribute to an individual’s risk of developing a specific disease. The idea is that these common variants, which are widely distributed in the population, are responsible for a significant portion of the genetic susceptibility to a given disease.\nKey Points of the CDCV Hypothesis:\nPolygenic Nature: Common complex diseases are often influenced by multiple genetic factors, each with a modest effect size. This polygenic nature suggests that no single genetic variant has a large impact on disease risk.\nComplex Inheritance: Common variants contribute to disease risk in a complex manner, influenced by interactions between genes and the environment. This complexity makes it challenging to predict disease risk solely based on genetic information.\nQuantitative Trait Loci (QTLs): Common variants associated with disease risk are also often associated with variations in quantitative traits, such as blood pressure or cholesterol levels, which are risk factors for certain diseases.\nGenome-Wide Association Studies (GWAS): The CDCV hypothesis has been supported by the findings of genome-wide association studies (GWAS). These studies scan the entire genome for associations between common genetic variants and specific diseases or traits. Many common variants have been identified as having modest effects on disease risk through GWAS.\nStatistical Significance: Given the small effect sizes of individual variants, large sample sizes are often required in GWAS to achieve statistical significance. This emphasizes the cumulative impact of multiple variants on disease risk.\nHeritability Estimates: The CDCV hypothesis aligns with estimates of heritability for common complex diseases, which suggest that a significant portion of the variation in disease risk can be attributed to genetic factors.\nCritiques and Challenges:\nWhile the CDCV hypothesis has provided valuable insights into the genetic basis of common complex diseases, it is not without its criticisms and challenges. Some researchers argue that rare genetic variants with larger effect sizes could also contribute to disease risk and might have been overlooked by traditional GWAS approaches.\nIn recent years, advancements in sequencing technologies and analysis methods have allowed researchers to explore the role of rare variants in disease susceptibility, blurring the distinction between the CDCV hypothesis and the “rare variant” hypothesis. It’s increasingly recognized that both common and rare variants contribute to the overall genetic architecture of complex diseases, and a comprehensive understanding of disease risk requires considering both types of variants.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Genome-wide association studies</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/gwas.html#testing-association",
    "href": "chapters/bioinformatics/gwas.html#testing-association",
    "title": "23  Genome-wide association studies",
    "section": "Testing association",
    "text": "Testing association",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Genome-wide association studies</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/gwas.html#genome-wide-association",
    "href": "chapters/bioinformatics/gwas.html#genome-wide-association",
    "title": "23  Genome-wide association studies",
    "section": "Genome-wide association",
    "text": "Genome-wide association\nIntroduction:\nThe completion of the Human Genome Project in 2003 marked a pivotal milestone in the realm of genomics, providing a comprehensive map of human genetic information. Subsequent advancements in high-throughput genotyping and sequencing technologies have ushered in an era of genome-wide association studies (GWAS), enabling researchers to unravel the complex genetic underpinnings of various traits, diseases, and phenotypic variations. Genome-wide association studies have revolutionized our understanding of the genetic basis of multifactorial traits, providing insights into the interplay between genetics, environment, and disease susceptibility. This introduction aims to provide an academic overview of GWAS, elucidating their methodology, significance, challenges, and potential implications in the fields of genetics, medicine, and personalized healthcare.\nMethodological Underpinnings of GWAS: Genome-wide association studies are designed to identify statistically significant associations between genetic variants and phenotypic traits within a population. These genetic variants, typically single nucleotide polymorphisms (SNPs), are distributed across the human genome. The fundamental approach of GWAS involves genotyping a large number of individuals for a multitude of SNPs, followed by a statistical analysis to identify genetic variants that are overrepresented in individuals with a particular trait or condition. This analysis often involves comparing allele frequencies between cases and controls, taking into account potential confounding factors.\nSignificance and Implications: The insights garnered from GWAS have provided a remarkable understanding of the genetic basis of various complex traits and diseases, including diabetes, cardiovascular diseases, psychiatric disorders, and cancer susceptibility. By pinpointing specific genetic variants associated with disease risk, GWAS have not only expanded our fundamental knowledge of human genetics but have also identified potential therapeutic targets and pathways that underlie these conditions. Moreover, GWAS findings have paved the way for the development of polygenic risk scores, which offer personalized assessments of disease susceptibility based on an individual’s genetic makeup.\nChallenges and Limitations: Despite their transformative impact, GWAS are not without challenges. One of the major limitations is the “missing heritability” phenomenon, where the cumulative effect of identified genetic variants often does not account for the entire heritable component of a trait. Additionally, the identified genetic variants might have modest effect sizes, necessitating the analysis of large sample sizes to achieve statistical significance. The issue of population stratification, where differences in genetic ancestry can lead to spurious associations, requires meticulous consideration in study design and analysis.\nFuture Directions and Implications: As GWAS methodologies continue to evolve, integrating data from diverse populations and incorporating functional genomics approaches hold the promise of unraveling the biological mechanisms underlying identified associations. The emergence of large-scale biobanks, coupled with advancements in computational biology and artificial intelligence, is expected to enhance our ability to predict disease risk, identify novel drug targets, and tailor interventions for individuals based on their genetic profiles.\nConclusion:\nGenome-wide association studies have emerged as a cornerstone of contemporary genetic research, providing a robust framework for unraveling the intricate relationship between genetic variation and complex traits. Their contributions to our understanding of disease etiology, personalized medicine, and the genetic basis of human diversity are undeniable. However, ongoing efforts to address methodological challenges, expand diverse representation, and decipher the functional relevance of identified variants are crucial for fully capitalizing on the potential of GWAS in shaping the future of genetics and healthcare.\nIntroduction to Methods Used in Genome-Wide Association Studies\nGenome-wide association studies (GWAS) have revolutionized the field of genetics and genomics by enabling researchers to uncover the genetic underpinnings of complex traits and diseases. GWAS involve analyzing a vast number of genetic markers across the entire genome to identify associations between specific genetic variants and traits of interest. This introduction provides an overview of the methods used in GWAS and their significance in unraveling the genetic basis of various traits and conditions.\nGenetic Variation and Disease Risk: Human genetic variation plays a crucial role in determining an individual’s susceptibility to various diseases and traits, ranging from common disorders like diabetes and heart disease to more intricate traits such as height or cognitive abilities. GWAS aims to identify the specific genetic variants that contribute to these traits and understand how they influence disease risk or trait expression.\nMarker Selection and Genotyping: In a GWAS, a comprehensive set of genetic markers, typically single nucleotide polymorphisms (SNPs), are selected from across the genome. SNPs are single-letter variations in the DNA sequence that can influence traits. High-throughput genotyping technologies allow researchers to determine the genetic variants present in thousands of individuals simultaneously.\nCase-Control or Cohort Design: GWAS often follow either a case-control or cohort design. In a case-control design, individuals with a specific trait or disease (cases) are compared to individuals without the trait or disease (controls) to identify genetic variants associated with the trait. In a cohort design, a large group of individuals is followed over time to observe the relationship between genetic variants and the development of traits or diseases.\nStatistical Analysis: GWAS involves rigorous statistical analysis to identify associations between genetic variants and traits. The basic approach is to compare the frequency of each genetic variant between cases and controls. Variants that show significantly different frequencies are considered potentially associated with the trait. Various statistical tests, such as chi-square tests or logistic regression, are employed to assess the strength and significance of these associations.\nPopulation Stratification and Confounding: One challenge in GWAS is population stratification, where differences in genetic ancestry among study participants can lead to false positive associations. To mitigate this, researchers use methods to correct for population structure and confounding factors that might influence the results.\nMultiple Testing Correction: Due to the large number of genetic markers tested, there’s a risk of identifying false positives by chance alone. Multiple testing correction methods, such as the Bonferroni correction or false discovery rate control, are employed to account for the increased likelihood of false positives and to determine statistical significance thresholds.\nLinkage Disequilibrium and Fine-Mapping: Genetic variants in close proximity on the same chromosome often exhibit linkage disequilibrium (LD), meaning they are inherited together more frequently than expected by chance. This property allows researchers to pinpoint the region of the genome where the causal variant likely resides. Fine-mapping techniques aim to narrow down the location of the true causal variant within an associated region.\nIn conclusion, GWAS represent a powerful approach to uncovering the genetic factors influencing traits and diseases. By combining advanced genotyping technologies, robust statistical methods, and meticulous study designs, researchers can identify key genetic variants associated with various conditions, shedding light on the underlying biological mechanisms and paving the way for more personalized approaches to healthcare and disease prevention. ## Do it yourself: Exploring an association with Parkinsons disease {-}\nThe purpose of this exercise is to expose you to the different kinds of information that are stored in databases relevant to bioinformatics. It takes experience and skill to navigate the user interface of these databases. Here you will see a few of the important ones, but there are many more. I have put a list at the end of this exercise with some additional relevant ones. Browse them at your harts content.\nThe MacGuffin of this exercise is Parkinsons disease (PD). Millions of people live with PD, which is a progressive incurable disease affecting the nervous system resulting in shaking, involuntary movement and trouble talking and walking. PD is a complex and multifactorial disease with a heritable component: close relative of people with PD have higher risk. 15% of PD patients have a parent, sibling or child with PD. However, unlike other genetic diseases like cystic fibrosis, where a single gene is responsible, the risk of developing PD is determined by small contributions of many different genes. These genes interact with environmental conditions, such as tobacco smoke. PD symptoms are induced by death certain brain cells in the sunstiantia migraine part of the brain that normally produces the neurotransmitter dopamine.\nIn the study published in by Do at al. 2011, the authors searched for genes contributing to the risk of developing PD. They genotyped 3,426 PD patients (cases) and 29,624 healthy controls for 522,782 single nucleotide polymorphisms SNPs. A SNP is a position in the genome where the nucleotide differ between individuals in a population because some carry a recent mutation (G) and others carry the ancestral variant (A). Simply put, they considered each of the 522,782 SNPs to see if the occurrence of one of the alleles was significantly more often found among the individuals with PD than among healthy controls. Knowing only the number of cases and controls and the total numbers of A and G alleles, the expected number of A and G alleles found among cases and controls can be computed (E.g. the expected number of cases with the A allele is \\((3426 * 23615) / 33050 \\approx 2448\\)):\n|—:|—:|—:|—:| | | A | G | Totals | | Cases | 2448 | 978 | 3426 | | Controls | 21167 | 8456 | 29624 | | Totals | 23615 | 9434 | 33050 |\nThis corresponds to an expected frequency of Allele A of 40% in both cases and controls. In the study the they observed the following numbers in each group;\n|—:|—:|—:|—:| | | Allele 1 | Allele 2 | Totals | | Cases | 2320 | 1106 | 3426 | | Controls | 21295 | 8328 | 29624 | | Totals | 23615 | 9434 | 33050 |\nCorresponding to a 48% frequency of allele A among cases and a 39% frequency among controls. To test the statistical significance of this deviation from the expectation, we can perform a Chi-square testto compute the p-value for the above case. The test statistic is very simple:\n\\[ \\sum \\frac{(observed - expected)^2}{expected} \\]\nUnder the null-hypothesis, the test statistic follows a chi-square distribution with 1 degree of freedom. You can even do this in Python using the chi2_contingency from the script.stats library. Try it out and see what the p-value is in this case:\nfrom scipy.stats import chi2_contingency\nobserved = [[2320, 1106],\n            [21295, 8328]]\nstat, p_value, deg_free, expected = chi2_contingency(observed, correction=False)\nprint(p_value)\nThe p-value is probably something like 3e-07, which you may think is really small. Normally we use 0.05 as our significance cutoff - the probability of wrongly rejecting our null hypothesis of no association. Since there is a 0.05 probably in every test, we need to divide our significance cutoff by the number of tests to get the significance cutoff needed to only wrongly reject the null-hypothesis with 0.05 probability after doing all 522,782 tests. This cutoff is \\(0.05 / 522782 = 9.56e-08\\). This adjustment of the significance cutoff is called Bonferroni correction overcorrects a bit, but the correction shows that even p-values as low as the one you computed above is only just significant in a GWAS.\nThat is pretty much what GWAS is. There are some additional nuts and bolts required to take biases into account. Accounting for cases and controls not being sampled in the same way. You can probably imagine why the SNPs determining eye color would show up as associated with PD if all cases were sampled in Spain and all controls in Finland. However, we will gloss over those details here.\nThe SNPs associated with PD are not themselves involved in PD, but they mark a genomic neighborhood that is inherited along with the SNP. The closer a gene is to an associated SNP, the more likely it is that the gene is inherited along with the SNP. So it this genomic neighborhood that we should search for genes playing a role in the development of PD. Such candidate genes must be identified for new insights into causes of the disease and how it can be treated. The following part the of the exercise, but is meant to take you though some of the motions that a scientist would go through to search relevant genes in the region.\n\nEach known SNP has a unique accession number that identifies it.\nThe SNP identified by Do et al. has accession number rs11868035\nTo explore the genomic neighbourhood of this SNP we use the UCSC genome browser.\nThe genome browser saves your preferences across sessions so if you have tried this service before before you can reset the browser to the default settings to align the views with this exercise. Click the Genome Browser-&gt;Reset All User Settings option in the top menu bar. However, be aware that this action will remove all custom tracks and will clear all track filter and configuration settings that may have modified.\nUnder “Find Position” select the most recent human genome assembly (hg38) and paste in rs11868035 under “Position/Search Term” and click GO.\nOn the resulting listing click the top link under “NHGRI-EBI Catalog of Published Genome-Wide Association Studies”.\nFamiliarise yourself with the browser view.\nNotice the SNP shown in the middle of the “NHGRI-EBI Catalog of Published Genome-Wide Association Studies” track.\nNotice the scale shown at the top of the view. What part of the genome is shown? The chromosome ideogram at the top also shows with a red marker what part of the chromosome is shown. Use the zoom buttons to zoom out so you can see a see roughly 1,000 kilobases (1,000,000 base pairs) of the genome.\nThe view is divided into tracks. Mousing over the right margin of each track will highlight it in green, and right-clicking will show customisation settings for each track. By holding and dragging on the grey bars furthest to the right, you can even reorder tracks as you please.\nScrolling down below the view, you can see a large number of tracks you can enable to show in the view.\nIn the “Phenotype and Literature” section find the dropdown labelled OMIM Genes and chose the view mode “Pack”. Similarly, in the “Expression” section find and enable the track called GNF Atlas 2. Finally, “Mapping and Sequencing”, find the Publications track and choose the “Dense” view mode. Now click any of the “Refresh” buttons to update the view with the selected tracks.\nIf you click the grey bar on the right of each track, you are redirected to a page explaining the track.\n\n\n\nIn part I of the exercise, the UCSC “Genes” track has been replaced by “GENCODE v29”. If you do not see the “GENCODE v29” track or the “RefSeq Genes” and “Human mRNAs” tracks, scroll down to the drop-down menus under “Gene and Gene Predictions” and select “GENCODE v29” and “NCBI RefSeq”. The “Human mRNAs” track can be found under “mRNA and EST”. Unfortunately, the GAD view and the Publications track are no longer available.\n\nHave them read a GWAS review\nPart of the exercise could be to make chi-square tests for the subset of SNPs in the region to see if they get something similar to\nimport matplotlib.pyplot as plt\n\npvalues = [1,2,3]\ncoordinates = [1,2,1]\nplt.scatter(pvalues, coordinates)\nplt.title('Plot 1')\nplt.show()\n\npvalues = [1,2,3]\ncoordinates = [1,2,3]\nplt.scatter(pvalues, coordinates)\nplt.title('Plot 2')\nplt.show()",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Genome-wide association studies</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/databases.html",
    "href": "chapters/bioinformatics/databases.html",
    "title": "24  Databases",
    "section": "",
    "text": "GenBank\nBioinformatics databases are crucial resources that provide access to a vast array of biological data, ranging from genetic sequences and protein structures to functional annotations and disease-related information. These databases play a pivotal role in various research fields, aiding scientists in data analysis, hypothesis testing, and discovery. Here’s an overview of some of the most important bioinformatics databases and how to use them:\nGenBank is a comprehensive database maintained by the National Center for Biotechnology Information (NCBI) that contains DNA sequences submitted by researchers worldwide. It includes sequences from various organisms, along with associated metadata and annotations. Users can search for specific sequences, access genome assemblies, and retrieve information for various genomic regions.\nKey Features of GenBank:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Databases</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/databases.html#genbank",
    "href": "chapters/bioinformatics/databases.html#genbank",
    "title": "24  Databases",
    "section": "",
    "text": "Sequence Collection: GenBank contains a vast collection of DNA, RNA, and protein sequences from diverse organisms, including viruses, bacteria, fungi, plants, animals, and more.\nAnnotations: Sequences in GenBank are accompanied by annotations that provide valuable information about the sequence, such as gene names, protein products, functional regions, and other relevant data.\nGenomic Assemblies: GenBank hosts whole genome assemblies for many organisms, enabling researchers to access and analyze complete genomes.\nVersioning: Each sequence in GenBank is assigned a version number to track changes and updates. This allows researchers to access historical versions of sequences.\nCross-References: GenBank cross-references other databases and resources, facilitating integration and collaboration among different data sources.\nBioProject and BioSample: GenBank integrates with BioProject and BioSample databases, providing additional context for submitted sequences, such as information about the source organism and experimental details.\nSearch and Retrieval: The GenBank website offers a user-friendly interface for searching and retrieving sequences based on keywords, accession numbers, organisms, and more.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Databases</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/databases.html#uniprot",
    "href": "chapters/bioinformatics/databases.html#uniprot",
    "title": "24  Databases",
    "section": "UniProt",
    "text": "UniProt\nUniProt is a database that provides detailed information about protein sequences and their functional annotations. It integrates data from various resources, offering a centralized repository for protein-related information. Researchers can search for proteins by name, sequence, or keywords and access data such as protein function, structure, domains, and post-translational modifications.\nUniProt (Universal Protein Resource) is a comprehensive and widely used bioinformatics database that provides a centralized repository of protein sequences and functional information. Maintained collaboratively by the European Bioinformatics Institute (EBI), the Swiss Institute of Bioinformatics (SIB), and the Protein Information Resource (PIR), UniProt serves as a valuable resource for researchers, educators, and students in the fields of biology, genetics, and molecular biology.\nUniProt is divided into three main components:\n\nUniProtKB: This is the primary component, providing a comprehensive collection of protein sequences and annotations. UniProtKB is further subdivided into three subdatabases:\nUniProtKB/Swiss-Prot: Curated protein entries with high-quality annotations. UniProtKB/TrEMBL: Automatically annotated protein entries that have not yet been curated. UniRef: This component clusters closely related protein sequences into UniRef clusters, reducing redundancy and simplifying sequence analysis.\nUniParc: UniParc contains a unique and non-redundant collection of all publicly available protein sequences, regardless of their level of annotation.\n\nKey Features of UniProt:\n\nProtein Sequences: UniProt contains a vast collection of protein sequences from a wide range of organisms, including bacteria, archaea, fungi, plants, animals, and viruses.\nFunctional Annotations: Each protein entry in UniProt is accompanied by extensive functional annotations, providing information about the protein’s biological role, structure, domains, post-translational modifications, interactions, subcellular localization, and more.\nCross-References: UniProt integrates information from other databases and resources, offering cross-references to relevant data sources, such as gene databases, literature citations, and 3D protein structures.\nIsoforms and Variants: UniProt includes information about protein isoforms, splice variants, and natural variants that affect protein function.\nTaxonomic Information: Protein entries are categorized based on taxonomy, enabling users to explore protein diversity across different organisms.\nSequence Alignments: UniProt provides sequence alignments for families of homologous proteins, aiding in understanding protein evolution and relationships.\nDisease Annotations: UniProt includes annotations linking proteins to various diseases, such as genetic disorders and cancers, based on experimental evidence.\nLiterature Citations: Protein entries often include references to scientific literature, allowing users to access the original research articles related to specific proteins.\nKeywords and Annotations: UniProt uses controlled vocabularies to assign keywords and annotations to proteins, facilitating standardized and structured data representation.\n\nUsage of UniProt:\n\nSearch: Enter protein names, identifiers, gene names, keywords, or organisms in the search bar.\nBrowse: Explore protein entries by taxonomy, organism, keywords, and functional annotations.\nRetrieve Information: Access protein sequences, functional annotations, cross-references, and literature citations.\nAnalyze: Utilize the provided data to understand protein function, structure, interactions, and disease associations.\nIntegration: Integrate UniProt data with other bioinformatics tools and resources for comprehensive analyses.\nUniProt is an invaluable resource for researchers studying proteins, their functions, and their roles in various biological processes. Its user-friendly interface, extensive annotations, and cross-referencing capabilities make it a cornerstone tool in the field of molecular biology.\n\nPubMed: PubMed is a database maintained by the National Library of Medicine, offering access to an extensive collection of biomedical literature. Researchers can search for articles related to specific topics, diseases, genes, or proteins. PubMed provides abstracts, full-text articles, and links to external resources, aiding literature review and research planning.\nEnsembl: Ensembl is a genome browser and annotation database that provides genomic sequences, gene annotations, and functional information for a wide range of species. Users can explore gene structures, regulatory elements, genetic variations, and comparative genomics data. Ensembl’s browser interface allows for interactive exploration of genomic regions.\nNCBI Gene: This database offers comprehensive information about genes, including functional annotations, expression data, gene-disease associations, and orthologous relationships. Researchers can search for specific genes, access genetic and protein sequences, and retrieve details about gene function and expression patterns.\nThe NCBI Gene database, maintained by the National Center for Biotechnology Information (NCBI), is a comprehensive resource that provides information about genes from a wide range of organisms. It serves as a centralized repository for gene-related data, annotations, and functional information. The database plays a crucial role in molecular biology research, aiding scientists in understanding gene functions, interactions, and regulatory mechanisms.\nKey Features of the NCBI Gene Database:\nGene Information: The NCBI Gene database contains detailed information about individual genes, including gene names, symbols, aliases, genomic locations, chromosomal coordinates, and orientations.\nGene Function: Each gene entry is accompanied by functional annotations that describe the gene’s biological roles, molecular functions, and involvement in cellular processes.\nTranscripts and Isoforms: The database provides information about different transcript variants and isoforms associated with a gene. This includes details about alternative splicing, coding regions, and untranslated regions.\nOrthologs and Paralogs: NCBI Gene includes information about orthologous and paralogous genes across different species, aiding in understanding gene evolution and relationships.\nHomology and Alignment: Gene entries often include sequence alignments, similarity scores, and evolutionary relationships with related genes.\nProtein Products: NCBI Gene provides information about the protein products encoded by genes, including functional domains, post-translational modifications, and protein interactions.\nGene Ontology (GO) Annotations: Many gene entries are associated with Gene Ontology terms that categorize gene functions, cellular components, and biological processes.\nExpression Data: The database offers data on gene expression patterns in various tissues, developmental stages, and conditions, aiding in understanding gene regulation.\nGenomic Context: Gene entries include information about neighboring genes, regulatory elements, and genetic variations in the genomic vicinity.\nDisease Associations: Gene entries may include annotations linking genes to specific diseases, based on experimental evidence.\nUsage of the NCBI Gene Database:\nTo use the NCBI Gene database effectively:\nSearch: Enter gene names, symbols, IDs, or keywords in the search bar. Browse: Explore gene entries by species, functional annotations, and genomic locations. Retrieve Information: Access gene details, functional annotations, orthologs, paralogs, and protein products. Analyze: Utilize the provided data to understand gene functions, expression patterns, and disease associations. Cross-Reference: NCBI Gene integrates with other NCBI databases, providing links to nucleotide sequences, protein sequences, PubMed articles, and more. The NCBI Gene database serves as a critical resource for researchers studying individual genes and their roles in various biological processes. Its comprehensive annotations, integration with other NCBI resources, and user-friendly interface make it an essential tool for molecular biologists, geneticists, and researchers across diverse fields.\ndbSNP: The Single Nucleotide Polymorphism Database (dbSNP) is a repository of genetic variations, including SNPs and other types of variations. Researchers can search for specific variations, retrieve their annotations, and explore data related to population frequencies, diseases, and functional effects.\nThe dbSNP (Single Nucleotide Polymorphism Database) is a comprehensive bioinformatics resource maintained by the National Center for Biotechnology Information (NCBI). It serves as a repository for genetic variations, including single nucleotide polymorphisms (SNPs), insertions, deletions, and other types of genetic variants. dbSNP plays a crucial role in cataloging and providing access to genetic variations across various species, aiding researchers in understanding the genetic basis of traits, diseases, and population diversity.\nKey Features of the dbSNP Database:\nVariation Catalog: dbSNP contains a wide variety of genetic variations, including SNPs, short insertions and deletions (indels), microsatellites, and larger structural variants.\nVariant Annotations: Each genetic variant is accompanied by annotations, such as genomic coordinates, alleles, frequencies in different populations, and clinical significance (if applicable).\nPopulation Data: dbSNP provides information about the frequency of genetic variants in different human populations, enabling researchers to study population genetics and diversity.\nFunctional Annotations: Many genetic variants are annotated with potential functional consequences, such as effects on protein coding, splicing, or regulatory elements.\nCross-References: dbSNP cross-references other databases, allowing users to access additional information about genes, proteins, and diseases associated with specific genetic variants.\nGenomic Context: The database includes information about the genomic context of variations, such as neighboring genes, regulatory elements, and conserved regions.\nClinVar Integration: dbSNP integrates with the ClinVar database, providing information about the clinical significance of genetic variants and their associations with diseases.\nGenome Build Compatibility: dbSNP supports different genome builds, enabling users to map variations to specific versions of the genome.\nUsage of the dbSNP Database:\nTo use the dbSNP database effectively:\nSearch: Enter SNP IDs, genomic coordinates, gene names, or keywords in the search bar. Browse: Explore variants by chromosome, population, frequency, or functional annotations. Retrieve Information: Access variant details, genomic coordinates, allele frequencies, and clinical significance information. Analyze: Utilize variant annotations for studying disease associations, population genetics, and functional effects. Integration: Combine dbSNP data with other resources to enhance genetic and genomic analyses. dbSNP is a crucial resource for researchers investigating the genetic variations that contribute to phenotypic differences, diseases, and population diversity. Its extensive collection of annotated variants, integration with other databases, and user-friendly interface make it an indispensable tool for geneticists, epidemiologists, and researchers in related fields.\nOMIM: Online Mendelian Inheritance in Man (OMIM) is a database that catalogs genetic mutations and their relationships to inherited diseases. Researchers can search for genes, phenotypes, and diseases to access information about genetic disorders, associated mutations, and relevant literature.\nThe Online Mendelian Inheritance in Man (OMIM) database is a comprehensive and authoritative resource that catalogues information about genetic disorders, traits, and other phenotypic traits in humans. Maintained by the McKusick-Nathans Institute of Genetic Medicine at Johns Hopkins University, OMIM plays a pivotal role in bridging the gap between genetic research and clinical medicine, providing valuable insights into the genetic basis of various human conditions.\nKey Features of the OMIM Database:\nGenetic Disorders: OMIM contains detailed information about a wide range of genetic disorders, both rare and common, providing insights into the genetic mutations, inheritance patterns, clinical features, and molecular mechanisms underlying these conditions.\nPhenotypic Traits: In addition to genetic disorders, OMIM also catalogues information about various phenotypic traits, such as physical characteristics, susceptibility to diseases, and responses to treatments.\nGene-Centric Information: OMIM provides gene-centric entries that include information about specific genes associated with genetic disorders. These entries detail gene functions, mutations, protein products, and any known associations with diseases or traits.\nClinical Descriptions: Each entry includes detailed clinical descriptions of the disorders or traits, including symptoms, diagnostic criteria, and information about disease progression.\nGenetic Inheritance Patterns: OMIM categorizes disorders based on their inheritance patterns, such as autosomal dominant, autosomal recessive, X-linked, and mitochondrial.\nGene and Locus References: OMIM cross-references genes and loci to other databases and resources, facilitating integration with genomic and functional data.\nLinks to Literature: OMIM entries include references to scientific literature, providing access to primary research articles and reviews related to specific disorders and genes.\nMolecular Mechanisms: Many OMIM entries describe the molecular mechanisms underlying genetic disorders, providing insights into how mutations affect biological processes.\nUsage of the OMIM Database:\nTo use the OMIM database effectively:\nSearch: Enter disease names, gene names, phenotypic keywords, or gene identifiers in the search bar. Browse: Explore entries by disease categories, gene names, inheritance patterns, and other criteria. Retrieve Information: Access detailed information about genetic disorders, phenotypic traits, genes, clinical descriptions, and molecular mechanisms. Analyze: Utilize the provided data to understand the genetic basis of diseases, inheritance patterns, and potential therapeutic targets. Integration: Combine OMIM data with other genetic and genomic resources to enhance research and clinical applications. OMIM is widely used by geneticists, clinicians, researchers, and healthcare professionals to gain insights into the genetic underpinnings of diseases, guide clinical diagnoses, and inform therapeutic strategies. Its rich content, authoritative sources, and user-friendly interface make it an essential tool for anyone involved in genetics and genomics research.\nSTRING: The STRING database provides information about protein-protein interactions and functional associations. Users can search for a protein of interest to explore its interactions, view network maps, and analyze the potential functions of proteins within a network context.\nTo use these databases effectively:\nKeyword Search: Start by entering relevant keywords, gene names, protein identifiers, or disease names in the search bar. Filters: Many databases offer filters to refine search results based on criteria such as species, data type, and publication date. Advanced Search: Use advanced search options to specify specific fields or search criteria to narrow down results. Data Retrieval: Once you find relevant information, you can often download sequences, annotations, and other data for further analysis. Citations: When using data from these databases in your research, make sure to provide proper citations to acknowledge the original sources. These databases are continuously updated and expanded, so it’s essential to explore their documentation and tutorials to stay informed about the latest features and search strategies.\nThe STRING database (Search Tool for the Retrieval of Interacting Genes/Proteins) is a valuable bioinformatics resource that provides information about protein-protein interactions (PPIs) and functional associations. STRING helps researchers explore the relationships between proteins, gain insights into biological processes, and understand the complex networks that underlie various cellular functions. Maintained by a collaborative team of researchers, STRING is widely used in various fields, including molecular biology, systems biology, and drug discovery.\nKey Features of the STRING Database:\nProtein Interaction Data: STRING aggregates and integrates experimental and computational data on protein interactions from diverse sources, including high-throughput experiments, curated databases, and literature mining.\nFunctional Associations: Beyond direct physical interactions, STRING provides information about functional associations between proteins, such as co-expression, shared domains, and similar annotations.\nConfidence Scores: STRING assigns confidence scores to interactions and associations based on the evidence supporting them. These scores help users assess the reliability of the reported interactions.\nNetwork Visualization: STRING generates interactive graphical representations of protein networks, allowing users to visualize and explore protein interactions and functional relationships in a visual format.\nSpecies Coverage: STRING supports a wide range of organisms, from model organisms to less-studied species, enabling researchers to investigate protein interactions in different biological contexts.\nEnrichment Analysis: STRING offers enrichment analysis tools that help users identify overrepresented functional categories, pathways, and Gene Ontology terms within a set of proteins of interest.\nPrediction Methods: STRING includes computational prediction methods that estimate potential interactions based on sequence similarities, domain architectures, and other features.\nCross-References: STRING provides cross-references to external resources, allowing users to access additional information about interacting proteins, pathways, and diseases.\nUsage of the STRING Database:\nTo use the STRING database effectively:\nSearch: Enter protein names, identifiers, or keywords to find interactions and associations. Network Visualization: Explore and visualize protein interaction networks, adjusting confidence thresholds and interaction types. Retrieve Information: Access interaction scores, functional annotations, pathway information, and external references. Analyze: Utilize the provided data to understand protein functions, regulatory mechanisms, and disease associations. Enrichment Analysis: Perform enrichment analysis to identify functional themes within a set of proteins. Integration: Combine STRING data with other omics data to gain a holistic understanding of cellular processes. STRING is a versatile tool for researchers investigating protein interactions, cellular pathways, and systems-level biology. Its user-friendly interface, comprehensive data sources, and advanced analysis features make it an essential resource for studying the complex molecular networks that govern biological functions.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Databases</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/databases.html#sequence-databases",
    "href": "chapters/bioinformatics/databases.html#sequence-databases",
    "title": "24  Databases",
    "section": "Sequence databases",
    "text": "Sequence databases",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Databases</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/databases.html#genome-browsers",
    "href": "chapters/bioinformatics/databases.html#genome-browsers",
    "title": "24  Databases",
    "section": "Genome browsers",
    "text": "Genome browsers\nThe UCSC Genome Browser is a widely used and comprehensive online tool for visualizing and exploring genomic information from a wide range of organisms. Developed and maintained by the University of California, Santa Cruz (UCSC), this browser offers a user-friendly interface to navigate and analyze genomes, gene structures, regulatory elements, genetic variations, and other genomic features. Here’s an overview of the UCSC Genome Browser and its key features:\nFeatures of the UCSC Genome Browser:\nGenome Selection: The UCSC Genome Browser supports a vast collection of genomes from various species, including humans, model organisms, and microbes. Users can select the genome of interest from a dropdown menu.\nGenome Views: The browser provides different views of the genome, including the standard linear view, a circular view (for some genomes), and a conservation view that highlights evolutionarily conserved regions.\nNavigation and Zoom: Users can easily navigate through genomic regions using navigation arrows and zoom controls. This allows detailed examination of specific regions.\nAnnotation Tracks: One of the most powerful features of the UCSC Genome Browser is the ability to overlay various types of annotation tracks onto the genome view. These tracks include gene annotations, regulatory elements, genetic variations, and more. Users can customize which tracks are displayed and adjust their visibility and order.\nGene Annotations: The browser displays gene structures, including exons, introns, coding sequences, and untranslated regions. It provides information about gene names, functions, and alternative splicing patterns.\nRegulatory Elements: Regulatory elements such as promoters, enhancers, and transcription factor binding sites can be visualized, aiding in understanding gene regulation.\nGenetic Variations: Genetic variations, including single nucleotide polymorphisms (SNPs), insertions, and deletions, can be displayed. Users can examine variations’ positions, alleles, frequencies, and potential functional consequences.\nCustom Tracks: Users can upload their own data, such as experimental results or custom annotations, to visualize alongside the provided tracks.\nComparative Genomics: The browser offers tools to compare genomic sequences and annotations across multiple species. This aids in identifying conserved regions and evolutionary changes.\nSearch and Highlight: Users can search for specific genes, regions, sequences, or annotations and highlight them in the genome view for detailed examination.\nLinks to External Resources: The UCSC Genome Browser provides links to external databases and resources, enabling seamless access to additional information.\nUsage:\nTo use the UCSC Genome Browser:\nAccess the Browser: Go to the UCSC Genome Browser website (genome.ucsc.edu).\nChoose a Genome: Select the genome of interest from the dropdown menu.\nNavigate and Explore: Navigate to specific genomic regions using the search bar, navigation arrows, and zoom controls. Customize the displayed tracks to focus on relevant features.\nAnalyze and Download: Analyze gene structures, regulatory elements, and genetic variations in the context of the genome. Download data and images for use in research or presentations.\nThe UCSC Genome Browser serves as an invaluable resource for researchers, educators, and students seeking to understand and analyze genomic information across various organisms. Its intuitive interface, extensive collection of annotation tracks, and powerful visualization capabilities make it a cornerstone tool in the field of genomics.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Databases</span>"
    ]
  },
  {
    "objectID": "chapters/web/gwas_databases/index.html",
    "href": "chapters/web/gwas_databases/index.html",
    "title": "25  GWAS candidates",
    "section": "",
    "text": "Browsing SNPs from a GWAS\nThe purpose of this exercise is to expose you to the different kinds of information that are stored in databases relevant to bioinformatics. It takes experience and skill to navigate the user interface of these databases. Here, you will see a few important ones, but there are many others. I have put a list at the end of this exercise with some additional relevant ones on Brightspace. Browse them at your heart’s content.\nGenome-wide association studies (GWAS) are a powerful tool in genetics and genomics research to identify genetic variants associated with diseases or traits. When a significant SNP is identified in a GWAS, it is a genomic signpost tagging an associated genomic region. Still, it only partially reveals the genes causing the disease if the genomic region identified contains several genes or genomic features. Investigating candidate disease genes near a GWAS SNP involves: Exploring the genomic region around the SNP. Studying nearby genes and regulatory elements. Evaluating their potential roles in the disease or trait of interest. A standard GWAS only includes a select subset of the SNPs in the genome. So, the most significant included SNP variant is rarely responsible for the disease. Still, it is so close to the causal one that individuals with the causal SNP variant carry it. The closer two SNPs are along the genome, the more likely they appear together like this. The further away from each other, the more likely it is that genetic recombination has removed this correlation.\nType 1 diabetes, often referred to as juvenile diabetes or insulin-dependent diabetes, is a chronic autoimmune condition that affects how the body regulates blood sugar (glucose). Unlike type 2 diabetes, which is commonly associated with lifestyle factors such as obesity and physical inactivity, type 1 diabetes is not preventable and typically develops early in life, often during childhood or adolescence. In type 1 diabetes, the immune system, usually responsible for defending the body against harmful invaders like bacteria and viruses, becomes misguided. It mistakenly identifies the insulin-producing beta cells within the pancreas as foreign threats. This misrecognition triggers an autoimmune response, leading immune cells to launch an attack on these vital beta cells. The pancreas, an organ located behind the stomach, is a key player in regulating blood sugar levels. It consists of clusters of cells called the Islets of Langerhans, which house the insulin-producing beta cells. When the immune system attacks these beta cells, it results in their destruction or severe impairment. This process is thought to involve various immune cells, such as T-cells and antibodies, which play pivotal roles in autoimmune reactions. Due to this autoimmune attack, the pancreas gradually loses its ability to produce insulin, a hormone with crucial responsibilities in maintaining proper blood sugar balance. Insulin acts as a molecular key that unlocks the doors of cells throughout the body, allowing glucose to enter and be used as an energy source. Think of insulin as a bridge that facilitates the movement of glucose from the bloodstream into cells. Research into type 1 diabetes is ongoing, and scientists are exploring potential cures and better management strategies. However, until a cure is found, individuals with type 1 diabetes continue to lead fulfilling lives by effectively managing their condition through insulin therapy, a balanced diet, regular exercise, and closely monitoring their blood sugar levels.\nStart by examining a Manhattan plot or list of significant SNPs obtained from a GWAS study. We are going to select one of these SNPs and do further analysis. While doing the analysis, note the SNP identifier (rsID) and its significance level (p-value). Go to locuszoom.org and press the blue button shown on Figure 25.1:\nNow, you should be able to search for public GWAS studies. Copy/paste “Rare Genetic Variants of Large Effect Influence Risk of Type 1 Diabetes” into the search bar. Only one result should show up. Press it. Now, you are ready to examine the Manhattan plot. You can see a lot of significant SNPs in the Manhattan plot, and you are welcome to examine them, but the one we are interested in for this exercise is the one located close to RSBN1. Click it, and it will zoom in. The SNP has an rsID of rs6679677, and its position is 113.761.186 on chromosome 1. It’s a C to A mutation. Save this information because we will use it for the rest of the exercise.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>GWAS candidates</span>"
    ]
  },
  {
    "objectID": "chapters/web/gwas_databases/index.html#browsing-snps-from-a-gwas",
    "href": "chapters/web/gwas_databases/index.html#browsing-snps-from-a-gwas",
    "title": "25  GWAS candidates",
    "section": "",
    "text": "Figure 25.1: Screenshot of the LocusZoom website",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>GWAS candidates</span>"
    ]
  },
  {
    "objectID": "chapters/web/gwas_databases/index.html#exploring-a-genomic-region",
    "href": "chapters/web/gwas_databases/index.html#exploring-a-genomic-region",
    "title": "25  GWAS candidates",
    "section": "Exploring a genomic region",
    "text": "Exploring a genomic region\nIn this section, we are going to explore our SNP and its surrounding genomic regions to identify our candidate gene/genes for diabetes type 1. Go to the UCSC Genome Browser. In the “Human Assembly” drop-down, make sure it says “GRh38/hg38”. That way, you access the genome assembly also used in the GWAS study. If you choose another one, the SNP and gene coordinates will be different. Now paste your SNP identifier rs6679677 into the search field where it says “Position/Search Term” and click GO. You will get a list of search results. Clicking the link in the top one (if it says rs6679677) should take you to a page centered on this SNP looking something like the one shown in Figure 25.2:\n\n\n\n\n\n\nFigure 25.2: Screenshot of the UCSC genome browser\n\n\n\nNow, you see the SNP in a window. You can play around with the zoom function until you start seeing a couple of other SNP IDs. Now we want to look at surrounding genes, so scroll down to the “Genes and Gene predictions” Section. All the options you see here are called “tracks”, and they all contain different information about the genome. If you want to look at the annotated gene, select the “GENCODE V44” select “pack” and press refresh on the right side of the section. Play around with the different settings (pack, dense, squish, all). They all give you a different amount of information. Select the one that you are most comfortable with when exploring. You might have to change it for some types of questions. “Pack” is a good place to start.\n\nExercise 25-1\nPlay around with the zoom function. To the left of where you inserted the SNP ID is the size of the window you are looking at. The more you zoom out, the more genes you will be able to see.\n\n\nExercise 25-2\nIdentify nearby genes, including their names, locations, and orientations. Remember that linkage means that the causal gene may not be the one closest to the GWAS SNP. Are there any genes located close to the SNP of interest? If yes. Note them down for further analysis.\n\n\nExercise 25-3\nWhat is the genomic context (e.g., intronic, intergenic) of the SNP?\n\n\nExercise 25-4\nYou see the same gene multiple times in the gene track. Why do you think that is?\n\n\nExercise 25-5\nTry to select other tracks such as promoters (EPDnew Promoters) and regulatory elements (ENCODE Regulation). See if there are known regulatory elements, such as enhancers or promoters, in the vicinity of the SNP.\n\n\nExercise 25-6\nAre there any annotated regulatory elements near the SNP that might influence gene expression? Try to press the regulatory track. What kind of information does this track represent? (Hint: Read the description of the track).",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>GWAS candidates</span>"
    ]
  },
  {
    "objectID": "chapters/web/gwas_databases/index.html#gathering-information-about-genes",
    "href": "chapters/web/gwas_databases/index.html#gathering-information-about-genes",
    "title": "25  GWAS candidates",
    "section": "Gathering information about genes",
    "text": "Gathering information about genes\nNow, we are ready to look at the genes we are interested in relation to our SNP. For this, we will use 3 well-known databases. The goal is to identify which genes are the potential cause of type 1 diabetes. Take your genes to each of the websites and use the information they give you to see which genes can be related to diabetes.\n\nNCBI Gene\nENSEMBL\nGenecards\n\nIt’s important to understand what kind of information these sites provide and their intentions. So, let us do some light exploration.\n\nExercise 25-7\nGoogle “NCBI”. What is it, and who administers it? Do the same with ENSEMBL. What’s its function, and who administers it?\n\n\nExercise 25-8\nOn the NCBI Gene website, the drop-down menu shows “gene”, but other databases on NCBI exist. Get yourself an overview. Do you recognize other databases? Some you don’t know?\n\n\nExercise 25-9\nWhen a gene is found in the “About this gene” section at ENSEMBL, try to press “phenotypes” if there are any. Do you see diabetes for any of the genes?\n\n\nExercise 25-10\nThe Genecards resource is different from the two other databases. Can you list two major differences?\n\n\nExercise 25-11\nBy now, you should have a feeling for the databases and their goals. NCBI and ENSEMBL store the same sequence information, so it is mostly about which site presents data in the most useful way for the task at hand. Which one is your favorite one and why? Which of the genes are related to Type 1 Diabetes? If you can’t find a related gene, go back to “Accessing the UCSC Genome Browser and make initial exploration” and look at your tracks again. You may have missed it.\n\n\nExercise 25-12\nWith the gene you now have chosen, answer the following questions by using the 3 above databases.\n\nHow long is the entire of the gene (in bp or kb)?\nHow many transcripts of the gene are in NCBIs “Transcript table”?\nDoes Ensembl and NCBI show the same number of transcripts?\nIn the graphical representation of a gene, how are exons and introns depicted at ENSEMBL and NCBI?\nAt ENSEMBL, try to click on the UniprotKN identifier. This takes you to a page in the “UniProt” database. Can you retrive the amino acid sequence? - Do that.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>GWAS candidates</span>"
    ]
  },
  {
    "objectID": "chapters/web/gwas_databases/index.html#exploring-tissue-expression",
    "href": "chapters/web/gwas_databases/index.html#exploring-tissue-expression",
    "title": "25  GWAS candidates",
    "section": "Exploring tissue expression",
    "text": "Exploring tissue expression\nIn this step, we are interested in investigating our gene’s expression. Or multiple genes if we have yet to choose a specific gene. Expression analysis will help us understand the genes better. Go to the GTEx Portal (https://www.gtexportal.org/home/) and search for the gene/genes associated with your SNP to see their expression profiles across tissues. Explore tissue-specific gene expression data for the identified genes. In which tissues is the gene(s) expressed, and is there any tissue where its expression is notably higher? You may know “EBV-transformed lymphocytes” as “lymphocytes” cells. They are important to the immune system.\n\nExercise 25-13\nIn which tissues is the gene(s) typically expressed, and are there variations in expression levels across different tissues?\n\n\nExercise 25-14\nDo the expression profiles make sense with the information you got from the other databases? Do you expect to see certain tissues with a high expression? Other with a low? Is it relevant to the disease we are investigating?\n\n\nExercise 25-15\nWhat can you infer about the potential functional relevance of the gene(s) in the context of the disease or trait?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>GWAS candidates</span>"
    ]
  },
  {
    "objectID": "chapters/web/gwas_databases/index.html#hypotheses-and-discussion",
    "href": "chapters/web/gwas_databases/index.html#hypotheses-and-discussion",
    "title": "25  GWAS candidates",
    "section": "Hypotheses and Discussion",
    "text": "Hypotheses and Discussion\nBased on the information gathered from UCSC, various gene databases, and GTEx, propose hypotheses about the potential role of the identified gene(s) in the disease or trait associated with the SNP. Think about the importance of tissue-specific gene expression in understanding disease mechanisms. Are there any other genes or regulatory elements near the SNP that could also be relevant to the disease or trait?\n\nExercise 25-16\nBased on the genomic and expression data, what are your hypotheses regarding the role of the identified gene(s) in the disease or trait?\n\n\nExercise 25-17\nHow might tissue-specific gene expression patterns provide insights into the disease mechanism?\n\n\nExercise 25-18\nAre there potential challenges or limitations in establishing causality between the gene(s) and the disease?\n\n\nExercise 25-19\nSummarize your findings and discuss the significance of investigating candidate disease genes near a GWAS SNP. Reflect on the challenges and limitations of this approach in pinpointing causal genes for complex diseases.\n\n\nExercise 25-20\nWhat did you learn from this exercise about the importance of exploring the genomic context and tissue-specific gene expression in GWAS follow-up?\n\n\nExercise 25-21\nHow might these findings inform future research or therapeutic approaches for the disease or trait?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>GWAS candidates</span>"
    ]
  },
  {
    "objectID": "chapters/project/translation_project/index.html",
    "href": "chapters/project/translation_project/index.html",
    "title": "26  Translating ORFs",
    "section": "",
    "text": "Project files\nThis chapter is about translating DNA into protein. If bacteria can do it, so can you.\nIn this project you will write the code needed to translate an open reading frame (ORF) on a DNA sequence into into the corresponding sequence of amino acids.\nBegin by downloading the files you need for the project:\nhttps://munch-group.org/bioinformatics/supplementary/project_files\nThe file translationproject.py is for your code. The file test_translationproject.py is the script you use to test the functions you write for this project (see Chapter 17).\nIn this project you will need a data structure that pairs each codon to the amino acid it encodes. This is an obvious use of a dictionary and at the top of translationproject.py I have defined such a dictionary you can use. Defining it outside the functions means that it is visible inside all your functions (unless you define another variable called codon_map inside a function). Defining variables globally to your program sometimes make sense if some value can be considered a constant in your program and is never changed.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Translating ORFs</span>"
    ]
  },
  {
    "objectID": "chapters/project/translation_project/index.html#project-files",
    "href": "chapters/project/translation_project/index.html#project-files",
    "title": "26  Translating ORFs",
    "section": "",
    "text": "It is normally very bad programming style to access variables outside functions in this way because it may have all kinds of unexpected side effects across function calls. So make it a rule for yourself that code inside a function should never to access variables outside the function. The reason we define codon_map globally in this project is to help you understand that when Python cannot find a variable inside a function, it looks outside the function to find it. In this project functions will find codon_map in this way. However, as I already said, you should never do this yourself. The chance that you make an unexpected mistake is overwhelming.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Translating ORFs</span>"
    ]
  },
  {
    "objectID": "chapters/project/translation_project/index.html#translating-a-single-codon",
    "href": "chapters/project/translation_project/index.html#translating-a-single-codon",
    "title": "26  Translating ORFs",
    "section": "Translating a single codon",
    "text": "Translating a single codon\nWrite a function, translate_codon that takes one argument:\n\nA string, which is a codon.\n\nThe function should return:\n\nA string of length one (one character). If the string argument is a valid codon then this letter should the be an amino acid letter specified by the codon_map dictionary. Note that stop codons are represented by a star ('*'). If the string argument is not a valid codon, the function must return '?'.\n\nExample usage:\ntranslate_codon('ACG')\nshould return\n'T'\nBefore you start coding you should always outline for yourself intuitively what you need to do to complete the task at hand. In this case want to translate, or map, between a three letter string, codon, and the corresponding one letter string for the amino acid that the codon corresponds to. Notice that the keys in the codon_map dictionary are in upper case, so you must make sure that the keys you use are also in upper case. You can translate codon into an upper case version of itself using the upper() method.\nTry this out first:\ncodon = 'TTG'\namino_acid = codon_map[codon]\nprint(amino_acid)\nNow write the function so it uses the string parameter as a key to look up the corresponding amino acid letter and returns this letter. Before you go on, make a function that does only that.\nBefore you are completely done you need to make your function handle the situation when the argument to the function is not a key in the codon_map dictionary. Use an if-else construct to handle the two cases. The boolean expression must test if the function argument is a key in codon_map. Remember that you can use the in operator to do this.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Translating ORFs</span>"
    ]
  },
  {
    "objectID": "chapters/project/translation_project/index.html#splitting-an-open-reading-frame-into-codons",
    "href": "chapters/project/translation_project/index.html#splitting-an-open-reading-frame-into-codons",
    "title": "26  Translating ORFs",
    "section": "Splitting an open reading frame into codons",
    "text": "Splitting an open reading frame into codons\nTo translate an entire open reading frame into the corresponding amino acid sequence, you need to split the ORF sequence into codons. When we have done that we can translate each codon using the function translate_codon you just wrote.\nWrite a function, split_codons, that takes one argument:\n\nA string, which is an ORF sequence\n\nThe function must return:\n\nA list of strings. Each string must have length 3 and must represent the-non overlapping triplets in the same sequence as they appear in the string given as argument.\n\nExample usage:\nsplit_codons('ATGTATGCCTGA')\nshould return\n['ATG', 'TAT', 'GCC', 'TGA']\nDivide the problem into simpler tasks like above. You need to loop over the sequence to perform operations on it. Start by writing a function that prints each character:\ndef split_codons(orf):\n    for i in range(len(orf)):\n        print(orf[i])\nNow try to figure out how you can modify the function to make it move over the sequence in jumps of three. Look at the documentation for the range function to see how you can make it iterate over numbers with increments of three like this: 0, 3, 6, 9, 12, … . Modify your function so that it now prints every third character.\nWhat you want is obviously not every third character. You want three characters. I.e. every third character and the two characters that come right after. You can use the index in the for loop to get the corresponding codon using slicing. Modify your function so that it prints each codon.\nNow all that remains is to put each codon on a list that you can return from the function. You can define a list before your for-loop so you have a list to add codons to.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Translating ORFs</span>"
    ]
  },
  {
    "objectID": "chapters/project/translation_project/index.html#translating-an-open-reading-frame",
    "href": "chapters/project/translation_project/index.html#translating-an-open-reading-frame",
    "title": "26  Translating ORFs",
    "section": "Translating an open reading frame",
    "text": "Translating an open reading frame\nNow you can use the two functions split_codons and translate_codon to write a function that translates an ORF into a protein sequence.\nWrite a function, translate_orf, that takes one argument:\n\nA string, which is a DNA sequence.\n\nThe function must return\n\nA string, which is the protein sequence translated from the ORF sequence argument.\n\nExample usage:\ntranslate_orf('ATGGAGCTTANCAAATAG')\nshould return\n'MEL?K*'",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Translating ORFs</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/hidden_markov_models.html",
    "href": "chapters/bioinformatics/hidden_markov_models.html",
    "title": "27  Hidden Markov Models",
    "section": "",
    "text": "28 Introduction: Why Do We Need Hidden Markov Models in Biology?\nWhen you look at a DNA sequence like ATGCGTAACGTTTAAGGCCTAG, what do you see? At first glance, it appears to be a random string of four letters. However, this sequence contains a wealth of biological information hidden beneath its surface. It might encode a protein-coding gene, contain regulatory elements that control gene expression, or include structural features that affect how the DNA is packaged in the cell. The challenge facing computational biologists is how to automatically detect and annotate these functional elements from raw sequence data.\nConsider the human genome, which contains over 3 billion base pairs of DNA. Within this vast sequence lie approximately 20,000 protein-coding genes, hundreds of thousands of regulatory elements, and numerous other functional features. Manual annotation of such sequences is impossible, yet accurate identification of these elements is crucial for understanding how genes are regulated, how proteins are made, and how genetic variations contribute to disease.\nHidden Markov Models provide an elegant computational framework for solving these biological annotation problems. They excel at identifying patterns in sequences where the underlying biological function is not directly observable but must be inferred from the sequence content. For instance, when we see the sequence ATGAAATTTGCCTAG, we cannot directly observe whether each nucleotide is part of an exon, intron, or intergenic region. However, we can use the statistical properties of the sequence—such as codon usage patterns, presence of start and stop codons, and splice site signals—to infer the most likely functional annotation.\ngraph LR\n    A[DNA Sequence&lt;br/&gt;ATGAAATTTGCCTAG] --&gt; B[Hidden States&lt;br/&gt;Start-Coding-Coding-Stop]\n    B --&gt; C[Functional Annotation&lt;br/&gt;Gene Structure]\n    \n    style A fill:#e1f5fe\n    style B fill:#fff3e0\n    style C fill:#e8f5e8\n\n\n\n\ngraph LR\n    A[DNA Sequence&lt;br/&gt;ATGAAATTTGCCTAG] --&gt; B[Hidden States&lt;br/&gt;Start-Coding-Coding-Stop]\n    B --&gt; C[Functional Annotation&lt;br/&gt;Gene Structure]\n    \n    style A fill:#e1f5fe\n    style B fill:#fff3e0\n    style C fill:#e8f5e8\nThe power of HMMs lies in their ability to model sequential dependencies while handling uncertainty. Biological sequences exhibit complex patterns where the function of one region influences the likely function of neighboring regions. For example, in eukaryotic genes, exons are typically followed by introns, which are then followed by more exons. Promoter regions contain specific sequence motifs that tend to cluster together upstream of transcription start sites. CpG islands, regions with unusually high frequencies of cytosine-guanine dinucleotides, often mark the beginning of genes and play important roles in gene regulation.\nIn protein analysis, HMMs help us understand the relationship between amino acid sequence and protein structure. The sequence MKLILLFAIVSLVF might not immediately reveal its function, but an HMM trained on transmembrane proteins would recognize this as a likely signal peptide based on its hydrophobic character and typical length. Similarly, the alternating pattern of hydrophobic and hydrophilic regions in a protein sequence can reveal the presence of membrane-spanning α-helices.\nHMMs address three fundamental questions that arise repeatedly in computational biology:\nThese questions correspond to different biological applications: finding the most likely annotation of a sequence, evaluating how well a sequence fits a particular model, and determining the uncertainty in our predictions.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Hidden Markov Models</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/hidden_markov_models.html#gene-finding-in-eukaryotic-genomes",
    "href": "chapters/bioinformatics/hidden_markov_models.html#gene-finding-in-eukaryotic-genomes",
    "title": "27  Hidden Markov Models",
    "section": "35.1 Gene Finding in Eukaryotic Genomes",
    "text": "35.1 Gene Finding in Eukaryotic Genomes\nGene finding in eukaryotic genomes represents one of the most sophisticated applications of HMMs in computational biology. Unlike bacterial genes, which consist of simple continuous coding sequences, eukaryotic genes have complex structures with multiple exons separated by introns, alternative splicing patterns, and regulatory elements.\n\nstateDiagram-v2\n    [*] --&gt; Intergenic\n    Intergenic --&gt; FiveUTR\n    FiveUTR --&gt; FirstExon\n    FirstExon --&gt; Intron\n    Intron --&gt; InternalExon\n    InternalExon --&gt; Intron\n    InternalExon --&gt; LastExon\n    LastExon --&gt; ThreeUTR\n    ThreeUTR --&gt; Intergenic\n    Intergenic --&gt; [*]\n    \n    note right of FirstExon\n        Contains start codon\n        Maintains reading frame\n        Codon usage bias\n    end note\n    \n    note right of Intron\n        GT...AG splice sites\n        Branch point sequence\n        Variable length\n    end note\n    \n    note right of InternalExon\n        Maintains reading frame\n        No start/stop codons\n        Triplet periodicity\n    end note\n\n\n\n\nstateDiagram-v2\n    [*] --&gt; Intergenic\n    Intergenic --&gt; FiveUTR\n    FiveUTR --&gt; FirstExon\n    FirstExon --&gt; Intron\n    Intron --&gt; InternalExon\n    InternalExon --&gt; Intron\n    InternalExon --&gt; LastExon\n    LastExon --&gt; ThreeUTR\n    ThreeUTR --&gt; Intergenic\n    Intergenic --&gt; [*]\n    \n    note right of FirstExon\n        Contains start codon\n        Maintains reading frame\n        Codon usage bias\n    end note\n    \n    note right of Intron\n        GT...AG splice sites\n        Branch point sequence\n        Variable length\n    end note\n    \n    note right of InternalExon\n        Maintains reading frame\n        No start/stop codons\n        Triplet periodicity\n    end note\n\n\n\n\n\n\nA comprehensive gene finding HMM must model all these features while maintaining computational efficiency. A basic eukaryotic gene finding model includes states representing different functional regions: 5’ untranslated regions (5’ UTR), first exons, introns, internal exons, last exons, and 3’ untranslated regions (3’ UTR). The emission probabilities reflect the different sequence characteristics of these regions. Exon states avoid in-frame stop codons and exhibit the triplet periodicity characteristic of protein-coding sequences, while intron states have more uniform nucleotide composition and may contain repetitive elements.\nThe transition probabilities encode biological knowledge about gene structure. The probability of transitioning from “first exon” to “intron” is high near GT dinucleotides (donor splice sites), while the probability of transitioning from “intron” to “internal exon” is high near AG dinucleotides (acceptor splice sites). These transition probabilities can be made position-specific to model the sequence conservation around splice sites more accurately.\nFor example, the donor splice site model might include a series of states \\(D_1, D_2, \\ldots, D_9\\) that model the conserved sequence around the splice site:\n\n\\(e_{D_1}(\\text{G}) \\approx 0.95\\), modeling the highly conserved G in the GT dinucleotide\n\\(e_{D_2}(\\text{T}) \\approx 0.95\\), modeling the highly conserved T in the GT dinucleotide\n\n\\(e_{D_3}\\) through \\(e_{D_9}\\) model the less conserved but still biased positions\n\nThis approach allows the HMM to recognize splice sites based on both the canonical GT-AG signals and the more subtle sequence preferences in the surrounding regions.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Hidden Markov Models</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/hidden_markov_models.html#cpg-island-detection",
    "href": "chapters/bioinformatics/hidden_markov_models.html#cpg-island-detection",
    "title": "27  Hidden Markov Models",
    "section": "35.2 CpG Island Detection",
    "text": "35.2 CpG Island Detection\nCpG island detection provides another excellent example of sophisticated HMM design. CpG islands are regions of genomic DNA with elevated frequencies of cytosine-guanine dinucleotides that often mark gene promoters and regulatory regions. The challenge is that CpG islands are not uniformly CpG-rich but contain regions of varying CpG density, and their boundaries are often gradual rather than sharp.\n\nstateDiagram-v2\n    [*] --&gt; Background\n    Background --&gt; LowCpG\n    LowCpG --&gt; MediumCpG\n    MediumCpG --&gt; HighCpG\n    HighCpG --&gt; MediumCpG\n    MediumCpG --&gt; LowCpG\n    LowCpG --&gt; Background\n    Background --&gt; [*]\n    \n    note right of Background\n        P(CG) = 0.01\n        Typical genomic frequency\n    end note\n    \n    note right of LowCpG\n        P(CG) = 0.04\n        CpG island periphery\n    end note\n    \n    note right of MediumCpG\n        P(CG) = 0.08\n        Intermediate regions\n    end note\n    \n    note right of HighCpG\n        P(CG) = 0.15\n        CpG island core\n    end note\n\n\n\n\nstateDiagram-v2\n    [*] --&gt; Background\n    Background --&gt; LowCpG\n    LowCpG --&gt; MediumCpG\n    MediumCpG --&gt; HighCpG\n    HighCpG --&gt; MediumCpG\n    MediumCpG --&gt; LowCpG\n    LowCpG --&gt; Background\n    Background --&gt; [*]\n    \n    note right of Background\n        P(CG) = 0.01\n        Typical genomic frequency\n    end note\n    \n    note right of LowCpG\n        P(CG) = 0.04\n        CpG island periphery\n    end note\n    \n    note right of MediumCpG\n        P(CG) = 0.08\n        Intermediate regions\n    end note\n    \n    note right of HighCpG\n        P(CG) = 0.15\n        CpG island core\n    end note\n\n\n\n\n\n\nA sophisticated model might include multiple CpG island states representing different levels of CpG enrichment:\n\nHigh CpG state: \\(P(\\text{CG}) = 0.15\\), \\(P(\\text{other dinucleotides}) = 0.85/15\\)\nMedium CpG state: \\(P(\\text{CG}) = 0.08\\), \\(P(\\text{other dinucleotides}) = 0.92/15\\)\n\nLow CpG state: \\(P(\\text{CG}) = 0.04\\), \\(P(\\text{other dinucleotides}) = 0.96/15\\)\nBackground state: \\(P(\\text{CG}) = 0.01\\), \\(P(\\text{other dinucleotides}) = 0.99/15\\)\n\nThe transition structure allows gradual transitions between these states, modeling the fact that CpG islands often have cores of high CpG density surrounded by regions of intermediate CpG density.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Hidden Markov Models</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/hidden_markov_models.html#transmembrane-protein-topology-prediction",
    "href": "chapters/bioinformatics/hidden_markov_models.html#transmembrane-protein-topology-prediction",
    "title": "27  Hidden Markov Models",
    "section": "35.3 Transmembrane Protein Topology Prediction",
    "text": "35.3 Transmembrane Protein Topology Prediction\nTransmembrane protein topology prediction illustrates how biophysical knowledge can be incorporated into HMM design. Transmembrane proteins contain hydrophobic α-helical segments that span cell membranes, separated by hydrophilic loops in the aqueous environment.\n\nstateDiagram-v2\n    [*] --&gt; OutsideLoop\n    OutsideLoop --&gt; TMHelix\n    TMHelix --&gt; InsideLoop\n    InsideLoop --&gt; TMHelix\n    TMHelix --&gt; OutsideLoop\n    OutsideLoop --&gt; [*]\n    InsideLoop --&gt; [*]\n    \n    note right of OutsideLoop\n        Hydrophilic residues\n        P(K,R,D,E) high\n        Negative charge bias\n    end note\n    \n    note right of TMHelix\n        Hydrophobic residues\n        P(L,I,V,F,A) high\n        Length: 20-25 residues\n    end note\n    \n    note right of InsideLoop\n        Positive-inside rule\n        P(K,R) &gt; P(D,E)\n        Cytoplasmic side\n    end note\n\n\n\n\nstateDiagram-v2\n    [*] --&gt; OutsideLoop\n    OutsideLoop --&gt; TMHelix\n    TMHelix --&gt; InsideLoop\n    InsideLoop --&gt; TMHelix\n    TMHelix --&gt; OutsideLoop\n    OutsideLoop --&gt; [*]\n    InsideLoop --&gt; [*]\n    \n    note right of OutsideLoop\n        Hydrophilic residues\n        P(K,R,D,E) high\n        Negative charge bias\n    end note\n    \n    note right of TMHelix\n        Hydrophobic residues\n        P(L,I,V,F,A) high\n        Length: 20-25 residues\n    end note\n    \n    note right of InsideLoop\n        Positive-inside rule\n        P(K,R) &gt; P(D,E)\n        Cytoplasmic side\n    end note\n\n\n\n\n\n\nThe design of an effective transmembrane protein HMM requires modeling several biological constraints. First, the hydrophobic nature of membrane-spanning regions must be captured through appropriate emission probabilities. Transmembrane helix states have high emission probabilities for hydrophobic amino acids (L, I, V, F, A) and low probabilities for charged amino acids (K, R, D, E).\nSecond, the length constraints of transmembrane helices must be modeled. Membrane-spanning α-helices typically contain 20-25 amino acids, corresponding to the thickness of the lipid bilayer. This can be modeled using a series of transmembrane states or explicit length distributions.\nThird, the “positive-inside rule” must be incorporated. This rule states that the cytoplasmic side of transmembrane proteins contains more positively charged amino acids than the extracellular side. This can be modeled by having different inside and outside loop states with different emission probabilities for charged amino acids:\n\nInside loop: \\(P(\\text{K}) = 0.08\\), \\(P(\\text{R}) = 0.06\\), \\(P(\\text{D}) = 0.04\\), \\(P(\\text{E}) = 0.05\\)\nOutside loop: \\(P(\\text{K}) = 0.04\\), \\(P(\\text{R}) = 0.03\\), \\(P(\\text{D}) = 0.08\\), \\(P(\\text{E}) = 0.09\\)",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Hidden Markov Models</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/hidden_markov_models.html#signal-peptide-prediction",
    "href": "chapters/bioinformatics/hidden_markov_models.html#signal-peptide-prediction",
    "title": "27  Hidden Markov Models",
    "section": "35.4 Signal Peptide Prediction",
    "text": "35.4 Signal Peptide Prediction\nSignal peptide prediction represents another important application where biological knowledge guides HMM design. Signal peptides are short amino acid sequences that direct newly synthesized proteins to specific cellular locations. They typically consist of three regions: a positively charged N-terminal region, a hydrophobic core region, and a polar C-terminal region containing the cleavage site.\n\nstateDiagram-v2\n    [*] --&gt; NTerminal\n    NTerminal --&gt; HydrophobicCore\n    HydrophobicCore --&gt; CTerminal\n    CTerminal --&gt; CleavageSite\n    CleavageSite --&gt; [*]\n    \n    note right of NTerminal\n        Positively charged\n        P(K,R) high\n        Length: 1-5 residues\n    end note\n    \n    note right of HydrophobicCore\n        Hydrophobic residues\n        P(L,I,V,F,A) high\n        Length: 7-15 residues\n    end note\n    \n    note right of CTerminal\n        Polar residues\n        Small, uncharged\n        Length: 3-7 residues\n    end note\n    \n    note right of CleavageSite\n        Specific cleavage rules\n        Small residues at -1,-3\n    end note\n\n\n\n\nstateDiagram-v2\n    [*] --&gt; NTerminal\n    NTerminal --&gt; HydrophobicCore\n    HydrophobicCore --&gt; CTerminal\n    CTerminal --&gt; CleavageSite\n    CleavageSite --&gt; [*]\n    \n    note right of NTerminal\n        Positively charged\n        P(K,R) high\n        Length: 1-5 residues\n    end note\n    \n    note right of HydrophobicCore\n        Hydrophobic residues\n        P(L,I,V,F,A) high\n        Length: 7-15 residues\n    end note\n    \n    note right of CTerminal\n        Polar residues\n        Small, uncharged\n        Length: 3-7 residues\n    end note\n    \n    note right of CleavageSite\n        Specific cleavage rules\n        Small residues at -1,-3\n    end note\n\n\n\n\n\n\nAn HMM for signal peptide prediction might include states for each of these regions with appropriate emission probabilities and transition structures that model the sequential organization and typical length ranges of each region.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Hidden Markov Models</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/hidden_markov_models.html#profile-hmms-for-protein-family-analysis",
    "href": "chapters/bioinformatics/hidden_markov_models.html#profile-hmms-for-protein-family-analysis",
    "title": "27  Hidden Markov Models",
    "section": "36.1 Profile HMMs for Protein Family Analysis",
    "text": "36.1 Profile HMMs for Protein Family Analysis\nProfile HMMs represent one of the most successful extensions of the basic HMM framework. They adapt the basic structure to model multiple sequence alignments, enabling sensitive detection of remote homology and accurate classification of protein sequences into functional families.\n\ngraph TD\n    subgraph \"Profile HMM Structure\"\n        M1[Match₁] --&gt; M2[Match₂]\n        M1 --&gt; I1[Insert₁]\n        M1 --&gt; D2[Delete₂]\n        I1 --&gt; M2\n        I1 --&gt; I1\n        I1 --&gt; D2\n        D2 --&gt; M2\n        D2 --&gt; D2\n        \n        M2 --&gt; M3[Match₃]\n        M2 --&gt; I2[Insert₂]\n        M2 --&gt; D3[Delete₃]\n    end\n    \n    note right of M1\n        Emit according to\n        alignment column\n        conservation\n    end note\n    \n    note right of I1\n        Emit according to\n        background\n        frequencies\n    end note\n    \n    note right of D2\n        Silent state\n        No emission\n    end note\n    \n    style M1 fill:#e8f5e8\n    style I1 fill:#fff3e0\n    style D2 fill:#ffebee\n\n\n\n\ngraph TD\n    subgraph \"Profile HMM Structure\"\n        M1[Match₁] --&gt; M2[Match₂]\n        M1 --&gt; I1[Insert₁]\n        M1 --&gt; D2[Delete₂]\n        I1 --&gt; M2\n        I1 --&gt; I1\n        I1 --&gt; D2\n        D2 --&gt; M2\n        D2 --&gt; D2\n        \n        M2 --&gt; M3[Match₃]\n        M2 --&gt; I2[Insert₂]\n        M2 --&gt; D3[Delete₃]\n    end\n    \n    note right of M1\n        Emit according to\n        alignment column\n        conservation\n    end note\n    \n    note right of I1\n        Emit according to\n        background\n        frequencies\n    end note\n    \n    note right of D2\n        Silent state\n        No emission\n    end note\n    \n    style M1 fill:#e8f5e8\n    style I1 fill:#fff3e0\n    style D2 fill:#ffebee\n\n\n\n\n\n\nIn a profile HMM, we have three types of states at each alignment column that model different evolutionary events. Match states (M) emit amino acids according to the conservation pattern in that alignment column. For example, if an alignment column contains mostly hydrophobic amino acids, the corresponding match state would have high emission probabilities for L, I, V, F, and A. Insertion states (I) emit amino acids according to background frequencies, modeling insertions relative to the consensus sequence. Deletion states (D) emit no amino acids (silent states), modeling deletions relative to the consensus sequence.\nThe transition probabilities between these states model the frequency of insertions and deletions in the protein family. For alignment column \\(i\\), typical transitions include:\n\n\\(M_{i-1} \\to M_i\\): normal progression through the alignment\n\\(M_{i-1} \\to I_{i-1}\\): insertion after match state\n\n\\(M_{i-1} \\to D_i\\): deletion of alignment column \\(i\\)\n\\(I_{i-1} \\to M_i\\): end of insertion, return to consensus\n\\(I_{i-1} \\to I_{i-1}\\): extension of insertion\n\\(D_{i-1} \\to D_i\\): extension of deletion\n\nThis structure allows profile HMMs to identify sequences that match the overall pattern of a protein family even when they contain insertions, deletions, or substitutions relative to the consensus sequence.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Hidden Markov Models</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/hidden_markov_models.html#pair-hmms-for-sequence-alignment",
    "href": "chapters/bioinformatics/hidden_markov_models.html#pair-hmms-for-sequence-alignment",
    "title": "27  Hidden Markov Models",
    "section": "36.2 Pair HMMs for Sequence Alignment",
    "text": "36.2 Pair HMMs for Sequence Alignment\nPair HMMs extend the framework to model the evolutionary relationship between two sequences simultaneously, finding applications in sequence alignment and comparative genomics. This is particularly useful for identifying conserved regions between species, which likely represent functionally important elements.\n\nstateDiagram-v2\n    [*] --&gt; Match\n    Match --&gt; Match\n    Match --&gt; InsertX\n    Match --&gt; InsertY\n    InsertX --&gt; Match\n    InsertX --&gt; InsertX\n    InsertY --&gt; Match\n    InsertY --&gt; InsertY\n    Match --&gt; [*]\n    InsertX --&gt; [*]\n    InsertY --&gt; [*]\n    \n    note right of Match\n        Emit from both sequences\n        Models aligned positions\n        Substitution patterns\n    end note\n    \n    note right of InsertX\n        Emit from sequence X only\n        Gap in sequence Y\n        Insertion events\n    end note\n    \n    note right of InsertY\n        Emit from sequence Y only\n        Gap in sequence X\n        Deletion events\n    end note\n\n\n\n\nstateDiagram-v2\n    [*] --&gt; Match\n    Match --&gt; Match\n    Match --&gt; InsertX\n    Match --&gt; InsertY\n    InsertX --&gt; Match\n    InsertX --&gt; InsertX\n    InsertY --&gt; Match\n    InsertY --&gt; InsertY\n    Match --&gt; [*]\n    InsertX --&gt; [*]\n    InsertY --&gt; [*]\n    \n    note right of Match\n        Emit from both sequences\n        Models aligned positions\n        Substitution patterns\n    end note\n    \n    note right of InsertX\n        Emit from sequence X only\n        Gap in sequence Y\n        Insertion events\n    end note\n    \n    note right of InsertY\n        Emit from sequence Y only\n        Gap in sequence X\n        Deletion events\n    end note\n\n\n\n\n\n\nThe states in a pair HMM typically represent different types of evolutionary events:\n\nMatch state: emits aligned amino acids or nucleotides from both sequences\nInsertion in sequence 1: emits from sequence 1 only (gap in sequence 2)\nInsertion in sequence 2: emits from sequence 2 only (gap in sequence 1)\n\nThe emission probabilities for the match state capture the substitution patterns between the two sequences:\n\\[\ne_M(a,b) = P(\\text{emitting amino acid } a \\text{ from sequence 1 and amino acid } b \\text{ from sequence 2})\n\\tag{36.1}\\]\nFor closely related sequences, this probability would be high when \\(a = b\\) (identical amino acids) and lower for substitutions. For distantly related sequences, the emission probabilities would reflect the amino acid substitution matrices derived from evolutionary studies.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Hidden Markov Models</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/hidden_markov_models.html#hidden-semi-markov-models",
    "href": "chapters/bioinformatics/hidden_markov_models.html#hidden-semi-markov-models",
    "title": "27  Hidden Markov Models",
    "section": "36.3 Hidden Semi-Markov Models",
    "text": "36.3 Hidden Semi-Markov Models\nHidden semi-Markov models (HSMMs) relax the geometric length distribution assumption of standard HMMs by explicitly modeling state durations. This extension is particularly valuable for biological applications where feature lengths follow non-geometric distributions, such as protein domains or gene exons.\nInstead of transition probabilities between individual positions, HSMMs use duration probabilities \\(P(d)\\) for spending exactly \\(d\\) time steps in a state, and transition probabilities between different state types. The forward algorithm becomes:\n\\[\nf_l(i) = \\sum_d \\sum_k f_k(i-d) \\times a_{kl} \\times P(d) \\times \\prod_{j=i-d+1}^{i} e_l(x_j)\n\\tag{36.2}\\]\nThis allows modeling of complex length distributions while maintaining computational tractability. For example, exon lengths in human genes could be modeled using empirical length distributions derived from known genes, rather than the geometric distributions implicit in standard HMMs.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Hidden Markov Models</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/hidden_markov_models.html#phylogenetic-hmms-for-comparative-genomics",
    "href": "chapters/bioinformatics/hidden_markov_models.html#phylogenetic-hmms-for-comparative-genomics",
    "title": "27  Hidden Markov Models",
    "section": "36.4 Phylogenetic HMMs for Comparative Genomics",
    "text": "36.4 Phylogenetic HMMs for Comparative Genomics\nModern comparative genomics applications use sophisticated HMM variants to analyze multiple genome alignments simultaneously. These phylogenetic HMMs model the evolution of functional elements across multiple species, allowing identification of conserved regulatory elements, detection of positive selection, and reconstruction of ancestral genome organization.\n\ngraph TB\n    subgraph \"Evolutionary States\"\n        C1[Coding under purifying selection]\n        U1[UTR under moderate constraint]\n        R1[Regulatory under strong constraint]\n        N1[Neutral sequences]\n        P1[Positive selection]\n    end\n    \n    subgraph \"Species Tree\"\n        S1[Human] \n        S2[Chimp]\n        S3[Mouse]\n        S4[Rat]\n    end\n    \n    C1 --&gt; S1\n    C1 --&gt; S2\n    C1 --&gt; S3\n    C1 --&gt; S4\n    \n    style C1 fill:#e8f5e8\n    style R1 fill:#e3f2fd\n    style N1 fill:#fff3e0\n\n\n\n\ngraph TB\n    subgraph \"Evolutionary States\"\n        C1[Coding under purifying selection]\n        U1[UTR under moderate constraint]\n        R1[Regulatory under strong constraint]\n        N1[Neutral sequences]\n        P1[Positive selection]\n    end\n    \n    subgraph \"Species Tree\"\n        S1[Human] \n        S2[Chimp]\n        S3[Mouse]\n        S4[Rat]\n    end\n    \n    C1 --&gt; S1\n    C1 --&gt; S2\n    C1 --&gt; S3\n    C1 --&gt; S4\n    \n    style C1 fill:#e8f5e8\n    style R1 fill:#e3f2fd\n    style N1 fill:#fff3e0\n\n\n\n\n\n\nFor example, a phylogenetic HMM for analyzing mammalian genome alignments might include states representing:\n\nCoding sequences under purifying selection\nUntranslated regions under moderate constraint\n\nRegulatory elements under strong constraint\nNeutral sequences under no constraint\nRegions under positive selection\n\nThe emission probabilities at each state model the expected substitution patterns under different evolutionary pressures, while the transition probabilities model the spatial organization of functional elements along chromosomes.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Hidden Markov Models</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/sequence_annnotation.html",
    "href": "chapters/bioinformatics/sequence_annnotation.html",
    "title": "28  Sequence annotation",
    "section": "",
    "text": "What it is",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Sequence annotation</span>"
    ]
  },
  {
    "objectID": "chapters/web/new_hmm_exercise/index.html",
    "href": "chapters/web/new_hmm_exercise/index.html",
    "title": "29  Membrane proteins",
    "section": "",
    "text": "Using TMHMM…",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Membrane proteins</span>"
    ]
  },
  {
    "objectID": "chapters/project/orf_project/index.html",
    "href": "chapters/project/orf_project/index.html",
    "title": "30  Finding genes",
    "section": "",
    "text": "Finding Open Reading Frames\nThis chapter is a programming project where you will find open reading frames in the genome of a particularly virulent strain of E. coli.\nIn this project, you will analyze DNA to identify the open reading frames (ORFs) and the proteins they encode.\nDownload the files you need for this project:\nhttps://munch-group.org/bioinformatics/supplementary/project_files\nYou also need to download the two project files:\nPut all three files in a folder dedicated to this project. On most computers you can right-click on the link and choose “Save file as…” or “Download linked file”.\nFour your convenience, the file orfproject.py already contains three global constants (variables that must never be changed by the code). One is a dictionary codon_map, which maps codons to letters that represent amino acids. The other two are a string, start_codon, and a list, stop_codons. You can refer to these three variables in your code, but obviously, never change them.\nThe project has three parts.\nStart by reading through the exercise before you do anything else. That way you have a good overview of the tasks ahead. Here is a mind map of how we split the larger problem into smaller bits and how they fit together:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Finding genes</span>"
    ]
  },
  {
    "objectID": "chapters/project/orf_project/index.html#finding-open-reading-frames",
    "href": "chapters/project/orf_project/index.html#finding-open-reading-frames",
    "title": "30  Finding genes",
    "section": "",
    "text": "Find the start positions of ORFs in a DNA sequence\nThe first task is to write a function that finds all the possible positions where an ORF can begin.\nWrite a function, find_start_positions, which takes one argument:\n\nA string, which is a DNA sequence.\n\nThe function must return:\n\nA list of integers, which represent the indexes of the first base in start codons in the DNA sequence argument.\n\nExample usage:\nfind_start_positions('TATGCATGATG')\nshould return\n[1, 5, 8]\nYour function should contain a for-loop that iterates over all possible positions in a DNA string where a codon can begin. Not surprisingly, these are all the positions except for the last two. So start out with this:\ndef find_start_positions(seq):\n    for i in range(len(seq) - 2):\n        print(i)\nNow, instead of just printing i, try and make it print the three bases following i using the slicing technique:\ntriplet = seq[i:i+3]\nI.e. if your sequence is 'TATGCATGATG' it should first print 'TAT' then 'ATG' then 'TGC' and so on.\nWhen you have this working you should change the code so that triplets are only printed if they are start codons. You can use an if-statement that tests if each triplet is equal to start_codon.\nThen try and make your function print i only when i is the first base of a start codon.\nFinally, modify the function so all the relevant values of i are collected in a list using the same technique as in the split_codons(orf) function, and then return this list from the function.\n\n\nFinding the next occurrence of some codon in an ORF\nNow that you can find where the ORFs begin in our sequence you must also be able to identify where each of these end. As you know, an ORF ends at any of three different stop codons in the same reading frame as the start codon. So, starting at the start codon of the ORF, we need to be able to find the next occurrence of some specific codon. I.e. you should look at all codons after the start codon and find the first occurrence of some specified codon. If the function does not find that codon in the string it should return None.\nWrite a function, find_next_codon, that takes three arguments:\n\nA string, which is the DNA sequence.\nAn integer, which is the index in the sequence where the ORF starts.\nA string, which is the codon to find the next occurrence of.\n\nThe function must return:\n\nAn integer, which is the index of the first base in the next in-frame occurrence of the codon. If the function does not find that codon in the string it should return None.\n\nExample usage:\nfind_next_codon('AAAAATTTAATTTAA', 1, 'TTT')\nshould return\n10\nYour function should contain a for-loop that iterates over all the relevant starts of codons. Remember that no valid codon can start at the last two positions in the sequence. E.g. if the second argument is 7 and the length of the sequence is 20 then the relevant indexes are 7, 10, 13, 16.\nStart by writing a function just with a for-loop that lets you print these indexes produced by range. Figure out how to make the range function iterate over the appropriate numbers.\ndef find_next_codon(seq, start, codon):\n    for idx in range( ?? ):\n        print(idx)\nWhen you have that working, use the slicing technique to instead print the codons that start at each index.\nFinally, add an if-statement that tests if each codon is equal to codon. When this is true, the function should return the value of idx.\n\n\nFinding the first stop codon in an ORF\nNow that you can find the next occurrence of any codon, you are well set up to write a function that finds the index for the beginning of the next in-frame stop codon in an ORF.\nWrite a function, find_next_stop_codon, that takes two arguments:\n\nA string, which is the DNA sequence.\nAn integer, which is the index in the sequence where the ORF starts.\n\nThe function must return:\n\nAn integer, which is the index of the first base in the next in-frame stop codon. If there is no in-frame stop codon in the sequence the function should return None.\n\nExample usage:\nfind_next_stop_codon('AAAAATAGATGAAAA', 2)\nshould return\n5\nHere is some inspiration:\n\nYou should define a list to hold the indexes for the in-frame stop codons we find.\nThen we loop over the three possible stop codons to find the next in-frame occurrence of each one from the start index. You can use find_next_codon for this. Remember that it returns None if it does not find any. If it does find a position you can add it to your list.\nAt the end, you should test if you have any indexes in your list.\nIf you do, you should return the smallest index in the list. I.e the ones closest to the start codon.\nIf you did not find any stop codons the function must return None to indicate this.\n\n\n\nFinding ORFs\nNow you can write a function that uses find_start_positions and find_next_stop_codon to extract the start and end indexes of each ORF in a genomic sequence.\nWrite a function, find_orfs, that takes one argument:\n\nA string, which is a DNA sequence.\n\nThe function should return:\n\nA list, which contains lists with two integers. The list returned must contain a list for each ORF in the sequence argument. These lists each contain two integers. The first integer represents the start of the ORF, the second represents the end. The function should handle both uppercase and lowercase sequences.\n\nExample usage:\nfind_orfs(\"AAAATGGGGTAGAATGAAATGA\")\nshould return\n[[3, 9], [13, 19]]\nStart by using find_start_positions to get a list of all the start positions in sequence:\ndef find_orfs(seq):\n    start_positions = find_start_positions(seq)\nWhen you have that working, add a for-loop that iterates over the start positions. Inside the for-loop, you can then get the next in-frame stop codon for each start position by calling find_next_stop_codon. Try to print the start and end indexes you find to make sure the code does what you think.\nFinally, you need to add a [start, stop] list for each ORF to the big list that the function returns. To append a list to a list you do write something like this:\norf_coordinate_list.append([start, stop])\nTest your function. Chances are that some of the end positions you get are None. This is because some of the start codons were not followed by an in-frame stop codon. Add an if-statement to your function that controls that only start-stop pairs with a valid stop coordinate are added to the list of results.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Finding genes</span>"
    ]
  },
  {
    "objectID": "chapters/project/orf_project/index.html#translation-of-open-reading-frames",
    "href": "chapters/project/orf_project/index.html#translation-of-open-reading-frames",
    "title": "30  Finding genes",
    "section": "Translation of open reading frames",
    "text": "Translation of open reading frames\nWe need to translate the reading frames we find into the proteins they may encode. So why not use the code you already wrote in the programming project where you translated open frames? Copy the content of translationproject.py into orfproject.py. Now you can use the function translate_orf to translate your ORFs.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Finding genes</span>"
    ]
  },
  {
    "objectID": "chapters/project/orf_project/index.html#put-everything-together",
    "href": "chapters/project/orf_project/index.html#put-everything-together",
    "title": "30  Finding genes",
    "section": "Put everything together",
    "text": "Put everything together\n\nRead in genomic sequences\nThe file e_coli_O157_H157_str_Sakai.fasta contains the genome that we want to analyze to find open reading frames. This is an especially nasty strain of Escherichia coli O157:H7 isolated after a massive outbreak of infection in school children in Sakai City, Japan, associated with consumption of white radish sprouts.\nYou can use the function below to read the genome sequence into a string.\ndef read_genome(file_name):\n    f = open(file_name, 'r')\n    lines = f.readlines()\n    header = lines.pop(0)\n    substrings = []\n    for line in lines:\n        substrings.append(line.strip())\n    genome = ''.join(substrings)\n    f.close()\n    return genome\nNow for the grand finale: Using read_genome, find_orfs and translate_orf you can write a function that finds all protein sequences produced by open reading frames in the genome.\nWrite a function, find_candidate_proteins, that takes one argument:\n\nA string, which is a genome DNA sequence.\n\nThe function must return\n\nA list of strings, which each represent a possible protein sequence.\n\nNote that this is a full genome so finding all possible proteins will take a while (~5 min.). You can start by working on the first 1000 bases:\nExample usage:\ngenome = read_genome('e_coli_O157_H157_str_Sakai.fasta')\nfirst_1000_bases = genome[:1000]\nfind_candidate_proteins(first_1000_bases)\nshould return\n['MSLCGLKKESLTAASELVTCRE*', 'MKRISTTITTTITTTITITITTGNGAG*',\n 'MQNVFCGLPIFWKAMPGRGRWPPSSLPPPKSPTTWWR*', 'MPGRGRWPPSSLPPPKSPTTWWR*',\n 'MLYPISAMPNVFLPNF*', 'MPNVFLPNF*', 'MSCMALVC*', 'MALVC*']\nThe function should call find_orfs to get the list of start-end pairs. For each index pair, you must then slice the ORF out of the sequence (remember that the end index represents the first base in the stop codon), translate the ORF to protein, and add it to a list of proteins that the function can return.\n\n\n\n\n\n\nHint\n\n\n\n\n\nTo check your result note that all returned sequences should start with a start codon 'M', end with a stop codon '*' and contain no stop codons in the middle.\n\n\n\n\n\nOn your own\nThis is where this project ends, but you can continue if you like. Given a long list of candidate proteins of all sizes, what would you do to narrow down your prediction to a smaller set of very likely genes? If you have some ideas, then try them out.\n\nMaybe you can rank them by length? What is the expected minimum length of proteins?\nMaybe you can look for a Shine-Delgarno motif upstream of the start codon? You know how to do that from the lectures.\nYou can also try to BLAST them against the proteins in Genbank. The true ones should have some homologs in other species.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Finding genes</span>"
    ]
  },
  {
    "objectID": "chapters/web/neural_networks/index.html",
    "href": "chapters/web/neural_networks/index.html",
    "title": "32  Neural networks",
    "section": "",
    "text": "Machine learning comes in many forms. Whether you want to call them artificial intelligence or just models is a matter of taste. Hidden Markov models are one class of models, and neural networks are another.\nAt this point, you already know the basics of neural networks, especially feed-forward networks, and how we can train such a network of sigmoid neurons to work as a classifier. In this exercise, you will play with neural networks and explore how features of input data and hidden layers affect the properties and the neural network’s performance.\nFollow the above link into the Neural Network playground. Start by reading the text below the dashboard and look over the dashboard’s components. At the top, there is a panel with dropdown menus controlling the properties of the network and selecting the type of problem to solve. We will start with an activation type of “TanH” (similar to sigmoid activation) and a problem type of “Classification” (already set if you have not used the site before). You can pick the data set to work on in the “Data” column on the left side. Select the top left one (blue dots surrounded by orange ones), and leave the other controls as they are.\nYou see the network layout in the middle, with the input layer on the left and the output layer on the right. The data is a set of colored points in a two-dimensional coordinate system. The points are split into a training set and a test set. In each epoch of the training, the model parameters are changed, and the resulting change in performance is evaluated by running the model on the test data. The points included in the training data are the ones you see on the right over the output. There is a tick box in the output panel that lets you see the test data too. If you drag the “Data” slider “Ratio of training to test data” to the left, you can see how the training data set shrinks as you include more data in your test set. Leave it at 50%.\nThe neurons in the input layer fire if the data shows a particular feature. In the case of feature X1, the neuron produces output when the data exhibits a gradient of orange points on the left and blue points on the right. Other features trigger the other input neurons, as their thumbnails show.\n\nExercise 32-1\nTrim the network down to a single hidden layer (-1 layer) with just two neurons, and make sure only the X1 feature is selected in the input layer. In the output on the right, the color of each point shows which class it belongs to. The background color represents the classification made by your neural network.\nPress play to start the training. Pay close attention to how the weights and outputs change from their initial states. Run the network for 100-200 epochs, then stop and inspect it.\n\nThe two neurons in the hidden layer should produce output for different features - try hovering over them and think about how the single feature creates these activations.\nDo the weights or the biases differ the most? You can hover over the lines/points or look at their color.\nWhat is the Test Loss noted under output?\nDo you think adding more features, neurons, or layers will improve the classification?\n\n\n\nExercise 32-2\nWe may need more features. Try adding the input node capturing the X2 feature and run this model for 200 epochs.\n\nIs the Test Loss better now (Test Loss is the loss function of the test data).\nThe Output prediction is quite different now; look at the neurons and consider how adding the X2 Feature changed the other neuron outputs.\nIt seems to have quite a different fit - will adding more neurons make it even better?\n\n\n\nExercise 32-3\nTwo neurons may not allow for enough flexibility. Add more neurons to the hidden layer and run the model for 200 epochs.\n\nHow many neurons must you add to gain Test Loss under &gt; 0.005?\n\n\n\nExercise 32-4\nNow lets see how good you are:\n\nChallenge: How low can you go in total Neurons and Features and still produce a good fit (Test Loss under 0.005)? Consider which features work well with the data especially.\nChallenge: Try creating a model that performs poorly despite having at least three features and four neurons (poorly being Test Loss over 0.1).\n\n\n\nExercise 32-5\nThe ring-shaped classification problem is relatively easy (for neural networks). Now, it is time to challenge it with a more complex problem. Pick the spiral pattern (bottom left option under Data). This pattern is much more complicated, so a Test Loss below 0.05 (rather than 0.005) is good. Using more Features and Neurons will also take longer for each epoch, so you need to be more patient. It also requires more Epochs to train, so wait for 500-1000 Epochs before deciding how well the network performs. While you wait, you can watch the Test Loss graph in the output panel.\n\nTry fitting a model using all features, and decide how many neurons and layers to use. How many neurons do you need to do a good fit? Hint: You may need more than one hidden layer.\nLook at the neurons in the last layer - does any of the neurons reflect the spiral of the data well?\nTry removing some of the features the network uses the least - does it still perform well?\nSummarize the changes you had to make to the network to make it fit the spiral data. Do these changes capture the non-linear pattern in the data?\n\n\n\nExercise 32-6\nLet’s wrap up with a different kind of problem - regression. In contrast to classification, we do not try to predict a discrete class but rather a specific numerical value. At the top left, click on problem type and choose “Regression”. Of the datasets, pick the more difficult dataset to the right, listed as “Multi Gaussian”. Include only the X1 and X2 features, but try different network architectures. Let the training run between 200 and 500 Epochs when testing your network.\n\nCan you get the Test Loss below 0.005 with only a single hidden layer?\nDoes adding more hidden layers improve the model?\nWhich additional features enhance the model the most?\nDoes the addition of some features only improve models with more than one hidden layer?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Neural networks</span>"
    ]
  },
  {
    "objectID": "chapters/project/folding_project/index.html",
    "href": "chapters/project/folding_project/index.html",
    "title": "33  Primer analysis",
    "section": "",
    "text": "Count the number of bases in your candidate primer\nSay you have a short sequence that you want to use as a PCR primer. To evaluate if it a suitable primer, you need to know the melting temperature of the sequence. You also need to make sure that it will not fold up on itself so that it cannot bind to the DNA sequence you want to amplify.\nDownload the files you need for this project:\nhttps://munch-group.org/bioinformatics/supplementary/project_files\nPut the files in a folder dedicated to this project. On most computers you can right-click on the link and choose “Save file as…” or “Download linked file”.\nBefore you can compute the melting temperature, you need to determine how many times each base occurs in the sequence. You can assume that the only characters in the string are A, T, G, and C.\nWrite a function, count_bases, which takes one argument:\nThe function must return:\nExample usage: If the function is called like this:\nthen it should return (not necessarily with key-value pairs in the same order):",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Primer analysis</span>"
    ]
  },
  {
    "objectID": "chapters/project/folding_project/index.html#count-the-number-of-bases-in-your-candidate-primer",
    "href": "chapters/project/folding_project/index.html#count-the-number-of-bases-in-your-candidate-primer",
    "title": "33  Primer analysis",
    "section": "",
    "text": "A string, which is a DNA sequence.\n\n\n\nA dictionary, which in which keys are strings that represent bases and values are integers that represent the number of occurrences of each base. If a base is not found in the sequence, its count must be zero.\n\n\ncount_bases(\"ATGG\")\n\n{\"A\": 1, \"C\": 0, \"G\": 2, \"T\": 1}",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Primer analysis</span>"
    ]
  },
  {
    "objectID": "chapters/project/folding_project/index.html#compute-the-melting-temperature",
    "href": "chapters/project/folding_project/index.html#compute-the-melting-temperature",
    "title": "33  Primer analysis",
    "section": "Compute the melting temperature",
    "text": "Compute the melting temperature\nKnowing the base composition in your sequence, you can now calculate the melting temperature the double-stranded DNA that forms when your primer pairs up with the sequence to amplify. If the primer has less than 14 bases the formula for calculating melting temperature is:\n\\[ Temp = (A + T) * 2 + (G + C) * 4 \\]\nand if the primer has 14 bases or more it is calculated like this:\n\\[ Temp = 64.9 + 41 * (G + C - 16.4) / (A + T + G + C) \\]\nThe A, T, C, and G in the formulas represent the numbers of A, T, C and G in the DNA primer.\nYou must write a function that applies these two formulas appropriately by taking the length of the primer into account.\nWrite a function, melting_temp, which takes one argument:\n\nA string, which is a DNA sequence (your primer).\n\nThe function must return:\n\nA number, which represents the melting temperature of the double-stranded DNA corresponding to the DNA string given as argument.\n\nExample usage: If the function is called like this:\nmelting_temp(\"ATG\")\nthen it should return:\n8",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Primer analysis</span>"
    ]
  },
  {
    "objectID": "chapters/project/folding_project/index.html#reverse-complement-the-sequence",
    "href": "chapters/project/folding_project/index.html#reverse-complement-the-sequence",
    "title": "33  Primer analysis",
    "section": "Reverse complement the sequence",
    "text": "Reverse complement the sequence\nIt is possible that one part of the primer forms base pairs with another part of the primer to form a hairpin structure. To figure out if this can happen to your primer, you need to be able to find the reverse complement of DNA sequence. The reverse complement of a DNA sequence is one where the sequence of bases is first reversed, and then each base is replaced with its Watson-Crick complementary base.\nWrite a function, reverse_complement, which takes one argument:\n\nA string, which is a DNA sequence.\n\nThe function must return:\n\nA string, which represents the reverse complement of the DNA string given as argument.\n\nExample usage: If the function is called like this:\nreverse_complement(\"AATTC\")\nthen it should return:\n\"GAATT\"",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Primer analysis</span>"
    ]
  },
  {
    "objectID": "chapters/project/folding_project/index.html#check-for-hairpins",
    "href": "chapters/project/folding_project/index.html#check-for-hairpins",
    "title": "33  Primer analysis",
    "section": "Check for hairpins",
    "text": "Check for hairpins\nYou would like to be able to determine if your primer can fold to form a hairpin with some specified minimum number of consequtive base pairs. We assume that hairpin loops are always at least four bases long and that base pairs in the hairpin can only be Watson-Crick basepairs. Here is an example of a hairpin with five basepairs and a loop of four bases (four Cs):\n        C C\n      C     C\n       A - T\n       T - A\n       A - T\n       T - A\n       A - T\nTo test if a sequence can form a hairpin with at least four consequtive base pairs, you need to test if the sequence contains any subsequence of length four whose reverse complement is identical to another nonoverlapping subsequence. To take into account that the hairpin loop is at least four bases long, any such two subsequences must be separated by at least four bases.\nWrite a function, has_hairpin, which takes two arguments:\n\nA string, which is a DNA sequence.\nAn integer, which represents the minimum number of consequtive base pairs in the hairpins to search for.\n\nThe function must return:\n\nTrue if the sequence contains a hairpin of at least the specified length and False otherwise.\n\nExample usage: If the function is called like this:\nprint(has_hairpin(\"ATATACCCCTATAT\", 4))\nthen it should return:\nTrue\nThis is a hard one, so I will give you a bit of help. Here is the function with some parts missing.\ndef has_hairpin(s, k):\n    looplen = 4\n    for i in range(len(s)-k+1):\n        subs = # Hint A\n        right = # Hint B\n        revcl = reverse_complement(subs)\n        if revcl in right[looplen:]:\n            return True\n    return False\nHint A: Here you need to extract a substring of length k starting at i. Hint B: Here you need to extract all the sequence to the right of substr.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Primer analysis</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/assembly_and_mapping.html",
    "href": "chapters/bioinformatics/assembly_and_mapping.html",
    "title": "34  Genome assembly and read mapping",
    "section": "",
    "text": "Sequencing technologies\nIntroduction to Genome Assembly and State-of-the-Art Algorithms\nGenome assembly, a fundamental task in bioinformatics and genomics, involves the reconstruction of a complete genome sequence from fragmented DNA sequences. This intricate process is essential for understanding the genetic makeup of organisms, identifying genetic variations, and comprehending the molecular basis of various biological phenomena. As DNA sequencing technologies have advanced, producing enormous amounts of short DNA fragments, the field of genome assembly has witnessed remarkable progress in algorithmic development and computational techniques.\nIn the early days of genomics, the Sanger sequencing method generated relatively longer reads, simplifying the assembly process. However, with the advent of high-throughput sequencing technologies such as Illumina, which produce shorter reads, genome assembly became more challenging due to the complexities associated with reconstructing the original genome sequence accurately from these fragmented pieces. To address this challenge, a myriad of algorithms have been developed, each with distinct strategies, advantages, and limitations.\nState-of-the-art genome assembly algorithms employ various innovative approaches to tackle the complexities of assembling genomes from short DNA reads. One prominent approach is the “de Bruijn graph” method, which involves breaking down the reads into smaller k-mers (subsequences of length k) and constructing a graph where nodes represent k-mers and edges depict their overlapping relationships. This graph-based representation enables the detection of overlaps and the identification of potential paths through which k-mers can be connected to reconstruct longer sequences.\nAnother cutting-edge technique involves the use of “overlap-layout-consensus” (OLC) approaches. In this strategy, reads are aligned to one another to identify overlapping regions, creating a layout of their relative positions. By establishing a consensus sequence from these overlaps, the algorithm constructs longer contiguous sequences. OLC methods are particularly advantageous for assembling longer reads generated by technologies like PacBio and Oxford Nanopore.\nAdditionally, hybrid assembly approaches combine data from different sequencing technologies to capitalize on their respective strengths. For example, short reads from Illumina can be used to correct errors in long reads from PacBio or Nanopore, resulting in highly accurate and contiguous assemblies.\nRecent advancements in machine learning and artificial intelligence have also influenced genome assembly algorithms. Deep learning techniques, such as convolutional neural networks (CNNs) and recurrent neural networks (RNNs), have been applied to improve error correction, scaffolding, and other assembly steps, enhancing the accuracy and efficiency of the overall process.\nIn conclusion, genome assembly stands at a fascinating crossroads of biology, computer science, and data analysis. State-of-the-art algorithms continue to evolve, leveraging innovative strategies and leveraging advancements in sequencing technologies and computational methods. These algorithms enable researchers to unlock the mysteries of genetics, uncovering insights into the structure and function of genomes with increasing accuracy and speed.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Genome assembly and read mapping</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/assembly_and_mapping.html#graph-based-assembly",
    "href": "chapters/bioinformatics/assembly_and_mapping.html#graph-based-assembly",
    "title": "34  Genome assembly and read mapping",
    "section": "Graph-based assembly",
    "text": "Graph-based assembly",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Genome assembly and read mapping</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/assembly_and_mapping.html#dealing-with-repeats",
    "href": "chapters/bioinformatics/assembly_and_mapping.html#dealing-with-repeats",
    "title": "34  Genome assembly and read mapping",
    "section": "Dealing with repeats",
    "text": "Dealing with repeats",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Genome assembly and read mapping</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/assembly_and_mapping.html#assessing-the-quality-of-an-asssembly",
    "href": "chapters/bioinformatics/assembly_and_mapping.html#assessing-the-quality-of-an-asssembly",
    "title": "34  Genome assembly and read mapping",
    "section": "Assessing the quality of an asssembly",
    "text": "Assessing the quality of an asssembly",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Genome assembly and read mapping</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/assembly_and_mapping.html#resequencing",
    "href": "chapters/bioinformatics/assembly_and_mapping.html#resequencing",
    "title": "34  Genome assembly and read mapping",
    "section": "Resequencing",
    "text": "Resequencing",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Genome assembly and read mapping</span>"
    ]
  },
  {
    "objectID": "chapters/project/assembly_project/index.html",
    "href": "chapters/project/assembly_project/index.html",
    "title": "35  Genome assembly",
    "section": "",
    "text": "Read and analyze the sequencing reads\nThis chapter is a programming project where you will assemble a small genomic sequence from a set of short sequencing reads.\nIn genome assembly, many short sequences (reads) from a sequencing machine are assembled into long sequences – ultimately chromosomes. This is done by ordering overlapping reads so that they together represent genomic sequences. For example, given these three reads: AGGTCGTAG, CGTAGAGCTGGGAG, GGGAGGTTGAAA, ordering them based on their overlap like this\nproduces the following genomic sequence:\nReal genome assembly is, of course, more sophisticated than what we do here, but the idea is the same. To limit the complexity of the problem, we make two simplifying assumptions:\nThe second assumption implies that overlaps are always of this type:\nand never of this type:\nIn this project, you will be asked to write functions that solve the problem of assembling a genomic sequence. Each function solves a small problem, and you may need to call these functions inside other functions to put together solutions to larger subproblems.\nDownload the files you need for this project:\nhttps://munch-group.org/bioinformatics/supplementary/project_files\nYou also need to download the two project files:\nPut the files in a folder dedicated to this project. On most computers you can right-click on the link and choose “Save file as…” or “Download linked file”.\nNow open each file in your editor and look at what is in sequencing_reads.txt. (Do not change it in any way, and do not save it after viewing. If your editor asks you if you want to save it before closing, say no.) How many sequences are there in each file?\nThe project is split into four parts:\nHere is an overview of the functions you will write in each part of the project and of which functions are used by other functions.\nMake sure to read the entire exercise and understand what you are supposed to do before you begin!\nThe first task is to read and parse the input data. The sequence reads for the mini-assembly are in the file sequencing_reads.txt. The first two lines of the file look like this:\nEach line represents a read. The first field on each line is the name of the read, and the second field is the read sequence itself. So for the first line, Read1 is the name, and ATGCG... is the sequence.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Genome assembly</span>"
    ]
  },
  {
    "objectID": "chapters/project/assembly_project/index.html#read-and-analyze-the-sequencing-reads",
    "href": "chapters/project/assembly_project/index.html#read-and-analyze-the-sequencing-reads",
    "title": "35  Genome assembly",
    "section": "",
    "text": "Read1 GGCTCCCCACGGGGTACCCATAACTTGACAGTAGATCTCGTCCAGACCCCTAGC\nRead2 CTTTACCCGGAAGAGCGGGACGCTGCCCTGCGCGATTCCAGGCTCCCCACGGG\n\n\nRead the sequencing reads into your program\nWrite a function, read_data, that takes one argument:\n\nA string, which is the name of the data file.\n\nThe function must return\n\nA dictionary, where the keys are the names of reads and the values are the associated read sequences. Both keys and values must be strings.\n\nExample usage:\nread_data('sequencing_reads.txt')\nshould return a dictionary with the following content (maybe not with key-value pairs in that order)\n{'Read1': 'GGCTCCCCACGGGGTACCCATAACTTGACAGTAGATCTCGTCCAGACCCCTAGC',\n 'Read3': 'GTCTTCAGTAGAAAATTGTTTTTTTCTTCCAAGAGGTCGGAGTCGTGAACACATCAGT',\n 'Read2': 'CTTTACCCGGAAGAGCGGGACGCTGCCCTGCGCGATTCCAGGCTCCCCACGGG',\n 'Read5': 'CGATTCCAGGCTCCCCACGGGGTACCCATAACTTGACAGTAGATCTC',\n 'Read4': 'TGCGAGGGAAGTGAAGTATTTGACCCTTTACCCGGAAGAGCG',\n 'Read6': 'TGACAGTAGATCTCGTCCAGACCCCTAGCTGGTACGTCTTCAGTAGAAAATTGTTTTTTTCTTCCAAGAGGTCGGAGT'}\nHere is some scaffolding code to get you started:\ndef read_data(file_name):\n    input_file = open(file_name)\n    # ...\n    for line in input_file:\n         # ...    \n    # ...\n    \n    input_file.close() \n    \nThe line variable in the for loop holds each line in the file, including the \\n newline character at the end. You can use the’ split’ method of strings to split each line into the name of the read and the read sequence. You can see the documentation for that method by typing pydoc str.split in your terminal.\n\n\nCompute the mean length of reads\nAfter writing that function, we would like to get an idea about the length of the reads. There are often too many reads to look at manually, so we need to make a function that computes the mean length of the reads.\nWrite a function, mean_length, that takes one argument:\n\nA dictionary, in which keys are read names and values are read sequences (this is a dictionary like that returned by read_data).\n\nThe function must return\n\nA float, which is the average length of the sequence reads.\n\nOne way to do this is to loop over the keys in the dictionary like this:\ndef mean_length(reads):\n    count = 0\n    total = 0\n    for name in reads:\n        seq = reads[name]\n        # ...\n        # ...\n    # ...\n    return total / count\nRemember that you can use the len function to find the length of a read.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Genome assembly</span>"
    ]
  },
  {
    "objectID": "chapters/project/assembly_project/index.html#compute-overlaps-between-reads",
    "href": "chapters/project/assembly_project/index.html#compute-overlaps-between-reads",
    "title": "35  Genome assembly",
    "section": "Compute overlaps between reads",
    "text": "Compute overlaps between reads\nThe next step is to determine which reads overlap each other. We need a function that takes two read sequences and computes their overlap to do that. Remember that in the input data, none of the reads are completely nested in another read.\n\nCompute the overlap between two reads\nWe know there are no sequencing errors so that the sequence match will be perfect in the overlap. To compute the overlap between the 3’ (right) end of the left read with the 5’ (left) end of the righthand read, you need to loop over all possible overlaps, honoring that one sequence is the left one and the other is the right one. In the for loop, start with the largest possible overlap ( min(len(left), len(right))) and evaluate smaller and smaller overlaps until you find an exact match.\nWrite a function, get_overlap, that takes two arguments\n\nA string, which is the lefthand read sequence.\nA string, which is the righthand read sequence.\n\nThe function must return\n\nA string, which is the overlapping sequence. If there is no overlap, it should return an empty string.\n\nExample usage:\ns1 = \"CGATTCCAGGCTCCCCACGGGGTACCCATAACTTGACAGTAGATCTC\"\ns2 = \"GGCTCCCCACGGGGTACCCATAACTTGACAGTAGATCTCGTCCAGACCCCTAGC\"\nget_overlap(s1, s2)\nshould return the string\n'GGCTCCCCACGGGGTACCCATAACTTGACAGTAGATCTC'\nand get_overlap(s2, s1)\nshould return the string\n'C'\nFrom these two examples, it seems that s1 and s2 overlap and that s1 is the left and s2 is the right. Treating s2 as the left one and s1 as the right one only gives an overlap of one base (we expect a few bases of overlap even for unrelated sequences).\n\n\n\n\nCompute all read overlaps\nWhen you have written get_overlap, you can use it to evaluate the overlap between all pairs of reads in both left-right and right-left orientations.\nWrite a function, get_all_overlaps, that takes one argument:\n\nA dictionary with read data as returned by read_data.\n\nThe function must return\n\nA dictionary of dictionaries specifying the number of overlapping bases for a pair of reads in a specific left-right orientation. Computing the overlap of a read to itself is meaningless and must not be included. Assuming the resulting dictionary of dictionaries is called d, then d['Read2'] will be a dictionary where keys are the names of reads that have an overlap with read 'Read2' when 'Read2' is put in the left position, and the values for these keys are the number of overlapping bases for those reads.\n\nExample usage: assuming that reads is a dictionary returned by read_data then:\nget_all_overlaps(reads)\nshould return the following dictionary of dictionaries (but not necessarily with the same ordering of the key-value pairs):\n{'Read1': {'Read3': 0, 'Read2': 1, 'Read5': 1, 'Read4': 0, 'Read6': 29},\n 'Read3': {'Read1': 0, 'Read2': 0, 'Read5': 0, 'Read4': 1, 'Read6': 1},\n 'Read2': {'Read1': 13, 'Read3': 1, 'Read5': 21, 'Read4': 0, 'Read6': 0},\n 'Read5': {'Read1': 39, 'Read3': 0, 'Read2': 1, 'Read4': 0, 'Read6': 14},\n 'Read4': {'Read1': 1, 'Read3': 1, 'Read2': 17, 'Read5': 2, 'Read6': 0},\n 'Read6': {'Read1': 0, 'Read3': 43, 'Read2': 0, 'Read5': 0, 'Read4': 1}}\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou can use the get_overlap function you just made to find the overlap between a pair of reads. To generate all combinations of reads, you need two for-loops. One looping over reads in the left position, and another (inside the first one) looping over reads in the right position. Remember that we do not want the overlap of a read to itself, so there should be an if-statement checking that the left and right reads are not the same.\n\n\n\n\n\nPrint overlaps as a nice table\nThe dictionary returned by get_all_overlaps is a bit messy. We want to print it in a nice matrix-like format so we can better see which pairs overlap in which orientations.\nThis pretty_print function should take one argument:\n\nA dictionary of dictionaries as returned by get_all_overlaps.\n\nThe function should not return anything but must print a matrix exactly as shown in the example below with nicely aligned and right-justified columns. The first column must hold names of reads in left orientation. The top row holds names of reads in right orientation. The remaining cells must each have the number of overlapping bases for a left-right read pair. The diagonal corresponds to overlaps with the read itself. You must put dashes in these cells.\nExample usage: assuming that overlaps is a dictionary of dictionaries returned by get_all_overlaps then:\npretty_print(overlaps)\nshould print exactly\n       Read1  Read2  Read3  Read4  Read5  Read6 \nRead1      -      1      0      0      1     29 \nRead2     13      -      1      0     21      0\nRead3      0      0      -      1      0      1\nRead4      1     17      1      -      2      0 \nRead5     39      1      0      0      -     14 \nRead6      0      0     43      1      0      -\nThis function is hard to get completely right. So, to spare you the frustration, this one is on me:\ndef pretty_print(d):\n    print('      ', end='')\n    for j in sorted(d):\n        print(\"{: &gt;6}\".format(j), end='')\n    print()\n    for i in sorted(d):\n        print(\"{: &gt;6}\".format(i), end='')\n        for j in sorted(d):\n            if i == j:\n                s = '     -'\n            else:\n                s = \"{: &gt;6}\".format(d[str(i)][str(j)])\n            print(s, end='')\n        print()\nMake sure you understand how it works. You can look up in the documentation what \"{: &gt;6}\".format(i) does.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Genome assembly</span>"
    ]
  },
  {
    "objectID": "chapters/project/assembly_project/index.html#find-the-correct-order-of-reads",
    "href": "chapters/project/assembly_project/index.html#find-the-correct-order-of-reads",
    "title": "35  Genome assembly",
    "section": "Find the correct order of reads",
    "text": "Find the correct order of reads\nNow that we know how the reads overlap, we can chain them pair by pair from left to right to get the order in which they represent the genomic sequence. To do this, we take the first (left-most) read and identify which read has the largest overlap at its right end. Then we take that read and find the read with the largest overlap to the right end of that - until we reach the rightmost (last) read.\n\nFind the first read\nThe first thing you need to do is to identify the first (leftmost) read so we know where to start. This read is identified as the one that has no significant (&gt;2) overlaps to its left end (it only has a good overlap when positioned to the left of other reads). In the example output from pretty_print above, the first read would be read 'Read4' because the 'Read4' column has no significant overlaps (no one larger than two).\nWe break the problem in two and first write a function that gets all the overlaps to the left end of a read (i.e., when it is in the right position):\nWrite a function, get_left_overlaps, that takes two arguments:\n\nA dictionary of dictionaries as returned from get_all_overlaps.\nA string, which represents the name of a read.\n\nThe function must return\n\nA sorted list of integers, which represent the overlaps of other reads to its left end.\n\nExample usage: assuming that overlaps is a dictionary of dictionaries returned by get_all_overlaps then.\nget_left_overlaps(overlaps, 'Read1')\nshould return\n[0, 0, 1, 13, 39]\n\n\n\n\n\n\nHint\n\n\n\n\n\nOnce you have made a list of left overlaps, you can use the built-in function sorted to make a sorted version of the list that you can return from the function.\n\n\n\nOK, now that we have a function that can find all the overlaps to the left end of a given read, all we need to do is find the particular read with no significant (&gt;2) overlaps to its left end.\nWrite a function, find_first_read, that takes one argument:\n\nA dictionary of dictionaries as returned from get_all_overlaps.\n\nThe function must return\n\nA string containing the name of the first read.\n\nExample usage: assuming that overlaps is a dictionary of dictionaries returned by get_all_overlaps then.\nfind_first_read(overlaps)\nshould return\n'Read4'\n\n\nFind the order of reads\nNow that we have the first read, we can find the correct order of the reads. We want a list of the read names in the right order.\nGiven the first (left) read, the next read is the one that has the largest overlap to the right end of that read. We use our dictionary of overlaps to figure out which read that is. If the first read is 'Read4', then overlaps['Read4'] is a dictionary of reads with overlap to the right end of read 'Read4'. So, to find the name of the read with the largest overlap, you must write a function that finds the key associated with the largest value in a dictionary. We do that first:\nWrite a function, find_key_for_largest_value, that takes one argument:\n\nA dictionary.\n\nThe function must return the key associated with the largest value in the dictionary argument.\nHaving written find_key_for_largest_value, you can use it as a tool in the function that finds the order of reads:\nWrite a function, find_order_of_reads, that takes two arguments:\n\nA string, which is the name of the first (left-most) read (that is returned by find_first_read).\nA dictionary of dictionaries of all overlaps (that returned by get_all_overlaps).\n\nThe function must return\n\nA list of strings, which are read names in the order in which they represent the genomic sequence.\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou know the first read is given by the first argument to the function. You also know that you can find the next read in the chain of overlapping reads by using the find_key_for_largest_value function. You should keep adding reads to the chain as long as the overlap is larger than two (you can use a for loop with an if statement inside to check that the overlap is larger than 2).\n\n\n\nExample usage: assuming that overlaps is a dictionary of dictionaries returned by get_all_overlaps then:\nfind_order_of_reads('Read4', overlaps)\nshould return:\n['Read4', 'Read2', 'Read5', 'Read1', 'Read6', 'Read3']\nBefore you implement the function, make sure you understand why this is the right list of read names.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Genome assembly</span>"
    ]
  },
  {
    "objectID": "chapters/project/assembly_project/index.html#reconstruct-the-genomic-sequence",
    "href": "chapters/project/assembly_project/index.html#reconstruct-the-genomic-sequence",
    "title": "35  Genome assembly",
    "section": "Reconstruct the genomic sequence",
    "text": "Reconstruct the genomic sequence\nNow that you have the number of overlapping bases between reads and the correct order of the reads, you can reconstruct the genomic sequence.\n\nReconstruct the genomic sequence from the reads\nWrite a function, reconstruct_sequence, that takes three arguments:\n\nA list of strings, which are the names of reads in the order identified by find_order_of_reads.\nA dictionary, with read data as returned from read_data.\nA dictionary of dictionaries with overlaps as returned from get_all_overlaps.\n\nThe function must return\n\nA string, which is the genomic sequence.\n\nExample usage: assuming that order is the list of strings returned by find_order_of_reads, that reads is the dictionary returned by read_data and that overlaps is a dictionary of dictionaries returned by get_all_overlaps then:\nreconstruct_sequence(order, reads, overlaps)    \nshould return one long DNA string (I had to break it in three to make it fit on the page):\nTGCGAGGGAAGTGAAGTATTTGACCCTTTACCCGGAAGAGCGGGACGCTGCCCTGCGCGATT\nCCAGGCTCCCCACGGGGTACCCATAACTTGACAGTAGATCTCGTCCAGACCCCTAGCTGGTA\nCGTCTTCAGTAGAAAATTGTTTTTTTCTTCCAAGAGGTCGGAGTCGTGAACACATCAGT\n\n\n\n\n\n\nHint\n\n\n\n\n\nIterate over the reads in order and use the overlap information to extract and join the appropriate parts of the reads.\n\n\n\n\n\nPutting the whole thing together\nNow that you have written functions to handle each step, you can write one last function that uses them to complete the entire assembly.\nWrite a function, assemble_genome, that takes one argument:\n\nA string, which is the name of a file with sequencing reads in the format described at the beginning of this project description.\n\nThe function must return\n\nA string, which is the genome assembled from the sequencing reads\n\nExample usage:\nassemble_genome('sequencing_reads.txt')\nshould return the assembled genome:\nTGCGAGGGAAGTGAAGTATTTGACCCTTTACCCGGAAGAGCGGGACGCTGCCCTGCGCGATT\nCCAGGCTCCCCACGGGGTACCCATAACTTGACAGTAGATCTCGTCCAGACCCCTAGCTGGTA\nCGTCTTCAGTAGAAAATTGTTTTTTTCTTCCAAGAGGTCGGAGTCGTGAACACATCAGT",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Genome assembly</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/global_alignment.html",
    "href": "chapters/bioinformatics/global_alignment.html",
    "title": "36  Pairwise global alignment",
    "section": "",
    "text": "An optimal alignment",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/global_alignment.html#an-optimal-alignment",
    "href": "chapters/bioinformatics/global_alignment.html#an-optimal-alignment",
    "title": "36  Pairwise global alignment",
    "section": "",
    "text": "What is an alignment?\nWhat do we want it to represent?\nScoring an alignment",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/global_alignment.html#a-recursive-solution",
    "href": "chapters/bioinformatics/global_alignment.html#a-recursive-solution",
    "title": "36  Pairwise global alignment",
    "section": "A recursive solution",
    "text": "A recursive solution",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/global_alignment.html#global-pairwise-alignment",
    "href": "chapters/bioinformatics/global_alignment.html#global-pairwise-alignment",
    "title": "36  Pairwise global alignment",
    "section": "Global pairwise alignment",
    "text": "Global pairwise alignment\nIf i give you the following three optimal alignments: n-1, m-1; n, m-1; n-1, m can you the. Give me the optimal alignment of n,m?\nThe Needleman-Wunsch algorithm is a dynamic programming algorithm commonly used for global sequence alignment in bioinformatics and computational biology. Developed by Saul B. Needleman and Christian D. Wunsch in 1970, this algorithm is fundamental for comparing two sequences, such as DNA, RNA, or protein sequences, to identify similarities, differences, and evolutionary relationships between them.\nProblem Statement: The primary objective of sequence alignment is to identify the optimal alignment between two sequences by inserting gaps (representing insertions or deletions) to maximize the similarity score while adhering to predefined scoring rules.\nAlgorithm Overview: The Needleman-Wunsch algorithm builds a dynamic programming matrix to efficiently calculate the optimal alignment score and traceback through the matrix to retrieve the optimal alignment itself. It employs a recurrence relation to calculate the score of aligning prefixes of the two sequences and incrementally fills the matrix based on these calculations.\nScoring Scheme: The algorithm uses a scoring scheme to assign scores to matches, mismatches, and gaps. Typically, a positive score is assigned to matches, a negative score to mismatches, and negative penalties for gap openings and gap extensions. The scoring scheme reflects the biological context and influences the alignment results.\nDynamic Programming Matrix: The dynamic programming matrix is constructed with dimensions M x N, where M is the length of the first sequence and N is the length of the second sequence. Each cell in the matrix represents the score of aligning the prefixes of the two sequences up to that point.\nInitialization: The first row and the first column of the matrix are initialized based on the gap penalties. The first row corresponds to aligning the first sequence with gaps in the second sequence, and the first column corresponds to aligning the second sequence with gaps in the first sequence.\nRecurrence Relation: Starting from the second row and the second column, each cell (i, j) in the matrix is calculated as the maximum of three values:\nThe cell above (i-1, j) plus the gap penalty (gap extension). The cell to the left (i, j-1) plus the gap penalty (gap extension). The diagonal cell (i-1, j-1) plus the match/mismatch score based on the characters in the sequences at positions i and j. Traceback: After the matrix is filled, the optimal alignment can be reconstructed by backtracking from the bottom-right corner (i.e., the end of both sequences) to the top-left corner (i.e., the beginning of both sequences). At each step, the decision to move diagonally, up, or left is based on the values in the neighboring cells and the scoring rules.\nAlignment Output: The traceback results in the aligned sequences with gaps, showcasing the optimal alignment between the input sequences. The alignment score is the value in the bottom-right corner of the matrix and represents the degree of similarity between the two sequences.\nComplexity: The Needleman-Wunsch algorithm has a time and space complexity of O(M * N), where M and N are the lengths of the input sequences. This complexity makes it suitable for relatively short sequences but can become impractical for very long sequences.\nIn summary, the Needleman-Wunsch algorithm is a foundational tool for performing global sequence alignment, allowing researchers to compare and analyze biological sequences to uncover evolutionary relationships, genetic variations, and functional similarities between genes, proteins, and other biological molecules.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/global_alignment.html#local-pairwise-alignment",
    "href": "chapters/bioinformatics/global_alignment.html#local-pairwise-alignment",
    "title": "36  Pairwise global alignment",
    "section": "Local pairwise alignment",
    "text": "Local pairwise alignment",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/global_alignment.html#alignment-significance",
    "href": "chapters/bioinformatics/global_alignment.html#alignment-significance",
    "title": "36  Pairwise global alignment",
    "section": "Alignment significance",
    "text": "Alignment significance",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/global_alignment.html#do-it-yourself",
    "href": "chapters/bioinformatics/global_alignment.html#do-it-yourself",
    "title": "36  Pairwise global alignment",
    "section": "Do it yourself:",
    "text": "Do it yourself:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/local_alignment.html",
    "href": "chapters/bioinformatics/local_alignment.html",
    "title": "37  Pairwise global alignment",
    "section": "",
    "text": "An optimal alignment",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/local_alignment.html#an-optimal-alignment",
    "href": "chapters/bioinformatics/local_alignment.html#an-optimal-alignment",
    "title": "37  Pairwise global alignment",
    "section": "",
    "text": "What is an alignment?\nWhat do we want it to represent?\nScoring an alignment",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/local_alignment.html#a-recursive-solution",
    "href": "chapters/bioinformatics/local_alignment.html#a-recursive-solution",
    "title": "37  Pairwise global alignment",
    "section": "A recursive solution",
    "text": "A recursive solution",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/local_alignment.html#global-pairwise-alignment",
    "href": "chapters/bioinformatics/local_alignment.html#global-pairwise-alignment",
    "title": "37  Pairwise global alignment",
    "section": "Global pairwise alignment",
    "text": "Global pairwise alignment\nIf i give you the following three optimal alignments: n-1, m-1; n, m-1; n-1, m can you the. Give me the optimal alignment of n,m?\nThe Needleman-Wunsch algorithm is a dynamic programming algorithm commonly used for global sequence alignment in bioinformatics and computational biology. Developed by Saul B. Needleman and Christian D. Wunsch in 1970, this algorithm is fundamental for comparing two sequences, such as DNA, RNA, or protein sequences, to identify similarities, differences, and evolutionary relationships between them.\nProblem Statement: The primary objective of sequence alignment is to identify the optimal alignment between two sequences by inserting gaps (representing insertions or deletions) to maximize the similarity score while adhering to predefined scoring rules.\nAlgorithm Overview: The Needleman-Wunsch algorithm builds a dynamic programming matrix to efficiently calculate the optimal alignment score and traceback through the matrix to retrieve the optimal alignment itself. It employs a recurrence relation to calculate the score of aligning prefixes of the two sequences and incrementally fills the matrix based on these calculations.\nScoring Scheme: The algorithm uses a scoring scheme to assign scores to matches, mismatches, and gaps. Typically, a positive score is assigned to matches, a negative score to mismatches, and negative penalties for gap openings and gap extensions. The scoring scheme reflects the biological context and influences the alignment results.\nDynamic Programming Matrix: The dynamic programming matrix is constructed with dimensions M x N, where M is the length of the first sequence and N is the length of the second sequence. Each cell in the matrix represents the score of aligning the prefixes of the two sequences up to that point.\nInitialization: The first row and the first column of the matrix are initialized based on the gap penalties. The first row corresponds to aligning the first sequence with gaps in the second sequence, and the first column corresponds to aligning the second sequence with gaps in the first sequence.\nRecurrence Relation: Starting from the second row and the second column, each cell (i, j) in the matrix is calculated as the maximum of three values:\nThe cell above (i-1, j) plus the gap penalty (gap extension). The cell to the left (i, j-1) plus the gap penalty (gap extension). The diagonal cell (i-1, j-1) plus the match/mismatch score based on the characters in the sequences at positions i and j. Traceback: After the matrix is filled, the optimal alignment can be reconstructed by backtracking from the bottom-right corner (i.e., the end of both sequences) to the top-left corner (i.e., the beginning of both sequences). At each step, the decision to move diagonally, up, or left is based on the values in the neighboring cells and the scoring rules.\nAlignment Output: The traceback results in the aligned sequences with gaps, showcasing the optimal alignment between the input sequences. The alignment score is the value in the bottom-right corner of the matrix and represents the degree of similarity between the two sequences.\nComplexity: The Needleman-Wunsch algorithm has a time and space complexity of O(M * N), where M and N are the lengths of the input sequences. This complexity makes it suitable for relatively short sequences but can become impractical for very long sequences.\nIn summary, the Needleman-Wunsch algorithm is a foundational tool for performing global sequence alignment, allowing researchers to compare and analyze biological sequences to uncover evolutionary relationships, genetic variations, and functional similarities between genes, proteins, and other biological molecules.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/local_alignment.html#local-pairwise-alignment",
    "href": "chapters/bioinformatics/local_alignment.html#local-pairwise-alignment",
    "title": "37  Pairwise global alignment",
    "section": "Local pairwise alignment",
    "text": "Local pairwise alignment",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/local_alignment.html#alignment-significance",
    "href": "chapters/bioinformatics/local_alignment.html#alignment-significance",
    "title": "37  Pairwise global alignment",
    "section": "Alignment significance",
    "text": "Alignment significance",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/local_alignment.html#do-it-yourself",
    "href": "chapters/bioinformatics/local_alignment.html#do-it-yourself",
    "title": "37  Pairwise global alignment",
    "section": "Do it yourself:",
    "text": "Do it yourself:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Pairwise global alignment</span>"
    ]
  },
  {
    "objectID": "chapters/project/alignment_project/index.html",
    "href": "chapters/project/alignment_project/index.html",
    "title": "38  Pairwise alignment",
    "section": "",
    "text": "Filling in the dynamic programming matrix\nThis chapter is about global pairwise alignment, and you will implement your own Needleman-Wunch algorithm.\nYour task is to find an optimal alignment of two sequences. If two such sequences are roughly 140 bases long, there are as many different ways to align them as there are atoms in the visible universe. Finding an optimal alignment among those \\(10^{80}\\) possibilities is a hard problem, but implementing the Needleman-Wunch algorithm will let you do it.\nThis project is meant to train your coding abilities and consolidate your understanding of the Needleman-Wunch algorithm. The better you understand the algorithm before you begin, the easier and more rewarding the project will be. So, re-read the book chapter about pairwise alignment and browse the lecture slides.\nDownload the files you need for this project:\nhttps://munch-group.org/bioinformatics/supplementary/project_files - alignmentproject.py is the file where you must write your code. It already contains a function I wrote for you. - test_alignmentproject.py is the test program that lets you test the code you write in alignmentproject.py.\nPut the files in a folder dedicated to this project. On most computers, you can right-click on the link and choose “Save the file as…” or “Download linked file.”\nThe project is split into two parts:\nTo help you along, the alignmentproject.py file already contains a function I wrote for you, so you can print your dynamic programming (DP) matrix as you gradually fill it in. You are not expected to understand how this function works. I made it as condensed as possible so it does not take up so much space in your file.\nThe function is named print_dp_matrix and takes two arguments:\nThe function returns:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Pairwise alignment</span>"
    ]
  },
  {
    "objectID": "chapters/project/alignment_project/index.html#filling-in-the-dynamic-programming-matrix",
    "href": "chapters/project/alignment_project/index.html#filling-in-the-dynamic-programming-matrix",
    "title": "38  Pairwise alignment",
    "section": "",
    "text": "Make a matrix\nWe start by making a list of lists (a matrix) with the right shape but only holds None values. We use the None values as placeholders, which you can later replace with scores. You can think of it as an empty matrix into which you can fill scores, just as we did in the lectures. If you want to align two sequences like AT and GAT, you want a matrix with three rows and four columns. Note that the matrix must have one more row than the number of bases in sequence one and one more column than the number of bases in sequence two.\nWrite a function, empty_matrix, that takes two arguments\n\nAn integer (which represents the length of sequence one + 1).\nAn integer (which represents the length of sequence two + 1).\n\nThe function must return:\n\nA list of lists. The number of sub-lists must be equal to the first integer argument. Each sublist must contain a number of None values equal to the second integer argument.\n\nExample usage:\nempty_matrix(3, 4)\nreturns a list with three lists each of length four:\n[[None, None, None, None], [None, None, None, None], [None, None, None, None]]\nEven though this is a list of lists, we can think of it as a three-by-four matrix:\n[[None, None, None, None], \n [None, None, None, None], \n [None, None, None, None]]\nIf you want to print the matrix in a way that looks like the slides I showed you at the lecture, you can use the print_dp_matrix function (again, None represents empty cells):\n          G    A    T\n  None None None None\nA None None None None\nT None None None None\nImportant: You can implement empty_matrix in a way that superficially looks ok but will cause you all kinds of grief when you start filling it in. When you create the list of lists (e.g., three as above), you must generate and add three separate lists. If you add the same list three times, you do not have three separate rows in your matrix. Instead, you have three references to the same row. You can test if you did it right this way – by changing the value of one cell to see what happens:\nempty = empty_matrix(3, 4)\nempty[0][0] = 'Mogens'\nprint(empty)\nIf this only changed one value like below, you are ok:\n[['Mogens', None, None, None], [None, None, None, None], [None, None, None, None]]\nIf it changed the first value in all the lists, it means that all your lists are the same (which is not what you want).\n[['Mogens', None, None, None], ['Mogens', None, None, None], ['Mogens', None, None, None]]\n\n\nFill the top row and left column\nNow that you can make a matrix with the correct dimensions, you need to write a function that fills in the top row and the left column with multiples of the gap score. E.g., if the gap score is -2, you want the matrix to look something like this when you print it with print_dp_matrix:\n          G    A    T\n     0   -2   -4   -6\nA   -2 None None None\nT   -4 None None None\nWrite a function, prepare_matrix, which takes three arguments:\n\nAn integer (which represents the length of sequence one plus one)\nAn integer (which represents the length of sequence two plus one)\nAn integer, which represents the gap_score used for alignment.\n\nThe function must return:\n\nA list of lists. The number of sub-lists must be equal to the first integer argument. The values in the first sub-list must be multiples of the gap score given as the third argument. The first elements of the remaining sub-lists must be multiples of the gap score. All remaining elements of sub-lists must be None.\n\nExample usage:\nprepare_matrix(3, 4, -2)\nmust return:\n[[0, -2, -4, -6], [-2, None, None, None], [-4, None, None, None]]\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou should call empty_matrix inside prepare_matrix to get a matrix filled with None.\n\n\n\nNow, all you need to do is replace the right None values with multiples of the gap score. For example, the third element in the first sub-list is matrix[2][0], for which you would need to assign the value 2 times the gap score. In the same way matrix[3][0] should be 3 times the gap score. So, you need to figure out which elements you should replace and which pairs of indexes you need to access those elements. Then, use range to generate those indexes and for-loops to loop them over.\n\n\nFill the entire matrix\nNow that we can fill the top row and left column, we can start thinking about how to fill the whole matrix.\nFor that, we need a score matrix of match scores. In Python, that is most easily represented as a dictionary of dictionaries like this:\nscore_matrix = {'A': {'A': 2, 'T': 0, 'G': 0, 'C': 0},\n                'T': {'A': 0, 'T': 2, 'G': 0, 'C': 0},\n                'G': {'A': 0, 'T': 0, 'G': 2, 'C': 0},\n                'C': {'A': 0, 'T': 0, 'G': 0, 'C': 2}}\nThat lets you get the score for matching an A with a T like this: score_matrix['A']['T']. Note that the match scores are only for uppercase letters (A, T, G, C).\nWrite a function, fill_matrix, which takes four arguments:\n\nA string, which represents the first sequence.\nA string, which represents the second sequence.\nA dictionary of dictionaries like the one shown above, which represents match scores.\nAn integer, which represents the gap score.\n\nThe function must return:\n\nA list of lists of integers, which represents a correctly filled dynamic programming matrix given the two sequences, the match scores, and the gap score.\n\nExample usage: If score_matrix is defined as above, then\nfill_matrix('AT', 'GAT', score_matrix, -2)\nmust return:\n[[0, -2, -4, -6], [-2, 0, 0, -2], [-4, -2, 0, 2]]\nIf you print that matrix using print_dp_matrix it should look like this:\n      G  A  T\n   0 -2 -4 -6\nA -2  0  0 -2\nT -4 -2  0  2\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou should call prepare_matrix inside fill_matrix to get a matrix with the top row and left column filled. Assuming seq1 is sequence one and seq2 is sequence two, then you can do it like this:\nmatrix = prepare_matrix(len(seq1)+1, len(seq2)+1, gap_score)\n\n\n\nNow, you only need to fill out the rest. You need two nested for-loops to produce the indexes of the elements in the list of lists that you need to assign values to.\nfor i in range(1, len(seq1)+1):\n    for j in range(1, len(seq2)+1):\n        print(i, j) # just to see what i and j are\nExamine this code and make sure you understand why we give those arguments to range. Each combination of i and j lets you access an element matrix[i][j] in matrix (list of lists) that you can assign a value to. The value to assign to matrix[i][j] (green cell on the slides) is the maximum of three values (the yellow cells on the slide):\n\nThe value of the cell to the left (matrix[i][j-1]) plus the gap score.\nThe cell above (matrix[i-1][j]) plus the gap score.\nThe diagonal cell (matrix[i-1][j-1]) plus the match score for base number i (index i-1) of sequence one and base number j (index j-1) of sequence two.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Pairwise alignment</span>"
    ]
  },
  {
    "objectID": "chapters/project/alignment_project/index.html#reconstructing-the-optimal-alignment",
    "href": "chapters/project/alignment_project/index.html#reconstructing-the-optimal-alignment",
    "title": "38  Pairwise alignment",
    "section": "Reconstructing the optimal alignment",
    "text": "Reconstructing the optimal alignment\nThis is the most challenging part, so I will hold your hand here. Below is first a function that identifies which of three cells (the yellow cells on the slides) some cell (green cell on the slides) is derived from. On the slides, this is the cell pointed to by the red arrow.\ndef get_traceback_arrow(matrix, row, col, match_score, gap_score):\n\n    # yellow cells:\n    score_diagonal = matrix[row-1][col-1]\n    score_left = matrix[row][col-1]\n    score_up = matrix[row-1][col]\n\n    # gree cell:\n    score_current = matrix[row][col]\n\n    if score_current == score_diagonal + match_score:\n        return 'diagonal'\n    elif score_current == score_left + gap_score:\n        return 'left'\n    elif score_current == score_up + gap_score:\n        return 'up'\nWrite (do not copy and paste) this into your file, and make sure that it works and that you understand exactly how it works before you proceed.\nHere is a function that uses get_traceback_arrow to do the traceback. It reconstructs the alignment starting from the last column, adding columns in front as the traceback proceeds. It is big, so it breaks across three pages.\ndef trace_back(seq1, seq2, matrix, score_matrix, gap_score):\n\n    # Strings to store the growing alignment strings:\n    aligned1 = ''\n    aligned2 = ''\n\n    # The row and col index of the bottom right cell:\n    row = len(seq1)\n    col = len(seq2)\n\n    # Keep stepping backwards through the matrix untill\n    # we get to the top row or the left col:\n    while row &gt; 0 and col &gt; 0:\n\n        # The two bases we available to match:\n        base1 = seq1[row-1]\n        base2 = seq2[col-1]\n\n        # The score for mathing those two bases:\n        match_score = score_matrix[base1][base2]\n\n        # Find out which cell the score in the current cell was derived from:\n        traceback_arrow = get_traceback_arrow(matrix, row, col, match_score, gap_score)\n\n        if traceback_arrow == 'diagonal':\n                # last column of the sub alignment is base1 over base2:\n            aligned1 = base1 + aligned1\n            aligned2 = base2 + aligned2\n            # next cell is the diagonal cell:\n            row -= 1\n            col -= 1\n        elif traceback_arrow == 'up':\n                # last column in the sub alignment is base1 over a gap:\n            aligned1 = base1 + aligned1\n            aligned2 = '-' + aligned2\n            # next cell is the cell above:\n            row -= 1\n        elif traceback_arrow == 'left':\n                # last column in the sub alignment is a gap over base2:\n            aligned1 = '-' + aligned1\n            aligned2 = base2 + aligned2\n            # next cell is the cell to the left:\n            col -= 1\n\n    # If row is not zero, step along the top row to the top left cell:\n    while row &gt; 0:\n        base1 = seq1[row-1]\n        aligned1 = base1 + aligned1\n        aligned2 = '-' + aligned2\n        row -= 1\n\n    # If col is not zero, step upwards in the left col to the top left cell:\n    while col &gt; 0:\n        base2 = seq2[col-1]\n        aligned1 = '-' + aligned1\n        aligned2 = base2 + aligned2\n        col -= 1\n\n    return [aligned1, aligned2]\nOnce you have written it into your file, make sure you understand the correspondence to the sequences of events on the lecture slides.\nNow you can write a function that performs the alignment. You get to do that yourself. It just calls fill_matrix and then trace_back to get the optimal alignment\nWrite a function, align, that takes four arguments:\n\nA string, which represents sequence one.\nA string, which represents sequence two.\nA dictionary of dictionaries, which represents the match scores (as described above).\nAn integer, which represents the gap score.\n\nThe function must return:\n\nA list of length two. The first element of that list must be a string representing the aligned sequence one. The second element must be a string, representing the aligned sequence two.\n\nExample usage:\nalign('ATAT', 'GATGAT', score_matrix, -2)\nmust return:\n['-AT-AT', 'GATGAT']\nOnce you have written that function, you can print your alignment like this:\nalignment = align('ATAT', 'GATGAT', score_matrix, -2)\nfor s in alignment:\n    print(s)",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Pairwise alignment</span>"
    ]
  },
  {
    "objectID": "chapters/web/ccr5_pwalign/index.html",
    "href": "chapters/web/ccr5_pwalign/index.html",
    "title": "39  CCR5-delta32",
    "section": "",
    "text": "Human Immunodeficiency Virus targets immune cells\nHIV (Human Immunodeficiency Virus) infects immune cells by specifically targeting and binding to certain receptors on the surface of these cells. The primary immune cells that HIV infects are CD4+ T cells (commonly known as T-helper cells), macrophages, and dendritic cells. Here’s a simplified step-by-step explanation of how HIV infects immune cells: The first step in the infection process involves the attachment of HIV to immune cells. The virus carries a glycoprotein on its surface called gp120, which binds to the CD4 receptor on the surface of CD4+ T cells, macrophages, and dendritic cells. This interaction is the initial binding event between the virus and the host cell. After binding to CD4, HIV also requires a co-receptor to gain entry into the host cell. Two common co-receptors used by the virus are CCR5 and CXCR4. Depending on the viral strain, it can use one or both of these co-receptors. This interaction between gp120 and the co-receptor triggers a conformational change in the virus, allowing it to fuse with the host cell membrane. The conformational change in the virus membrane allows it to fuse with the host cell membrane. This fusion event enables the virus to release its genetic material into the interior of the host cell. Once inside the host cell, HIV carries an enzyme called reverse transcriptase, which converts its single-stranded RNA genome into double-stranded DNA. This process is known as reverse transcription.\nThe newly formed viral DNA is transported into the cell’s nucleus, where it is integrated into the host cell’s DNA. The enzyme integrase plays a critical role in this step. Once integrated, the viral DNA becomes a permanent part of the host cell’s genetic material. The integrated viral DNA is transcribed into messenger RNA (mRNA), which is then translated by the host cell’s machinery to produce viral proteins and RNA. This leads to the assembly of new viral particles. New viral particles are assembled in the host cell and are released from the cell’s surface in a process known as budding. The new virus particles can go on to infect other immune cells and continue the cycle of infection. As HIV continues to infect and replicate within CD4+ T cells, macrophages, and dendritic cells, the immune system’s response is compromised. Over time, the gradual loss of CD4+ T cells, which are crucial for coordinating the immune response, weakens the immune system’s ability to defend the body against various infections. This progressive immune system decline eventually leads to the clinical symptoms associated with AIDS (Acquired Immunodeficiency Syndrome).",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>CCR5-delta32</span>"
    ]
  },
  {
    "objectID": "chapters/web/ccr5_pwalign/index.html#can-specific-gene-variants-provide-resistance-to-hiv",
    "href": "chapters/web/ccr5_pwalign/index.html#can-specific-gene-variants-provide-resistance-to-hiv",
    "title": "39  CCR5-delta32",
    "section": "Can specific gene variants provide resistance to HIV?",
    "text": "Can specific gene variants provide resistance to HIV?\nThe CCR5 gene and its protective variant, CCR5-delta32, thus play a pivotal role in the complex interplay between human genetics and HIV. The CCR5 gene, specifically its CCR5-delta32 mutation, has garnered significant attention in the field of HIV research due to its remarkable ability to confer a degree of natural resistance against the virus. The CCR5 gene, short for “C-C chemokine receptor type 5,” encodes a protein receptor found on the surface of certain immune cells, including T-cells and macrophages. This receptor acts as a gateway for HIV to enter these cells, a critical step in the virus’s infection cycle. However, a naturally occurring genetic variant of CCR5 known as CCR5-delta32 possesses a mutation that renders the receptor non-functional. Individuals who inherit two copies of this mutation are notably resistant to HIV infection, as the virus struggles to enter and infect their immune cells. This extraordinary genetic resistance has raised considerable interest in the scientific and medical communities, as it offers insights into potential HIV treatment strategies and the development of innovative therapies.\nThe frequency of the CCR5-delta32 variant varies significantly across different populations worldwide. It is important to note that historical factors, such as population migrations, genetic bottlenecks, and the prevalence of diseases like HIV, can influence the presence and distribution of this protective mutation. Here’s an overview of the frequency of the CCR5-delta32 mutation in different regions: The CCR5-delta32 mutation is most common in populations of Northern European descent, particularly in Scandinavia. In some regions of Northern Europe, such as Sweden and Finland, the mutation can be found in approximately 10-15% of the population. This high prevalence is thought to have resulted from strong selection pressures due to past epidemics, like the bubonic plague. As you move southward in Europe, the frequency of the CCR5-delta32 mutation decreases. In Southern European countries like Spain and Italy, the prevalence drops to about 5% or even lower. The CCR5-delta32 mutation is relatively rare in African, Asian, and Indigenous populations. In most cases, it occurs in less than 1% of these populations. The low frequency can be attributed to the historical lack of selective pressure from diseases like HIV in these regions.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>CCR5-delta32</span>"
    ]
  },
  {
    "objectID": "chapters/web/ccr5_pwalign/index.html#aim",
    "href": "chapters/web/ccr5_pwalign/index.html#aim",
    "title": "39  CCR5-delta32",
    "section": "Aim",
    "text": "Aim\nYour goal is to use pairwise alignment to find the position of the delta32 mutation and establish if it is a deletion, insertion, or nucleotide substitution. This way, you, or other researchers, will be able to learn how the mutation changes the gene’s protein-coding sequence.\nThe learning goals of this exercise are:\n\nAcquire practical experience using online alignemnt tools.\nUnderstanding how parameters in the Needleman-Wunch algorithms affects the alignment.\nUnderstand the different uses of DNA and protein alignment.\nAcquire practical experience using online Blast to search an NCBI sequence database.\nGetting acquainted with different file formats for storing sequence information.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>CCR5-delta32</span>"
    ]
  },
  {
    "objectID": "chapters/web/ccr5_pwalign/index.html#preparation",
    "href": "chapters/web/ccr5_pwalign/index.html#preparation",
    "title": "39  CCR5-delta32",
    "section": "Preparation",
    "text": "Preparation\n\nFasta sequence format\nFiles containing DNA or protein sequences are just text files formatted in a particular way so that each sequence can be associated with additional information. The most simple format is called FASTA format, and files with sequences in this format are called FASTA files and are usually given either a “.fa” or “.fasta” suffix. A FASTA has two elements for each sequence: a header line with a leading ” &gt;” character followed by one or more lines with the DNA or protein sequence (the sequence may be broken over several lines). The content of a FASTA file with two (short) sequences in it could look like this:\n&gt;7423344 some additional description\nAGTCCCTTGCA\nTTATTGCAATAT\n&gt;2342134 some additional description\nGGTCCAATTGC\nAAATTGGAATA\nThe first word after the “&gt;” in the header line is usually a sequence identifier; the rest is an additional description or information.\n\n\nAligning DNA sequences\nFor this this exercise, you will have four fasta files each with one sequence in it:\n\nThe full mRNA of the normal CCR5 gene: CCR5_mRNA.fa\nThe full mRNA of the CCR5-delta32 variant: CCR5_mRNA_delta32.fa\nThe coding sequence (CDS) of CCR5: CCR5_CDS.fa\nThe coding sequence (CDS) of CCR5-delta32: CCR5_CDS_delta32.fa\n\nYou can download the files on Brightspace.\n\nExercise 39-1\nBefore we head into the actual investigation, lets begin by looking at the exon/intron structure of CCR5 by aligning the mRNAs of CCR5 to its CDS using the Needleman-Wunsch algorithm. Go to the EBI website for pairwise alignment. Under “Sequence type” you need to select “DNA” to enable alignment parameters suitable for DNA alignment. Now align the two sequences by copy/pasting the mRNA into the top input field and the CDS into the bottom one (you must include the header line with the “&gt;” character). Leave the rest of the options with their default values.\n\nGuided Reflections\n\nWhat are the other default values? Click “more options” to see what they are.\nWhich score matrix gap penalties are used?\nDoes the program use linear or affine gap scoring?\nAre gaps at the ends of the alignment scored differently than the internal gaps?\n\n\n\n\nExercise 39-2\nNow click “Submit”, to get your job queued on the server. Yol, and the bottom part shows parau have to wait a bit. When the job is completed and the output is shown, the lines beginning with “#” provide additional information about the alignment. The top part list the options used for running the “needle” program in the terminameter values and alignment statistics.\n\nGuided Reflections\n\nWhat gap scoring was used?\nWhich substitution matrix was used?\nWhere do you find the result of the alignment?\nThe alignment shows differences and similarities between the two sequences. Which differences do you see between the mRNA and the CDS? Why is there a difference?\n\n\n\n\nExercise 39-3\nNow, on to the actual investigation. Begin by aligning the mRNAs of CCR5 and CCR5-delta32 to each other using the Needleman-Wunsch algorithm using the default values of parameters. Look at the alignment results.\n\nGuided Reflections\n\nDescribe the similarities between the two sequences. How many bases are the same and where are they located?\nDescribe the differences between the two sequences. Where are the differences located on the mRNA and how many bases are involved? (Hint: 5’-UTR, 3’-UTR, Coding region)",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>CCR5-delta32</span>"
    ]
  },
  {
    "objectID": "chapters/web/ccr5_pwalign/index.html#aligning-protein-sequences",
    "href": "chapters/web/ccr5_pwalign/index.html#aligning-protein-sequences",
    "title": "39  CCR5-delta32",
    "section": "Aligning protein sequences",
    "text": "Aligning protein sequences\n\nExercise 39-4\nNow, you will translate the coding sequence of CCR5 and CCR5-delta32 to see which effect the mutation has on the protein level. Go to the Expasy translate website and set the “Output format” to “verbose”. Then, translate the two coding sequences, one at a time, by pasting the FASTA entries into the field (including the header line).\n\nGuided Reflections\n\nWhat are the likely reading frames of each sequence? (number and direction)\nWhich differences do you observe based on the translated sequence?\n\n\n\n\nExercise 39-5\nNow go back to the EMBOSS Needle website and align the two protein sequences. Look at the results of the alignment.\n\nGuided Reflections\n\nWhere are the similarities between the two protein sequences?\nWhere are the differences between the two protein sequences?\nHow does the mutation affect the protein? (Hints: deletion, insertion, missense, nonsense, frameshift)",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>CCR5-delta32</span>"
    ]
  },
  {
    "objectID": "chapters/web/ccr5_pwalign/index.html#searching-a-database-using-blast",
    "href": "chapters/web/ccr5_pwalign/index.html#searching-a-database-using-blast",
    "title": "39  CCR5-delta32",
    "section": "Searching a database using Blast",
    "text": "Searching a database using Blast\nSooty mangabay (Cercocebus atys) is a species of primates. Sooty mangabays also have common variants in their CCR5 gene that seem to protect them against SIV (simian immunodeficiency virus). We want to investigate how the Sooty mangabay CCR5 variants are similar or different to the gene variants found in the human CCR5.\n\nExercise 39-6\nYou can use Blast to find and investigate these sequences too. Go to the Blast website at NCBI. Clicking “Nucleotide BLAST” will take you to the search interface for the versions of Blast optimized for DNA and RNA searches. Leave the settings to their default values, but take a look around to see what options are available. “Program Selection” lists the version of Blast. We are using megablast for this.\n\nGuided Reflections\n\nClick the “?” icon to learn a bit about each one. How do you think megablast and blastn may differ in the kmer sizes and thresholds they use?\n\n\n\n\nExercise 39-7\nBefore you start the database search, you want to limit its scope to only sequences from sooty mangabey. Set organism to sooty mangabey (“sooty mangabey (taxid:9531)”). Once you do this, it should look like Figure 39.1. Now paste in the CCR5 CDS and click the blue “BLAST” button at the bottom of the page to queue your search request (you may have to wait a bit).\n\n\n\n\n\n\nFigure 39.1: BLAST search interface\n\n\n\nOnce the search results appear, they are sorted by E-value. The light blue header row lets you sort them by other criteria. “Query cover” sorts the database hits by how much of your search sequence (query) they cover.\n\nGuided Reflections\n\nWhat does the E-value mean?\nWhat types of sequences does the BLAST search return?\n\n\n\n\nExercise 39-8\nSince you are looking for search hits to a CDS in the other species, look for “C-C motif chemokine receptor 5 (CCR5), complete CDS” in the descriptions of search hits and pick the one with the highest percent identity. Clicking the corresponding link in the description column takes you to a local alignment of the part of your query sequence that aligns with the database sequence. In this case, it covers your entire CCR5 CDS.\n\nGuided Reflections\n\nDescribe the differences shown by the alignment. How many bases are different? How many gaps are there?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>CCR5-delta32</span>"
    ]
  },
  {
    "objectID": "chapters/web/ccr5_pwalign/index.html#genbank-sequence-format",
    "href": "chapters/web/ccr5_pwalign/index.html#genbank-sequence-format",
    "title": "39  CCR5-delta32",
    "section": "GenBank sequence format",
    "text": "GenBank sequence format\n\nExercise 39-9\nNow go back to the list of search hits by clicking the “Descriptions” link in the light blue bar above the alignment you were just looking at. See if you can find any search hits with names including “delta”. There should be a delta delta-24 allele among them. Pick the one with sequence ID AF079473.1. Inspect the alignment to the human CCR5.\n\nGuided Reflections\n\nWhat characterizes these variants? What does the “delta” in the variant name refer to?\nGiven what you now know about the human and mangabey CCR5 genes, do you expect that the delta32 mutation to have arisen before or after the common ancestor of humans and mangabeys?\n\n\n\n\nExercise 39-10\nGo back to the descriptions list by clicking the “Descriptions” link in the light blue bar. On the left are tick boxes for each search hit. Mark only the two you have been looking at (IDs AF051905.1 and AF079473.1). In the “Download” dropdown list pick “GenBank” to download the two sequences in GenBank format. GenBank is a sequence entry format like Fasta, including much more information about each sequence. Open the downloaded file in VScode and see what it looks like.\n\nGuided Reflections\n\nWhen were the sequences determined/published?\nWhat sequencing method was used?\nFor each sequence, note another piece of information provided in the GenBank entry format.\n\n\n\n\nExercise 39-11\nIn the GenBank file, you can find the translated sequences of each CDS. Make a new text file in VScode and paste the two translated sequences in to create a Fasta file like this:\n&gt;normal\nMDYQVSSPTYDIDYYTSEPCQKINVKQIAARLLPPLYSLVFIFG\n… rest of the sequence …\n\n&gt;delta24\nMDYQVSSPTYDIDYYTSEPCQKINVKQIAARLLPPLYSLVFIFG\n… rest of the sequence …    \nNow, head back to the EBI needle website and align the two protein sequences. Make sure it is set to protein this time.\n\nGuided Reflections\n\nWhere is the deletion located?\nDoes it just delete amino acids, and if so, how many, or does it change the reading frame or induce stop codons?\nHow does the mangabey CCR5 mutation compare to that in humans?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>CCR5-delta32</span>"
    ]
  },
  {
    "objectID": "chapters/web/ccr5_pwalign/index.html#putting-it-all-together",
    "href": "chapters/web/ccr5_pwalign/index.html#putting-it-all-together",
    "title": "39  CCR5-delta32",
    "section": "Putting it all together",
    "text": "Putting it all together\n\nExercise 39-12\nHave a look at this scientific paper: “A Novel CCR5 Mutation Common in Sooty Mangabeys Reveals SIVsmm Infection of CCR5-Null Natural Hosts and Efficient Alternative Coreceptor Use In Vivo” and look at Figure 1 and its figure legend.\n\nGuided Reflections\n\nFigure 1A shows the alignment of 6 different gene variants. What species are they from and what variants are shown?\nFigure 1B shows the alignment of the predicted protein sequence. What do the grey boxes mean? What do the arrows mean? What does the highlighted sequence mean?\nWe have now looked at the sequences of different mutations. Suggest an experimental method/setup, that might show something about the functional importance of the mutations.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>CCR5-delta32</span>"
    ]
  },
  {
    "objectID": "chapters/web/ccr5_pwalign/index.html#project-files",
    "href": "chapters/web/ccr5_pwalign/index.html#project-files",
    "title": "39  CCR5-delta32",
    "section": "Project files",
    "text": "Project files\nDownload the files you need for this project:\n \nhttps://munch-group.org/bioinformatics/supplementary/project_files",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>CCR5-delta32</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/protein_substitution_matrices.html",
    "href": "chapters/bioinformatics/protein_substitution_matrices.html",
    "title": "40  Protein substitution matrices",
    "section": "",
    "text": "Scoring protein alignments",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Protein substitution matrices</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/protein_substitution_matrices.html#pam-matrices",
    "href": "chapters/bioinformatics/protein_substitution_matrices.html#pam-matrices",
    "title": "40  Protein substitution matrices",
    "section": "PAM matrices",
    "text": "PAM matrices\nThe PAM (Point Accepted Mutation) matrices are a family of substitution matrices used in bioinformatics for comparing protein sequences. PAM matrices are derived from an evolutionary model that assumes a specific rate of amino acid substitution over time. The number in the PAM matrix represents the fraction of accepted mutations (amino acid substitutions) at a specific position over a certain evolutionary distance. Here’s how to compute a PAM120 substitution matrix:\nCollect a Set of Homologous Sequences: Gather a set of protein sequences that are believed to be homologous or evolutionarily related. This set of sequences will serve as the input for constructing the substitution matrix.\nCalculate Pairwise Alignments: Align all pairs of sequences in the collected set using a suitable pairwise sequence alignment algorithm, such as Needleman-Wunsch or Smith-Waterman. This generates an alignment for each sequence pair, which helps identify positions where substitutions have occurred.\nCalculate Mutation Frequencies: Count the number of times each pair of amino acids has been substituted for each other across all the alignments. This provides the raw data for calculating the substitution probabilities.\nCalculate Fraction of Accepted Mutations (PAM1): For each amino acid pair, calculate the fraction of accepted mutations, which is the number of observed substitutions divided by the total number of aligned positions. PAM1 is the initial estimate of substitution probabilities.\nEstimate PAM Matrix for a Specific Evolutionary Distance: The PAM120 matrix represents amino acid substitutions over an estimated evolutionary distance of approximately 120 PAM units (PAM120). To compute this matrix, you need to perform a series of calculations using the PAM1 matrix.\nIterative Calculation: PAM matrices are constructed through iterations. The general idea is to extrapolate from PAM1 to PAM120 through a series of transformations. Each PAM matrix is derived from the previous one using a formula that relates the substitution probability in the current matrix to the substitution probabilities in the previous matrix.\nAdjust for Total Probability: In each iteration, the substitution probabilities are adjusted to ensure that the total probability of amino acid substitution remains constant. This helps maintain the expected properties of a substitution matrix.\nNormalization and Scaling: Normalize the calculated substitution probabilities to ensure they sum up to a certain value (often 1). Scale the probabilities by factors that depend on the number of substitutions and the evolutionary distance.\nRounding and Scaling for Matrix Values: Round the calculated probabilities to integers, ensuring that they fit into the matrix’s integer-based format. Scale the values by a constant factor to control the scoring range.\nMatrix Format: Present the calculated values in a matrix format, where rows and columns correspond to the 20 standard amino acids. The values in the matrix indicate the substitution scores between the respective amino acids.\nIt’s important to note that computing PAM matrices requires a deep understanding of evolutionary models, bioinformatics algorithms, and statistical concepts. PAM matrices are typically provided as precomputed matrices for various evolutionary distances, and their calculation involves complex mathematics. Therefore, most bioinformatics applications use precomputed PAM matrices rather than attempting to compute them from scratch.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Protein substitution matrices</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/protein_substitution_matrices.html#blosum-matrices",
    "href": "chapters/bioinformatics/protein_substitution_matrices.html#blosum-matrices",
    "title": "40  Protein substitution matrices",
    "section": "BLOSUM matrices",
    "text": "BLOSUM matrices\nThe BLOSUM (BLOcks SUbstitution Matrix) series of substitution matrices are widely used in bioinformatics for comparing protein sequences. BLOSUM matrices are derived from a set of aligned protein sequences and provide substitution scores that reflect the observed frequencies of substitutions between different amino acids. Here’s how to compute a BLOSUM62 substitution matrix:\nCollect a Sequence Database: Gather a diverse and representative set of protein sequences that are homologous or related to each other. This database will be used to calculate the substitution scores.\nCreate Sequence Pairs: Generate pairs of sequences from the collected database. These sequence pairs should be aligned to each other to identify the positions where substitutions occur.\nCalculate Substitution Frequencies: Count the number of times each pair of amino acids is observed to be substituted for each other in the aligned sequences. This forms the basis for calculating substitution probabilities.\nCalculate Substitution Probabilities: For each pair of amino acids, calculate the probability of substitution by dividing the observed substitution frequency by the total number of aligned pairs. This gives an idea of how likely one amino acid is to be substituted for another.\nCalculate Log-Odds Ratios: Convert the substitution probabilities into log-odds ratios by taking the logarithm (usually base 2) of the probability of substitution divided by the background frequency of observing those amino acids independently.\nNormalization: Normalize the log-odds ratios to ensure that the values are centered around zero and suitable for scoring alignments. This normalization step helps in preventing very high or very low scores.\nAdjustment for Diagonal Elements: The diagonal elements of the matrix (representing substitution of an amino acid with itself) are usually set to a fixed value, typically a negative value, to discourage mismatches.\nRounding and Scaling: Round the log-odds ratios to integers and scale them by a constant factor to ensure that the substitution scores are suitable for the scoring range desired.\nMatrix Format: Present the computed values in a matrix format, where rows and columns correspond to the 20 standard amino acids. The values in the matrix indicate the substitution scores between the respective amino acids.\nBLOSUM62 is specifically derived from a sequence identity of around 62% and is suited for comparing protein sequences that share this level of identity. It is widely used for aligning moderately divergent protein sequences. Different BLOSUM matrices with different sequence identity cutoffs (e.g., BLOSUM45, BLOSUM80) are available to accommodate sequences with varying degrees of similarity.\nIt’s important to note that BLOSUM matrices are typically precomputed and provided as standard matrices for various sequence comparison tools. If you’re looking to generate a BLOSUM matrix from scratch, it involves significant computational and statistical analysis, and specialized software tools are often used for this purpose.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Protein substitution matrices</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/protein_substitution_matrices.html#pam-vs-blosum",
    "href": "chapters/bioinformatics/protein_substitution_matrices.html#pam-vs-blosum",
    "title": "40  Protein substitution matrices",
    "section": "40.1 PAM vs BLOSUM",
    "text": "40.1 PAM vs BLOSUM\nBLOSUM (BLOcks SUbstitution Matrix) and PAM (Point Accepted Mutation) are both families of substitution matrices used in bioinformatics for comparing protein sequences. They are designed to quantify the likelihood of amino acid substitutions between sequences and are fundamental components in sequence alignment algorithms. Each family has its own advantages and limitations. Here’s a comparison of the pros and cons of BLOSUM and PAM matrices:\nBLOSUM (BLOcks SUbstitution Matrix):\nPros:\nEmpirical Nature: BLOSUM matrices are derived from a specific set of aligned protein sequences, often representing more recent evolutionary events. As a result, they capture more recent divergence and are suited for comparing moderately similar sequences. Variability: Different BLOSUM matrices are available (e.g., BLOSUM30, BLOSUM62, BLOSUM80), catering to varying degrees of sequence identity. This allows users to choose the matrix that best fits the similarity level of their sequences. Specificity: BLOSUM matrices can be used for aligning sequences with a wide range of similarity levels, making them versatile for various types of sequence comparisons. Scoring Range: BLOSUM matrices often result in a wider scoring range, providing more detailed information about sequence similarities and differences. Cons:\nLimited Evolutionary Distance: BLOSUM matrices are less suitable for highly divergent sequences or sequences separated by long evolutionary distances. Pre-computed Nature: BLOSUM matrices are precomputed and can’t be easily recalculated with custom data. This limits their adaptability to specific datasets. Homologous Sequences Required: The quality of BLOSUM matrices depends on the quality and diversity of the input sequences used to derive them. Alignment Quality Sensitivity: BLOSUM matrices are sensitive to the quality of the initial sequence alignment used to derive them. PAM (Point Accepted Mutation):\nPros:\nEvolutionary Model: PAM matrices are derived from an evolutionary model, which attempts to capture long-term evolutionary processes. They can be used for comparing sequences with a broader range of evolutionary distances. Flexibility: PAM matrices can be theoretically recalculated for custom datasets, although it requires significant computational effort and expertise. Range of Matrices: Like BLOSUM, different PAM matrices (e.g., PAM30, PAM120, PAM250) are available for varying degrees of sequence divergence. Long-Distance Comparisons: PAM matrices are more suitable for comparing highly divergent sequences due to their focus on longer-term evolutionary events. Cons:\nDependence on Model Assumptions: PAM matrices rely on the assumption of a specific evolutionary model, which may not perfectly represent all evolutionary processes. Complexity: Constructing and recalculating PAM matrices require significant computational resources and expertise. Sensitivity to Input Sequences: Like BLOSUM matrices, the quality of PAM matrices depends on the quality and diversity of the input sequences. Non-Contemporary Alignments: PAM matrices are designed to capture historical substitutions, which can be a limitation when comparing sequences with recent divergence. In summary, both BLOSUM and PAM matrices offer valuable tools for comparing protein sequences. The choice between them depends on the specific characteristics of the sequences being aligned, the desired degree of sensitivity, and the computational resources available. BLOSUM matrices are preferred for more recent evolutionary events and moderately similar sequences, while PAM matrices are better suited for longer-term evolutionary processes and highly divergent sequences.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Protein substitution matrices</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/database_searching.html",
    "href": "chapters/bioinformatics/database_searching.html",
    "title": "41  Data base searching",
    "section": "",
    "text": "BLAST",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Data base searching</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/database_searching.html#blast",
    "href": "chapters/bioinformatics/database_searching.html#blast",
    "title": "41  Data base searching",
    "section": "",
    "text": "BLAST is the 12’th most cited scientific paper - not just in bioinformatics but in all of science!.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Data base searching</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/database_searching.html#significance-of-search-hit",
    "href": "chapters/bioinformatics/database_searching.html#significance-of-search-hit",
    "title": "41  Data base searching",
    "section": "Significance of search hit",
    "text": "Significance of search hit",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Data base searching</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/database_searching.html#do-it-yourself",
    "href": "chapters/bioinformatics/database_searching.html#do-it-yourself",
    "title": "41  Data base searching",
    "section": "Do it yourself:",
    "text": "Do it yourself:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Data base searching</span>"
    ]
  },
  {
    "objectID": "chapters/web/mrsa_blast_multalign/index.html",
    "href": "chapters/web/mrsa_blast_multalign/index.html",
    "title": "42  MRSA",
    "section": "",
    "text": "Sequence Retrieval\nMethicillin-resistant Staphylococcus aureus (MRSA) is a strain of the staph bacteria that’s become resistant to the antibiotics typically used to treat ordinary staph infections. Originally, the Staphylococcus aureus bacterium was a common cause of skin infections, pneumonia, and other medical conditions. However, its methicillin-resistant counterpart, MRSA, emerged as a strain that resists many of the conventional antibiotics. This resistance is not limited to just methicillin but extends to other antibiotics, often rendering standard treatments ineffective.\nIndividuals infected with MRSA can experience a range of ailments, from skin and wound infections to more severe conditions like pneumonia, bloodstream infections, and sepsis. Particularly concerning is its ability to cause life-threatening complications in older or immunocompromised people or people with chronic illnesses.\nA critical factor that has amplified MRSA’s resilience and adaptability is the phenomenon of horizontal gene transfer (HGT). Unlike the usual vertical transfer of genes from parent to offspring, HGT facilitates the direct exchange of genetic material between different bacterial species. This form of gene transfer has been pivotal in the rapid acquisition and spread of antibiotic resistance genes within microbial communities, including those of Staphylococcus aureus.\nThe most common mechanism of HGT involves direct cell-to-cell contact, where a donor bacterium transfers genetic material, like the SCCmec carrying the mecA gene, to a recipient bacterium. Less commonly, viruses that infect bacteria, known as bacteriophages, can mistakenly package bacterial DNA, including resistance genes, and transfer them to another bacterium upon subsequent infection.\nMRSA’s resilience stems from various genetic mutations but is prominently due to the acquisition of the mecA gene. This gene provides the bacteria with the ability to produce a unique protein that alters its cell wall, reducing the efficacy of even last-resort antibiotics, such as methicillin. mecA is believed to have been acquired through HGT and often locates to a mobile genetic element called the staphylococcal chromosomal cassette (SCCmec), allowing for its potential transfer between different strains or even species of bacteria.\nGiven the role of HGT in the rapid spread of resistance, it’s evident that MRSA’s evolution isn’t merely a product of its internal genetic changes. It’s deeply intertwined with a broader microbial ecosystem, where genes, particularly those conferring survival advantages like antibiotic resistance, can be exchanged, adopted, and propagated. This understanding underscores the challenge that antibiotic resistance presents.\nIinvestigating the origins of the mecA gene in MRSA providesinsights into the potential sources and the evolutionary trajectory of antibiotic resistance. Your goal is to identify which organism(s) Staphylococcus aureus might have acquired the mecA gene, and what evidence supports this potential horizontal gene transfer event?\nThe structural learning goals of this exercise are:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>MRSA</span>"
    ]
  },
  {
    "objectID": "chapters/web/mrsa_blast_multalign/index.html#sequence-retrieval",
    "href": "chapters/web/mrsa_blast_multalign/index.html#sequence-retrieval",
    "title": "42  MRSA",
    "section": "",
    "text": "Exercise 42-1\nObtain the genetic sequence for the mecA gene from MRSA. Go to Genbank and find a complete sequence for mecA in Staphylococcus aureus. That is, do a nucleotide search for “Staphylococcus aureus mecA” and select a MecA gene version with “complete cds”. See Figure 42.2. Do not pick the complete genome. Check if MRSA is mentioned in the documentation for the result.\n\n\nExercise 42-2\nFind the FASTA version of the genomic reference assembly. This will give you the genetic sequence of the gene. Keep the header of the sequence (“&gt;… Staph…, complete cds”), as we will need this later.\n\n\nExericse 42-3\nFind the FASTA version of the protein sequence. There might be a link to this in “Related Information.”\n\n\n\n\n\n\nFigure 42.2: Screenshot",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>MRSA</span>"
    ]
  },
  {
    "objectID": "chapters/web/mrsa_blast_multalign/index.html#database-searching-using-blast",
    "href": "chapters/web/mrsa_blast_multalign/index.html#database-searching-using-blast",
    "title": "42  MRSA",
    "section": "Database Searching using BLAST",
    "text": "Database Searching using BLAST\n\nExercise 42-4\nGo to the NCBI BLAST web portal. Use the mecA nucleotide sequence to search for similar sequences in the nucleotide database. Which organisms have regions with high similarity to the mecA gene nucleotide sequence in your query? Tip: Check the “Show results in a new window” to allow searching multiple times and compare results. Further, know that it is normal for blasting to take a few minutes. Examine the following metrics (columns):\n\nE-value (Expect value): The number of hits one can “expect” to see by chance when searching a database of a particular size. Lower E-values indicate a more significant match. Typically, E-values below 0.05 or especially 0.01 suggest a significant match, but the threshold can depend on the content and especially the size of the search. The longer a search term, the less likely it is for random matches.\nPercent Identity: The percentage of identical matches between the query and subject sequences over the aligned region.\n\n\n\nExercise 42-5\nTry adjusting the number of maximum target sequences in “Algorithm Parameters” (e.g., to 1000). You can also exclude “Staphylococcus aureus” from the search results to only see other organisms.\n\nHow did this affect the results?\nCheck the taxonomy of your found organisms.\nCheck the graphic summary of the results.\n\n\n\nExercise 42-6\nTry the other programs (“Program Selection”). They may be slower but can find less similar matches that may uncover the potential sources of the gene.\n\nDid this affect the results? If so, how? (Use the taxonomy and graphic summary in your analysis.)\nWhat are the main differences between the programs (megablast, discontiguous megablast, and blastn).\nWhat do we expect from the different algorithms? It is okay to use Wikipedia or similar resources.\n\n\n\nExercise 42-7\nTry the protein blast algorithms and compare the findings. This requires the protein sequence. Do you find the MecA gene product (i.e., protein) in other types of bacteria (i.e., not Staphylococcus strains)? If so, what may this imply about horizontal gene transfer of this gene? Is there a risk of MRSA “helping” completely different, and perhaps more dangerous, bacteria genera become antibiotics resistant?\n\n\nExercise 42-8\nYou might see multiple Staphylococcus strains when allowing higher maximum target sequences. What are the potential interpretations of this concerning horizontal gene transfer? Can we deduce a single origin of the gene in Staphylococcus aureus from these results? Remember that we see a snapshot of where the genes were present during various studies – this is ever-changing.\n\n\nExericse 42-9\nAccording to Bloemendaal et al. (2010): “Methicillin Resistance Transfer from Staphylococcus epidermidis to Methicillin-Susceptible Staphylococcus aureus in a Patient during Antibiotic Therapy”, mecA may be transferred from Staphylococcus epidermidis. The mecA gene is located on the Staphylococcal Cassette Chromosome mec (SCCmec), and they found that the SCCmec were almost identical in MRSA and in S. epidermidis in a patient.\n\nDoes your results imply this may be true?\nIf this was the case in that one patient, does it mean the MecA gene in MRSA always stems from S. epidermidis?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>MRSA</span>"
    ]
  },
  {
    "objectID": "chapters/web/mrsa_blast_multalign/index.html#multiple-sequence-alignment-using-clustalw",
    "href": "chapters/web/mrsa_blast_multalign/index.html#multiple-sequence-alignment-using-clustalw",
    "title": "42  MRSA",
    "section": "Multiple Sequence Alignment using ClustalW",
    "text": "Multiple Sequence Alignment using ClustalW\n\nExercise 42-10\nChoose five or more types of bacteria from your BLAST results, such as Staphylococcus epidermidis (include Staphylococcus aureus). You will be comparing the MecA gene’s sequence in each of these to find relations between them.\n\n\nExercise 42-11\nGo to Genbank and find nucleotide sequences for the MecA gene in each of your selected organisms. E.g., search for “Staphylococcus epidermidis MecA”. You should get the (when possible) complete sequence for the gene only. Get the header of the FASTA file as well.\n\n\nExericise 42-12\nGo to ClustalW at https://www.genome.jp/tools-bin/clustalw and input the sequences (with header first) of the mecA sequences from MRSA and the selected organisms. See Figure 42.3 Select DNA as you’re inputting nucleotide sequences. Feel free to try the protein sequences.\nRun the multiple alignments. - What does the output tell us? - How may these alignments be useful to us in determining the origin of the MecA gene?\n\n\nExercise 42-13\nAt the top of the output page, select a method in the tree menu (e.g., FastTree) and press Exec. This will generate a phylogram. A phylogram is a depiction of evolutionary relationships between taxa, in this case, the mecA gene from different types of bacteria. The branch lengths illustrate evolutionary distance and nodes from where the tree branches can be interpreted as common ancestors when we are working with vertical gene transfer. Try to imagine what the nodes could be interpreted as when we are talking about horizontal gene transfer. Hint: maybe the nodes could be interpreted as possible horizontal gene transfer events.\n\nWhat does the generated phylogram tell you?\nHow could we use phylograms to track the potential horizontal gene transfer between the different bacteria?\n\n\n\n\n\n\n\nFigure 42.3: Screenshot",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>MRSA</span>"
    ]
  },
  {
    "objectID": "chapters/web/mrsa_blast_multalign/index.html#discussion",
    "href": "chapters/web/mrsa_blast_multalign/index.html#discussion",
    "title": "42  MRSA",
    "section": "Discussion",
    "text": "Discussion\nBased on the BLAST and ClustalW results, which organisms might have been the potential source(s) for the mecA gene in MRSA?\n\nDiscuss evidence of potential horizontal gene transfer events based on sequence similarity.\nReason about the roles of the various HGT approaches in MRSA (i.e., Conjugation, Transduction, Transformation). What types are most likely between staph bacteria?\nDiscuss the significance of horizontal gene transfer in the rapid emergence of antibiotic resistance.\nWhat are some ways we can use sequence alignments of MRSA to combat them? E.g., treatment, outbreak management (like tracking sources, spread, and evolution), and new drugs such as protein-targeting vaccines.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>MRSA</span>"
    ]
  },
  {
    "objectID": "chapters/web/mrsa_blast_multalign/index.html#additional-tools",
    "href": "chapters/web/mrsa_blast_multalign/index.html#additional-tools",
    "title": "42  MRSA",
    "section": "Additional tools",
    "text": "Additional tools\nDTU (Technical University of Denmark) has developed a set of tools highly relevant to antibiotic resistance and MRSE specifically. These are not part of the assignment, but check them out if you are curious:\n\nIdentification of acquired antibiotic resistance genes\nSCCmecFinder identifies SCCmec elements in sequenced S. aureus isolate\nIdentification of acquired virulence genes\nspaTyper predicts the S. aureus spa type",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>MRSA</span>"
    ]
  },
  {
    "objectID": "chapters/project/hiv_project/index.html",
    "href": "chapters/project/hiv_project/index.html",
    "title": "43  HIV sub-groups",
    "section": "",
    "text": "Compute the similarity of two sequences\nThis chapter is a programming project where you will put your new programming skills to use analyzing an HIV DNA sequences.\nYou have now been introduced to all the programming rules you will see in this course. You now know all the building blocks required to write any program – literally any. The reason why computer geeks are good at what they do is not that they know some incomprehensible secrets. It is because they practiced, a lot. With practice, the simple rules you know now will let you write anything from first-person shooter games over jumbo jet autopilots to scripts for simple problems in bioinformatics. In the last three chapters, we will train your ability to solve bioinformatics problems by putting together all the things you have learned.\nThe programming project in this chapter deals with DNA sequences from HIV viruses. There are two types of HIV: HIV-1, which is by far the most common, and HIV-2, which is mostly found in West Africa. HIV-1 vira are divided into groups M, N, O, and P. The most important group M (for major) is one primarily responsible for the global epidemic. Group M is further divided into subtypes A, B, C, D, F, G, J, K, and CRFs. In this project we will look at sequences from the subtypes A, B, C, and D. You have multiple database sequences for each of these four subtypes and you have one unknown sequence from a patient that you need to assign to either subtype A, B, C or D. To do this you will have to write a program that predicts the subtype of the unknown sequence. How cool is that?\nDownload the files you need for this project:\nhttps://munch-group.org/bioinformatics/supplementary/project_files\nYou also need to download the two project files:\nPut the files in a folder dedicated to this project. On most computers you can right-click on the link and choose “Save file as…” or “Download linked file”.\nNow open each file in VScode and have a look at what is in the data files. (Do not change them in any way and do not save them after viewing. If VScode asks you if you want to save it before closing, say no.) How many sequences are there in each file?\nThe project is divided into the following parts:\nMake sure you read the entire exercise and understand what you are supposed to do before you begin!\nWe need to compare our unknown HIV sequence to all the HIV sequences of known subtypes. That way we can identify the sequence of a known subtype that is most similar to your unknown sequence. We will then assume that our unknown sequence has the same subtype as this sequence. To accomplish this we first need to write some code that compares two sequences so we can compare our HIV sequence to each of the other HIV sequences.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>HIV sub-groups</span>"
    ]
  },
  {
    "objectID": "chapters/project/hiv_project/index.html#compute-the-similarity-of-two-sequences",
    "href": "chapters/project/hiv_project/index.html#compute-the-similarity-of-two-sequences",
    "title": "43  HIV sub-groups",
    "section": "",
    "text": "Compare two sequences\nWrite a function sequence_similarity that takes two arguments:\n\nA string which is a DNA sequence.\nA string of the same length as argument one, which is also a DNA sequence.\n\nThe function must return:\n\nA float, which is the proportion of bases that are the same in two DNA sequences.\n\nExample usage:\nsequence_similarity('AGTC' 'AGTT')\nshould return 0.75.\nStart out defining your function like this:\ndef sequence_similarity(seq1, seq2):\n    # your code here...\nRemember that range(len(seq1)) generates the numbers you can use to index the string seq1. You can use those numbers as indexes to look up positions in both strings. You will need a for-loop in your function and a variable that keeps track of how many similarities you have seen as you iterate through the sequences.\n\n\nCompare aligned sequences\nAll sequences, including the unknown sequence, are from the same multiple alignment. This ensures that sequence positions match up across all sequences but also means that a lot of gap characters ('-') are inserted. To compute similarities between such sequences you need to make function much like seqeuence_similarity that does not consider sequence positions where both bases are a gap ('-') characters. In other words, you must not only count the number of characters that are the same, you also need to count how many alignment columns that are \"-\" for both sequences. E.g. the following mini alignment has five such columns and four columns where the bases are the same. So in the following alignment, the similarity is 0.8 (4/5):\nA-CT-A\nA-CTTA\nWrite a function alignment_similarity that takes two arguments:\n\nA string which is a DNA sequence with gap characters.\nA string of the same length as argument one, which is also a DNA sequence with gap characters.\n\nThe function must return:\n\nA float, which is the proportion of bases that are the same in two DNA sequences.\n\nalignment_similarity('A-CT-A', 'A-CTTA')\nshould return 0.8.\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse an if-statement to test if the two characters at some index are equal to '-' in both sequences. You can use an expression like this:\nseq1[i] == '-' and seq2[i] == '-'\n\n\n\nOnce your function has computed both the number of identical bases and the number of alignment columns that are not both '-', you can have it return the similarity as the ratio of the two.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>HIV sub-groups</span>"
    ]
  },
  {
    "objectID": "chapters/project/hiv_project/index.html#read-the-hiv-sequences-into-your-program",
    "href": "chapters/project/hiv_project/index.html#read-the-hiv-sequences-into-your-program",
    "title": "43  HIV sub-groups",
    "section": "Read the HIV sequences into your program",
    "text": "Read the HIV sequences into your program\nTo use your alignment_similarity function to assess similarity between your unknown sequence and the sequences of known subtype, you need to read the sequences into your program. Here is a function that will read the sequences from one of the files you downloaded into a list:\ndef read_data(file_name):\n    f = open(file_name)\n    sequence_list = list()\n    for line in f:\n        seq = line.strip()\n        sequence_list.append(seq)\n    f.close()\n    return sequence_list\nYou can use that function to read the unknown sequence into your program:\nunknown_list = read_data('unknown_type.txt')\nIn this case, the list only contains the one unknown HIV sequence in unknown_type.txt.\nYou also need to load the typed HIV sequences into your program. Here is a function that returns a dictionary in which the keys are subtypes ('A', 'B', 'C' and 'D') and each value is a lists of sequences with that subtype:\ndef load_typed_sequences():\n    return {'A': read_data('subtypeA.txt'),\n            'B': read_data('subtypeB.txt'),\n            'C': read_data('subtypeC.txt'),\n            'D': read_data('subtypeD.txt') }\nIf you use the function like this:\ntyped_data = load_typed_sequences()\nthen you can access the list of sequences of subtype A like this: typed_data['A'].",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>HIV sub-groups</span>"
    ]
  },
  {
    "objectID": "chapters/project/hiv_project/index.html#compare-your-hiv-sequence-to-hiv-sequences-of-known-subtype",
    "href": "chapters/project/hiv_project/index.html#compare-your-hiv-sequence-to-hiv-sequences-of-known-subtype",
    "title": "43  HIV sub-groups",
    "section": "Compare your HIV sequence to HIV sequences of known subtype",
    "text": "Compare your HIV sequence to HIV sequences of known subtype\nTo type you HIV sequence you must compare your sequence to all the database sequences to see which group has the best matching sequence.\nWrite a function get_similarities that takes two arguments:\n\nA string, which is your unknown HIV sequence.\nA list of strings, each of which is an HIV sequence of known type.\n\nThe function must return:\n\nA list of floats, which should be the similarities between the unknown sequence given as the first argument and the list of sequences given as the second argument.\n\nExample usage:\nget_similarities(unknown_list[0], typed_data['A'])\nshould return:\n[0.8553288474061211, 0.8721742704480066,\n 0.854924397221087, 0.8481709291032696,\n 0.8498330281159108] \nThe function should use the function alignment_similarity to compare your unknown sequence (unknown_list[0]) to each of the sequences of some subtype. Start out like this:\ndef get_similarities(unknown, typed_sequences):\n    # Your code here...\n    \nIn your function you need to define a list that you can append the similarities you compute to:\nsimilarities = []\nThis is the list of results that your function must return. To compute the similarity between you unknown sequence and each of the sequences of known subtype, you can use your alignment_similarity function inside a for-loop.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>HIV sub-groups</span>"
    ]
  },
  {
    "objectID": "chapters/project/hiv_project/index.html#compute-maximum-similarity-to-each-subtype",
    "href": "chapters/project/hiv_project/index.html#compute-maximum-similarity-to-each-subtype",
    "title": "43  HIV sub-groups",
    "section": "Compute maximum similarity to each subtype",
    "text": "Compute maximum similarity to each subtype\nTo predict the subtype of the unknown HIV sequence you need to compare the unknown sequence to all the sequences of each of the different subtypes. The subtype of the sequence with the highest similarity to your unknown sequence is then our predicted subtype (or our best guess).\nWrite a function get_max_similarities that takes two arguments:\n\nA string, which is your unknown HIV sequence.\nA dictionary, like the one returned by load_typed_sequences.\n\nThe function must return:\n\nA dictionary, in which keys are strings representing each subtype ('A', 'B', 'C', and 'D') and values are floats representing the maximum similarity between the unknown sequence and the sequences of a subtype. The dictionary could look like this (it does not, you need to compute the similarities yourself.):\n\n{'A': 0.89, 'B': 0.95, 'C': 0.82, 'D': 0.99}\nTo get the highest number in a list of numbers, you can use the max function in Python. It works like this:\nnumbers = [3, 8, 53, 12, 7]\nprint(max(numbers))  # prints 53\nFor example, to get the highest similarity between the unknown sequence and sequences in typed_data['A']:\nsubtypeA_similarities = get_similarities(unknown_list[0], typed_data['A'])\nsubtypeA_max = max(subtypeA_similarities)",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>HIV sub-groups</span>"
    ]
  },
  {
    "objectID": "chapters/project/hiv_project/index.html#identify-the-hiv-subtype",
    "href": "chapters/project/hiv_project/index.html#identify-the-hiv-subtype",
    "title": "43  HIV sub-groups",
    "section": "Identify the HIV subtype",
    "text": "Identify the HIV subtype\nNow for the grand finale! You ultimately want to be able to write code like this:\nunknown_list = read_data('unknown_type.txt')\ntyped_data = load_typed_sequences()\nsubtype = predict_subtype(unknown_list[0], typed_data)\nprint(\"Patient HIV is subtype {}\".format(subtype))\nSo all you need now is the predict_subtype function.\nWrite a function predict_subtype that takes two arguments:\n\nA string, which is your unknown HIV sequence.\nA dictionary, like the one returned by load_typed_sequences.\n\nThe function must return:\n\nA string of length one (either 'A', 'B', 'C', or 'D') representing the predicted subtype of your unknown HIV sequence.\n\nThe function should use get_max_similarities to compute the dictionary of max similarities and then extract from that dictionary the key with the highest value (similarity). So the function must return 'A' if the unknown sequence is most similar to a sequence of subtype A, 'B' if the unknown sequence is most similar to a sequence of subtype B and so on.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>HIV sub-groups</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/multiple_alignment.html",
    "href": "chapters/bioinformatics/multiple_alignment.html",
    "title": "44  Multiple alignment",
    "section": "",
    "text": "How hard can it be?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Multiple alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/multiple_alignment.html#heuristic-approaches",
    "href": "chapters/bioinformatics/multiple_alignment.html#heuristic-approaches",
    "title": "44  Multiple alignment",
    "section": "Heuristic approaches",
    "text": "Heuristic approaches\n\nClustalW is the 10’th most cited scientific paper - not just in bioinformatics but in all of science!",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Multiple alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/multiple_alignment.html#do-it-yourself",
    "href": "chapters/bioinformatics/multiple_alignment.html#do-it-yourself",
    "title": "44  Multiple alignment",
    "section": "Do it yourself:",
    "text": "Do it yourself:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Multiple alignment</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/clustering.html",
    "href": "chapters/bioinformatics/clustering.html",
    "title": "45  Clustering of sequences",
    "section": "",
    "text": "UPGMA",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Clustering of sequences</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/clustering.html#neighbor-joining",
    "href": "chapters/bioinformatics/clustering.html#neighbor-joining",
    "title": "45  Clustering of sequences",
    "section": "Neighbor-joining",
    "text": "Neighbor-joining",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Clustering of sequences</span>"
    ]
  },
  {
    "objectID": "chapters/project/seqdist_project/index.html",
    "href": "chapters/project/seqdist_project/index.html",
    "title": "46  Sequence trees",
    "section": "",
    "text": "Measuring sequence distance\nThis chapter is about clustering sequence based on the evolutionary distance between them.\nDownload the files you need for this project:\nhttps://munch-group.org/bioinformatics/supplementary/project_files\nPut the files in a folder dedicated to this project. On most computers you can right-click on the link and choose “Save file as…” or “Download linked file”.\nClustering is based on the distances between all pairs of sequences. So before you can build your tree you must compute those distances and fill them into a table like that in the book. Here we break that task into three parts:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Sequence trees</span>"
    ]
  },
  {
    "objectID": "chapters/project/seqdist_project/index.html#measuring-sequence-distance",
    "href": "chapters/project/seqdist_project/index.html#measuring-sequence-distance",
    "title": "46  Sequence trees",
    "section": "",
    "text": "Compare two sequences\nMake the Jukes-Cantor correction\nGenerate a (lower triangular) distance matrix\n\n\nCompare two sequences\nThe first function you must write is one that finds the proportion of different bases between two sequences:\nWrite a function, sequence_difference, which takes two arguments:\n\nA string, which represents a DNA sequence.\nA string, which represents a DNA sequence of the same length as argument one.\n\nThe function must return:\n\nA float, which represents the proportion of different bases between the two sequences.\n\nExample usage:\nsequence_difference('AAATTAAA', 'AAAAAAAA')\nshould return\n0.25\n\n\nMake the Jukes-Cantor correction\nTo take into account that some substitutions may fall on top of others you must do the Jukes-Cantor correction you read about in the book. The formula is like this:\n\\[ K = -\\frac{3}{4} \\ln(1 - \\frac{4}{3}*D) \\]\nWhere \\(D\\) is the proportion of differences as returned by seqeunce_diff and \\(K\\) is the Jukes-Cantor corrected distance. In the top of seqdistproject.py it already says:\nfrom math import log\nThat line makes the log (logarithm) builtin function from the math python library available to your programme. Try to find its Python documentation to see how you use it.\nWrite a function, jukes_cantor, which takes one argument:\n\nA float, which represents a proportion of different bases between two sequences.\n\nThe function must return:\n\nA float, which represents the Jukes-Cantor corrected distance corresponding the proportion of differences given as argument.\n\nExample usage:\njukes_cantor(0.1)\nshould return\n0.10732563273050497",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Sequence trees</span>"
    ]
  },
  {
    "objectID": "chapters/project/seqdist_project/index.html#lower-triangular-distance-matrices",
    "href": "chapters/project/seqdist_project/index.html#lower-triangular-distance-matrices",
    "title": "46  Sequence trees",
    "section": "Lower triangular distance matrices",
    "text": "Lower triangular distance matrices\nThis project is all about distances between pairs (of sequences), and what would be more natural than to put all the distances in a matrix so you can look up the distance between the sequences with indexes i and j as the matrix element in row i and column j. You already know how matrices can be represented by lists of lists. E.g. a matrix like this:\n0.0  0.1  0.3  0.3  0.1  0.2\n0.1  0.0  0.2  0.4  0.1  0.1\n0.3  0.2  0.0  0.4  0.2  0.3\n0.3  0.4  0.4  0.0  0.2  0.1\n0.1  0.1  0.2  0.2  0.0  0.1\n0.2  0.1   0.3  0.1  0.1 0.0\n\ncan be expressed as a list of lists like this:\n[[0.0, 0.1, 0.3, 0.3, 0.1, 0.2],\n [0.1, 0.0, 0.2, 0.4, 0.1, 0.1],\n [0.3, 0.2, 0.0, 0.4, 0.2, 0.3],\n [0.3, 0.4, 0.4, 0.0, 0.2, 0.1],\n [0.1, 0.1, 0.2, 0.2, 0.0, 0.1],\n [0.2, 0.1, 0.3, 0.1, 0.1, 0.0]]\nNotice how the diagonal is all zeros because these distances represent the distance of a sequence to itself. Also, notice that the part above the diagonal is a mirror the part below the diagonal (in bold). This is all a bit redundant, especially in this project where you will have to reduce the matrix as you group (or cluster) sequences together. We want something nice and lean where we only have the numbers we need – and that is the lower triangular matrix:\n0.1\n0.3 0.2\n0.3 0.4 0.4\n0.1 0.1 0.2 0.2\n0.2 0.1 0.3 0.1 0.1\nIn Python this is still just a list of lists, only, each sublist now has the same length as its index in the big list (E.g. [0.3, 0.2] has index 2 in the list and has length 2):\nmatrix = [[],\n              [0.1],\n              [0.3, 0.2],\n              [0.3, 0.4, 0.4],\n              [0.1, 0.1, 0.2, 0.2],\n              [0.2, 0.1, 0.3, 0.1, 0.1]]\nHere I am just writing it nicely. If you where to print that list of lists it would look like this:\n[[], [0.1], [0.3, 0.2], [0.3, 0.4, 0.4], [0.1, 0.1, 0.2, 0.2], [0.2, 0.1, 0.3, 0.1, 0.1]]\nSay your sequences had names: A, B, C, D, E, and F, then the above data structure represents distances between each pair like this:\nA \nB 0.1\nC 0.3 0.2\nD 0.3 0.4 0.4\nE 0.1 0.1 0.2 0.2\nF 0.2 0.1 0.3 0.1 0.1\n   A   B   C   D   E   F\nThere is only one drawback with this reduced representation of the full square matrix: In the full matrix you can get the distance between the sequences with indexes i and j as both matrix[i][j] and matrix[j][i] because the part above and below the diagonal are the same. Using the lower triangular matrix, you must always use the largest index first. Using the smaller one first will give you an IndexError. So if you want the distance between sequences with index 2 and 4, you must use the bigger index first (as the row index): matrix[4][2].",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Sequence trees</span>"
    ]
  },
  {
    "objectID": "chapters/project/seqdist_project/index.html#generate-a-distance-matrix",
    "href": "chapters/project/seqdist_project/index.html#generate-a-distance-matrix",
    "title": "46  Sequence trees",
    "section": "Generate a distance matrix",
    "text": "Generate a distance matrix\nWrite a function, lower_trian_matrix, which takes one argument:\n\nA list of strings. All strings have equal length and represent DNA sequences.\n\nThe function must return:\n\nA list of lists of floats, which represent the lower triangular matrix of Jukes-Cantor distances between DNA sequences given as argument.\n\nExample usage:\nsequences = ['TAAAAAAAAAAA', \n             'TTAAAAAAAAAA', \n             'AAAAAAAAAAGG', \n             'AAAAAAAAGGGG']\nlower_trian_matrix(sequences)\nhere lower_trian_matrix should return:\n[[], \n [0.08833727674228764], \n [0.30409883108112323, 0.4408399986765892], \n [0.6081976621622466, 0.8239592165010822, 0.18848582121067953]]\nYou should use sequence_difference to compute the proportion of differences between each pair of sequences and jukes_cantor to produce the corrected distance to fill into the matrix.\nStart by figuring out what pairs of indexes you need and then figure out how you can make two nested for-loops generate them. Remember that the length of each sublist is equal to its index in the big list.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Sequence trees</span>"
    ]
  },
  {
    "objectID": "chapters/project/seqdist_project/index.html#clustering",
    "href": "chapters/project/seqdist_project/index.html#clustering",
    "title": "46  Sequence trees",
    "section": "Clustering",
    "text": "Clustering\nNow that you have the distance matrix you are ready for the actual clustering. There are three steps to that:\n\nFind the pair you want to join\nCompute the distances between the joined pair and all other elements (linkage)\nKeep going until you only have one left\n\nDepending on how you choose which pair to join and how you compute the new distances for the joined pair determines what kind of clustering you do. Here we will try a centroid-like linkage called WPGMA. It does not work as well as UPGMA but is a bit easier to implement (you can look up WPGMA on wikipedia).\n\nFind the pair to join\nHere you want to be able to find the pair with the smallest distance. To do that we identify the cell in the matrix with the smallest value:\nWrite a function, find_lowest_cell, which takes one argument:\n\nA list of lists, which represents a lower triangular distance matrix as returned by lower_trian_matrix.\n\nThe function must return:\n\nA list of two integers, which represent the row and column index of the cell with the smallest value in the matrix.\n\nRemember that the row index is always smaller than the column index. The two indexes tell you which two elements to join next.\nExample usage: Assuming that matrix is the lower triangular matrix returned by lower_trian_matrix in the previous example, then\nfind_lowest_cell(matrix)\nShould return\n[1, 0]\n\n\nDecide on a linkage method\nYou also need a function that computes a new distance from two original ones using the the centroid-like linkage we have decided to use.\nWrite a function, link, that takes two arguments:\n\nA float, which represents a matrix element.\nA float, which represents another matrix element.\n\nThe function must return:\n\nA float, which is the average of the two arguments\n\nExample usage:\nlink(0.4, 0.2)\nShould return:\n0.3",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Sequence trees</span>"
    ]
  },
  {
    "objectID": "chapters/project/seqdist_project/index.html#perform-the-clustering",
    "href": "chapters/project/seqdist_project/index.html#perform-the-clustering",
    "title": "46  Sequence trees",
    "section": "Perform the clustering",
    "text": "Perform the clustering\nThe three functions that do the actual clustering are complicated but you should be able to follow what they do. The first one updates the table to reflect that you join a pair. The second updates the list of sequence names (labels) to reflect that you joined a pair. The last one uses the two other functions to cluster pair until there is only one cluster left.\nYour task is to carefully type the code for each function and to understand what every line of code does.\n\nUpdating labels\nThe function update_labels takes three arguments:\n\nA list of strings representing sequence names.\nAn integer representing the index of a sequence name.\nAn integer representing the index of another sequence name.\n\nThe function does not return anything, but it updates the list of names to reflect that you joined a pair. If your list looks like this before you call the function:\nlabels = ['A', 'B', 'C', 'D']\nThen after you call the function like this update_labels(labels, 1, 0), the list will look like this:\n['(A,B)', 'C', 'D']\nHere is the function:\ndef update_labels(labels, i, j):\n\n    # turn the label at first index into a combination of both labels\n    labels[j] = \"({},{})\".format(labels[j], labels[i])\n\n    # Remove the (now redundant) label in the first index\n    del labels[i]\n\n\nUpdating the matrix\nThe function update_table takes three arguments:\n\nA list of lists, which represents a lower triangular distance matrix.\nAn integer representing the index of one of the elements to join.\nAn integer representing the index of the other element to join.\n\nThe way this function is implemented, it is assumed that the second argument is always larger than the third argument. I.e. the second argument is a row index and the third argument is a column index.\nThe function does not return anything, but it updates the matrix to reflect that a pair has been joined. If your matrix looks like this before you call the function:\nm = [[], [0.1], [0.3, 0.4], [0.6, 0.8, 0.2]]\nThen after you call the function like this update_table(m, 1, 0), the matrix will look like this:\n[[], [0.35], [0.7, 0.2]]\nHere is the function:\ndef update_table(table, a, b):\n\n    # For the lower index, reconstruct the entire row (ORANGE)\n    for i in range(0, b):\n        table[b][i] = link(table[b][i], table[a][i])\n\n    # Link cells to update the column above the min cell (BLUE)\n    for i in range(b+1, a):\n        table[i][b] = link(table[i][b], table[a][i])\n        \n    # Link cells to update the column below the min cell (RED)\n    for i in range(a+1, len(table)):\n        table[i][b] = link(table[i][b], table[i][a])\n\n    # Delete cells we no longer need (lighter colors)\n    for i in range(a+1, len(table)):\n        # Remove the (now redundant) first index column entry\n        del table[i][a]\n    # Remove the (now redundant) first index row\n    del table[a] \nThe colors refer to cell colors on the slide you I showed you at the lecture.\n\n\nDo the clustering\nNow onto the real task, the actual clustering. The function cluster takes two arguments:\n\nA list of strings representing DNA sequences of equal length.\nA list of strings representing sequence names.\n\nThe function returns:\n\nA string representing the generated clustering.\n\nHere is the function:\ndef cluster(sequences, names):\n\n    table = lower_trian_matrix(sequences)\n    labels = names[:]\n\n    # Until all labels have been joined...\n    while len(labels) &gt; 1:\n        # Locate lowest cell in the table\n        i, j = find_lowest_cell(table)\n\n        # Join the table on the cell co-ordinates\n        update_table(table, i, j)\n\n        # Update the labels accordingly\n        update_labels(labels, i, j)\n\n    # Return the final label\n    return labels[0]\nHere is a simple example of how you can use your new clustering code:\nnames = ['A', 'B', 'C', 'D']\nsequences = ['TAAAAAAAAAAA', \n             'TTAAAAAAAAAA', \n             'AAAAAAAAAAGG', \n             'AAAAAAAAGGGG']\n\ntree = cluster(sequences, names)\nprint(tree)\n\n\nOn your own\nFrom here on you are on your own. If you find a FASTA file with aligned (ungapped) homologous sequences, you can use the function below to read it into your program and try your code out on real-world sequences. I will leave it to you to figure out how it works.\ndef read_fasta(filename):\n    f = open(filename, 'r')\n    record_list = []\n    header = \"\"\n    sequence = \"\"\n    for line in f:\n        line = line.strip() ## get rid of whitespace and newline\n        if line.startswith(\"&gt;\"):\n            if header != \"\": ## if it is the first header\n                record_list.append([header, sequence])\n                sequence = \"\"\n            header = line[1:]\n        else:\n            sequence += line\n    record_list.append([header, sequence])\n    return record_list",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Sequence trees</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/models_of_dna_evolution.html",
    "href": "chapters/bioinformatics/models_of_dna_evolution.html",
    "title": "47  Models of DNA evolution",
    "section": "",
    "text": "Jukes-Cantor model",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Models of DNA evolution</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/models_of_dna_evolution.html#kimura-two-parameter-model",
    "href": "chapters/bioinformatics/models_of_dna_evolution.html#kimura-two-parameter-model",
    "title": "47  Models of DNA evolution",
    "section": "Kimura two-parameter model",
    "text": "Kimura two-parameter model",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Models of DNA evolution</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/models_of_dna_evolution.html#gtrm",
    "href": "chapters/bioinformatics/models_of_dna_evolution.html#gtrm",
    "title": "47  Models of DNA evolution",
    "section": "GTRM",
    "text": "GTRM",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Models of DNA evolution</span>"
    ]
  },
  {
    "objectID": "chapters/bioinformatics/phylogenetics.html",
    "href": "chapters/bioinformatics/phylogenetics.html",
    "title": "48  Phyogenetics",
    "section": "",
    "text": "Likelihood of a tree",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Phyogenetics</span>"
    ]
  },
  {
    "objectID": "chapters/web/aardwark_seqdist/index.html",
    "href": "chapters/web/aardwark_seqdist/index.html",
    "title": "49  Aardvark?",
    "section": "",
    "text": "Build a FASTA file\n“What is an Aardvark?” You may have bugged you for a while. It might have kept you up at night. You might have been twisting and turning due to the mystery that is the Aardvark. But fear not. Today, you will attempt to answer this exact question. Or at least a part of the question from a phylogenetic perspective. In the process, hopefully, you will learn something about phylogeny. Let’s start with a more straightforward question. “What does the Aardvark look like?”, Figure 49.1.\nThe Aardvark is a nocturnal mammal found in Africa, with the size of a big rottweiler. The long ears and face shape (not considering the nose) make you wonder if it is the long-lost cousin of the kangaroo. It mainly feeds on ants and termites, which might change your mind in regards to its heritage. It could be a type of anteater. Looking at the nose and considering that in Afrikaans, ‘erdvark’ means ‘earth pig’ or ‘ground pig,’ you might change your mind once again and consider it a type of pig. The Aardvark is truly a mystery. So, let’s solve the mystery of the Aardvark’s evolutionary relation to these reference animals! Feel free to look up cute pictures of these animals while you work on the exercises. I have collected a list of animals that I think of when I look at the Aardvark. Have the animals in Figure 49.2 in mind when you do the exercises.\nTo uncover the mystery of the Aardvark and its relation to the reference animals, we will be looking at the evolutionary distance between the animals listed above and the Aardvark. To do so, we need to align sequences from each of the animals. Not any gene will do. We need a highly conserved gene found in all animals, that can represent to long evolutionary distances in question.\nI suggest the COI (cytochrome c oxidase I) gene (also known as the COX1 gene). The COI gene is one of the most popular phylogenetic markers for evaluating evolutionary relationships. It is found in nearly all aerobic eukaryotes, where it encodes Cytochrome C Oxidase subunit 1, a protein involved in mitochondrial respiration.\nCOI is a part of the mitochondrial DNA, which has the added benefit that the gene is inherited from the mother and that it does not undergo recombination. Recombination would make different parts of the aligned sequences follow seperate paths through the generations. Each segment of the alignment would then have its own tree, and we would end up modeling an avarage of many trees with a model that assumes a single tree for the entire sequence. This is obviously not good, but think about how it might bias the resulting phylogeny.\nWe are not the first to think this specific gene would be neat to use for phylogeny. COI has been used for DNA barcoding, which is a method for identifying and classifying species based on their genetics. This also means that this gene has been sequenced for a lot of species, making our job more manageable. It means that we do not need to fly off to some jungle, catch animals, extract DNA, create primers for the COI gene, and sequence each one. We simply look them up in the online database.\nTo investigate the mystery of the Aardvark, you need to collect the sequences of the COI genes of all the reference animals in a way that makes it possible to compare all the gene sequences. A common way to do so is to use FASTA files. FASTA is a file format used for sequences of nucleotides or amino acids that is used by almost all bioinformatic software tools. A FASTA file can contain multiple sequences as long as they are formatted as follows: First, a line starting with “&gt;” followed by an ID and a description of the sequence. This is known as the “header” and is one line only The following lines are the sequence. This can take up as many lines as needed. The sequence is usually split across lines with 60-80 characters on each line. The example below has 70 characters per line. To start a new sequence in the file, simply add a new header, followed by a sequence. Like this:",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Aardvark?</span>"
    ]
  },
  {
    "objectID": "chapters/web/aardwark_seqdist/index.html#build-a-fasta-file",
    "href": "chapters/web/aardwark_seqdist/index.html#build-a-fasta-file",
    "title": "49  Aardvark?",
    "section": "",
    "text": "&gt; ID1 some kind of description\nATGTCTTCTATTAACAGCTCTGAATCGCTTGCTGCTTCGGGAGGAAAGCCTTCTGTTTCCCACGAGTCCT\nTGCCCTATAAAACTGTCACCTACTCCGGAGAAGGCAATGAGTATGTAATTATTGACAACAAAAAATACTT\nGAGGCACGAGTTGATGGCTGCCTTCGGTGGTACCTTCAATCCTGGTTTGGCACC\n&gt; ID2 some other kind of description\nATGTCTTCTATTAACAGCTCTGAATCGCTTGCTGCTTCGGGAGGAAAGCCTTCTGTTTCCCACGAGTCCT\nTGCCCTATAAAACTGTCACCTACTCCGGAGAAGGCAATGAGTATGTAATTATTGACAACAAAAAATACTT\nGAGGCACGAGTTGATGGCTGCCTTCGGTGGTACCTTCAATCCTGGTTTGGCACCCTTTCCTAAGCATCAG\nTTTGGTAACGCTTCTGCCCTAGGTATAGCAGCATTCGCCTTACCGCTTTTAGTGTTGGGCTTGTATAATT\nTGCAAGCCAAAGACATTACAATTCCAAATATGATTGTTGGTTTATGTTTCTTCTACGGTGGTCTTTGTCA\nATTCTTATCTGGACTCTGGGAAATGGTCATGGGAAACACCTTTGCTGCCACTTCCT\n\nExercise 49-1\nNow it is your turn! Make a FASTA file containing the nucleotide sequence of the COI (COX1) gene of all the reference animals and the Aardvark. Use the file “animals.fasta” to insert the nucleotide sequences. You can find the nucleotide sequences in the NCBI Nucleotide database. To search for genes, select “Gene” instead of nucleotide from the drop-down menu. If you where looking for the PRDM9 gene in humans you would, you search like this:\nPRDM9[Gene Name] AND Homo sapiens[Orgn]\nThe [Gene Name] and [Orgn] tags tells the database that “PRDM9” should be interpreted as a gene name, and “Homo sapiens” as an organism. This greatly limits your search and excludes database entries where the same words appear in other contexts. Have a quick look at the complete list of search terms available.\nYou are looking for COX1 and Orycteropus afer is the Latin name for Aardvark. This guides you to the page containing the database information for the COI gene for the specific organism (animal). You can find the gene sequence in a fasta format in the section “NCBI Reference Sequences (RefSeq).” Copy the gene sequence and paste it into the animals.fasta file under the appropriate header. To help you along, here are the Latin names of the animals:\n\n\n\nSpecies\nLatin name\n\n\n\n\nAardvark\nOrycteropus afer\n\n\nGrey Kangaroo\nMacropus giganteus\n\n\nGolden Mole\nEremitalpa granti\n\n\nElephant Shrew\nMacroscelides flavicaudatus\n\n\nRed River Hog\nPotamochoerus porcus\n\n\nCollared anteater\nTamandua tetradactyla\n\n\nAfrican Elephant\nLoxodonta africana\n\n\n\nWe would like to find an animal that can serve as “outgroup” in our analysis. An outgroup is a sequence so distantly related animal to all your other sequences (your “ingroup”) that you can safely assume that all your ingroup sequences find a common ancestor before before they find one with the outgroup sequence (Figure 49.3). The point where the outgroup attaches to the ingroup tree must then be the common ancestor of your ingroup sequences. Since all your subject animals are all live-bearing mammals, you can use the platypus (a monotreme)(Ornithorhynchus anatinus) as the outgroup and add it to your fasta-file.\n\n\n\n\n\n\nFigure 49.3: Ingroup and outgroup in a phylogeny",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Aardvark?</span>"
    ]
  },
  {
    "objectID": "chapters/web/aardwark_seqdist/index.html#one-click-analysis",
    "href": "chapters/web/aardwark_seqdist/index.html#one-click-analysis",
    "title": "49  Aardvark?",
    "section": "One-click analysis",
    "text": "One-click analysis\nNow that you have created a FASTA file with the COI (COX1) gene of the Aardvark and all the reference animals, it is time to look into the evolutionary distances between them. We will be using the web tool www.phylogeny.fr for this exercise. When you do your phylogenetic analyses below, you need to screengrab/save your phylogenetic trees along the way. You should paste them into a document with notes on which models and parameters used for each tree. That way you can compare them all at the end.\n\nExercise 49-2\nGo to www.phylogeny.fr and get aquianted with the web interface. Then navigate to the “one-click” analysis under the “phylogeny analysis” tab. The “one-click” analysis runs an easy initial analysis of your sequences, automating the four steps below with default models and parameters:\n\nMultiple sequences alignment of all the genes in your newly made FASTA file.\nCuration of the aligned sequences in order to eliminate poorly aligned positions (such as trailing nucleotides in cases where one sequence is much longer than the others).\nBuilding of the phylogenetic tree according to evolutionary distances calculated from the curated multiple sequence alignment.\nVisualization of the tree.\n\n\n\nExercise 49-3\nNow that you have navigated to the “one-click” analysis page, you can upload the FASTA file you created in the previous task. Then click submit. The result is a phylogenetic tree describing the evolutionary distances between COI genes of the different animals. Take a good look at it. Does it look anything like what you expected?\n\n\nExercise 49-4\nIf you want to make the tree easier to interpret or to highlight specific relations, you can change the visualization without changing the information in the tree. One way is to reroot the tree. Let’s try it out. First, click on the “Reroot (outgroup)” button below the tree under the section “Select an action and click leaf or internal branch.” Then click on the name “Platypus” and wait for the tree to re-render. Now, look at it again. You can also manipulate the visualization of the tree by, instead of clicking “reroot,” you can click on “Flip” or “Swap.”\n\nWhat does Flip do?\nWhat does Swap do?\nWhat does Reroot do?\n\n\n\nExercise 49-5\nYou have played around with the tree a bit, and now you are ready address what it tells you. Start by clicking on “Reset (cancel all changes)” in the section “Select an action” and follow up by rerooting the tree with Platypus as the outgroup. Now answer the following questions:\n\nHow much does re-rooting change the tree?\nHow many terminal nodes (leaves) and how many internal nodes are there in the tree?\nWhich node represents the most recent common ancestor between the Aardvark and the African Elephant? Which one is the common ancestor between the Aardvark and the Elephant Shrew? Does this hold no matter whether you forced the platypus as the outgroup?\nWhich of the reference animals are closest related to the Aardvark according to this model? Does the tree look like you expected?\n\n\n\nDifferent 49-6\n\n\nExercise 49-7\nThe “one-click” analysis uses the HKY85 substitution model to calculate the phylogenetic distances, but you can choose other models as well. Here is a rundown of the most important ones:\nThe Jukes-Cantor model is one of the simplest nucleotide substitution models. It assumes that all types of nucleotide substitutions (transitions and transversions) occur at an equal rate, meaning that there’s a single rate parameter for all types of substitutions. This is a highly simplified model and is often used as a baseline for comparison with more complex models.\nThe Kimura two-parameter model is a simple model that takes into account two types of substitutions: transitions (purine-to-purine or pyrimidine-to-pyrimidine changes) and transversions (purine-to-pyrimidine or vice versa). It assumes that transitions occur at a different rate (\\(\\alpha\\)) than transversions (\\(\\beta\\)), reflecting the fact that transitions are often more common in DNA evolution.\nThe HKY85 model is a relatively simple model that takes into account two major factors in the evolution of nucleotide sequences: transitions (purine-to-purine or pyrimidine-to-pyrimidine changes) and transversions (purine-to-pyrimidine or vice versa). It assumes that transitions and transversions occur at different rates, which makes it more biologically realistic compared to some simpler models like the Jukes-Cantor model.\nThe GTR model is a more complex and flexible model compared to HKY85. It allows for different substitution rates between all possible pairs of nucleotides, making it a highly general model. This means that it can accommodate variations in the substitution rates of all six possible types of nucleotide changes (A\\(\\leftrightarrow\\)C, A\\(\\leftrightarrow\\)G, A\\(\\leftrightarrow\\)T, C\\(\\leftrightarrow\\)G, C\\(\\leftrightarrow\\)T, G\\(\\leftrightarrow\\)T).\nThe Hamming distance is not a traditional substitution model used for phylogenetics. It is a simple method for comparing sequences of equal length, where it counts the number of positions at which two sequences differ (i.e., the number of substitutions needed to convert one sequence into another). It does not consider the specific types of substitutions (transitions or transversions).\nWhat might be the reason for not alway choosing the model with the largest number of parameters?\n\n\nExercise 49-8\nLet’s explore how the evolutionary distances change when you use other models and also how the different tree construction methods make a difference. You can du this by running the steps from the “one-step” analysis, but change the model of DNA evolution to explore how this affects your results.\nYou will start at step 1: Multiple sequence alignment. You need a multiple alignments of all your sequences. Lucky for you, www.phylogeny.fr has already done that in order to make the tree. Here, the MUSCLE program has been used (MUSCLE is conceptually close to ClustalW). We will not change the alignment method. To access the multiple alignments, click on the tab “3. Alignment”. To see the curated that, click on the tab “4. Curation”. In this tab, the alignment has been curated by the program Gblocks. Gblocks has identified the portions of the alignment suitable for distance calculation and tree-building and has underlined these portions with a dark blue box. You can read more about Gblocks in the Gblocks documentation. Go read the introduction in the Gblocks documentation. What kind of positions are excluded after curation?\nDownload the curated alignment by clicking on “Cured alignment in Phylip format” under the Outputs section. This gives you the equal-length aligned sequences resulting from curation by Gblocks in a phy-file. Go read the introduction in the Gblocks documentation. What kind of positions are NOT included after curation?\n\n\nExercise 49-9\nNow you can see what happens if we use the same alignment same curation, but different evolutionary models to calculate the evolutionary distances. To help you calculate the evolutionary distances, www.phylogeny.fr has some nice options for calculating distance matrices for you. Let’s start by building phylogenetic trees using PhyML.\nPhyML (Phylogenetic Maximum Likelihood) employs a statistical approach (maximum likelihood) to estimate the most likely tree given the input alignment. To Use PhyML, navigate to the top, tap “Online Programmes,” and choose PhyML. Here you can upload your curated alignment in phylip format (the one you downloaded from the curation tab).\nPhyML now lets you choose a substitution model. A substitution model is a mathematical model that describes how genetic sequences change over time. So now you will see how these different models actually affect your tree. Try the two DNA/RNA substitution models for PhyML (HKY58 and GTR). Remember to save your tree by clicking “Tree in newick format” and save the file. These tree files can be visualised by using the program “TreeDyn” under the top tab “Online Programmes”. Do the trees formed by GTR and HKY85 look alike? What are the Aardvark’s closest relatives according to the two trees?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Aardvark?</span>"
    ]
  },
  {
    "objectID": "chapters/web/aardwark_seqdist/index.html#explore-phylogeny---part-3",
    "href": "chapters/web/aardwark_seqdist/index.html#explore-phylogeny---part-3",
    "title": "49  Aardvark?",
    "section": "Explore phylogeny - part 3",
    "text": "Explore phylogeny - part 3\nNot only can you change the substitution model used in calculating the evolutionary distances. You can also use different tree-builders. You just tried PhyML, which uses a maximum likelihood approach. Next, try to use BioNJ. BioNJ stands for “Biased Neighbor Joining,” which is an adaptation of the neighbor-joining algorithm (not currently a part of www.phylogeny.fr). Neighbour Joining is a distance-based tree-building method, and BioNJ uses the same approach, with a slight bias, to avoid errors with particularly long branches. Try the three DNA/RNA substitution models for BioNJ (kimura, jukes-cantor, hamming ). Remember to save your trees. Do these three trees look alike? Do they look like the trees formed by PhyML? What are the Aardvark’s closest relatives according to the three trees?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Aardvark?</span>"
    ]
  },
  {
    "objectID": "chapters/web/aardwark_seqdist/index.html#food-for-thought",
    "href": "chapters/web/aardwark_seqdist/index.html#food-for-thought",
    "title": "49  Aardvark?",
    "section": "Food for thought",
    "text": "Food for thought\nOkay, step back from the Aardvark for a moment. What about the other animals we are looking at? Are their relations always the same? Are some always grouped together while others are always grouped far apart? If you are particularly curious, try to add other types of elephants to the FASTA-file and see how other types of elephants group when doing phylogeny.\nNow, you have looked at the Aardvark and its evolutionary relations with other animals. You have tried many different ways. Are you more confident in your knowledge about the Aardvark, or are you feeling more confused than ever? What of the animals in your analysis is the closest relative of the Aardvark? Does Wikipedia agree with you? (https://en.wikipedia.org/wiki/Aardvark) (Read from the Introduction, Name, and Taxonomy). Do you trust Wikipedia? See if you can find the Aardvark ( Orycteropus afer) in NCBI’s Taxnomy Browser. What does that report its taxonomy?",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Aardvark?</span>"
    ]
  },
  {
    "objectID": "chapters/web/aardwark_seqdist/index.html#project-files",
    "href": "chapters/web/aardwark_seqdist/index.html#project-files",
    "title": "49  Aardvark?",
    "section": "Project files",
    "text": "Project files\nDownload the files you need for this project:\nhttps://munch-group.org/bioinformatics/supplementary/project_files",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Aardvark?</span>"
    ]
  },
  {
    "objectID": "chapters/web/orf_finding/index.html",
    "href": "chapters/web/orf_finding/index.html",
    "title": "50  Plasmid ORFs",
    "section": "",
    "text": "Exercise 50-1\nGene prediction in bacteria is a crucial step in understanding the genetic makeup of these microorganisms. It involves identifying the locations and boundaries of genes within bacterial genomes, essential for studying bacterial physiology and pathogenicity and developing targeted therapies. The main component of bacterial genes is the open reading frame (ORFs), which translates into protein. So, identifying ORFs is the main task in “de novo” prediction of bacterial genes. The most commonly used start codon is ATG, and less frequently, GTG and TTG. Stop codons are either one of TAA, TAG, or TGA. Although the three “reading frames” on each strand allow ORFs to overlap, this is mainly a feature of highly compacted viral genomes and not often observed in bacteria. Promoter and terminator DNA motifs provide additional information usually built into hidden Markov models or neural networks. Such models also asses the coding potential, codon usage, and length of ORFs to distinguish randomly occurring pairs of start and stop codons from those representing genes.\nA bacterial plasmid is a circular, double-stranded DNA molecule separate from the genome found in the cytoplasm of bacteria. It is relatively small, ranging from a few kilobases to several hundred kilobases in size, and replicates autonomously, passing to daughter cells at cell division. Although they are usually not essential to the bacterium’s survival, plasmids often carry genes that can confer selective advantages to the bacteria under certain conditions. Such conditions include exposure to antibacterial agents like the antibiotics used to combat infections, and some plasmids carry genes making the bacterium resistant to such drugs.\nIn this exercise, the bacterial DNA you will investigate is a plasmid extracted from an Enterococcus faecium strain to test if it is responsible for its documented resistance to vancomycin. Vancomycin is used to treat infections of bacteria strains resistant to other antibiotics. Methicillin-resistant Staphylococcus aureus (MRSA) is one such strain. Because vancomycin is considered a “last resort” antibiotic, resistance to this drug is dangerous, and it must monitored carefully.\nYou will use the NCBI’s ORF Finder tool to identify ORFs in the plasmid, and then use various online tools to narrow down the ORFs to a set of likely resistance genes. You can download a fasta file with the plasmid sequence from Brightspace.\nWhen you open up ORF Finder, start by pasting the fasta file into the “Query Sequence” field. Look at the search parameters, but do not change them yet. One parameter controls the minimum ORF length. We can change the expected genetic code, specify alternate start codons, and choose to ignore nested ORFs.\nRun ORF Finder with the default parameters.",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Plasmid ORFs</span>"
    ]
  },
  {
    "objectID": "chapters/web/orf_finding/index.html#project-files",
    "href": "chapters/web/orf_finding/index.html#project-files",
    "title": "50  Plasmid ORFs",
    "section": "Project files",
    "text": "Project files\nDownload the files you need for this project:\n \nhttps://munch-group.org/bioinformatics/supplementary/project_files",
    "crumbs": [
      "Bioinformatics",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Plasmid ORFs</span>"
    ]
  },
  {
    "objectID": "supplementary/project_files.html",
    "href": "supplementary/project_files.html",
    "title": "Project files",
    "section": "",
    "text": "Python projects\nIn each sections below, you will find download links to the files you need for each python project.",
    "crumbs": [
      "Supplementary",
      "Project files"
    ]
  },
  {
    "objectID": "supplementary/project_files.html#web-exercises",
    "href": "supplementary/project_files.html#web-exercises",
    "title": "Project files",
    "section": "Web exercises",
    "text": "Web exercises\nIn each sections below, you will find download links to the files you need for each web exercise.\n\nGWAS\nNone\n\n\nCCR5\n CCR5_CDS.fa   CCR5_CDS_delta32.fa   CCR5_mRNA.fa   CCR5_mRNA_delta32.fa \n\n\nMRSA\nNone\n\n\nAardwark\n animals.fasta \n\n\nORF finding\n Enterococcusfaeciumresistanceplasmidsequence.fa \n\n\nLong reads\n\ncontig_1.bam\ncontig_1.bam.bai\ncontig_1.fa\ncontig_1.fa.fai\n\n\nNeural networks\nNone",
    "crumbs": [
      "Supplementary",
      "Project files"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html",
    "href": "supplementary/recordings2024.html",
    "title": "Lecture recordings",
    "section": "",
    "text": "Week 1",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-1",
    "href": "supplementary/recordings2024.html#week-1",
    "title": "Lecture recordings",
    "section": "",
    "text": "Monday\nUnfortunately, the Monday recording failed :/\n\n\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-2",
    "href": "supplementary/recordings2024.html#week-2",
    "title": "Lecture recordings",
    "section": "Week 2",
    "text": "Week 2\n\nMonday\nThe sound quality is terrible on this one, sorry.\n\n\n\nWednesday\nThe sound quality is terrible on this one, sorry.",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-3",
    "href": "supplementary/recordings2024.html#week-3",
    "title": "Lecture recordings",
    "section": "Week 3",
    "text": "Week 3\n\nMonday\n\n\n\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-4",
    "href": "supplementary/recordings2024.html#week-4",
    "title": "Lecture recordings",
    "section": "Week 4",
    "text": "Week 4\n\nMonday\n\n\n\nWednesday\nThe sound is missing from most of this one. The mic battery ran out…",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-5",
    "href": "supplementary/recordings2024.html#week-5",
    "title": "Lecture recordings",
    "section": "Week 5",
    "text": "Week 5\n\nMonday\nNo recording.\n\n\n\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-6",
    "href": "supplementary/recordings2024.html#week-6",
    "title": "Lecture recordings",
    "section": "Week 6",
    "text": "Week 6\n\nMonday\n\n\n\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-7",
    "href": "supplementary/recordings2024.html#week-7",
    "title": "Lecture recordings",
    "section": "Week 7",
    "text": "Week 7\n\nMonday\n\n\n\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-8",
    "href": "supplementary/recordings2024.html#week-8",
    "title": "Lecture recordings",
    "section": "Week 8",
    "text": "Week 8\n\nMonday\n\n\n\nWednesday\nThis lecture was canceled.",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-9",
    "href": "supplementary/recordings2024.html#week-9",
    "title": "Lecture recordings",
    "section": "Week 9",
    "text": "Week 9\n\nMonday\n\n\n\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-10",
    "href": "supplementary/recordings2024.html#week-10",
    "title": "Lecture recordings",
    "section": "Week 10",
    "text": "Week 10\n\nMonday\n\n\n\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-11",
    "href": "supplementary/recordings2024.html#week-11",
    "title": "Lecture recordings",
    "section": "Week 11",
    "text": "Week 11\n\nMonday\n\n\n\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-12",
    "href": "supplementary/recordings2024.html#week-12",
    "title": "Lecture recordings",
    "section": "Week 12",
    "text": "Week 12\n\nMonday\n\n\n\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/recordings2024.html#week-13",
    "href": "supplementary/recordings2024.html#week-13",
    "title": "Lecture recordings",
    "section": "Week 13",
    "text": "Week 13\n\nMonday",
    "crumbs": [
      "Supplementary",
      "Lecture recordings"
    ]
  },
  {
    "objectID": "supplementary/slides2024.html",
    "href": "supplementary/slides2024.html",
    "title": "Lecture slides",
    "section": "",
    "text": "Week 1\n\nMonday\nWednesday\n\nWeek 2\n\nMonday\nWednesday\n\nWeek 3\n\nMonday\nWednesday\n\nWeek 4\n\nMonday\nWednesday\n\nWeek 5\n\nMonday\nWednesday\n\nWeek 6\n\nMonday\nWednesday\n\nWeek 7\n\nMonday\nWednesday\n\nWeek 8\n\nMonday\nThe Wednesday lecture was canceled.\n\nWeek 9\n\nMonday\nWednesday\n\nWeek 10\n\nMonday\nWednesday\n\nWeek 11\n\nMonday\nWednesday\n\nWeek 12\n\nMonday\nWednesday\n\nWeek 13\n\nMonday\nWednesday\n\nWeek 14\n\nMonday\nWednesday",
    "crumbs": [
      "Supplementary",
      "Lecture slides"
    ]
  },
  {
    "objectID": "supplementary/bioinformatics_resources.html",
    "href": "supplementary/bioinformatics_resources.html",
    "title": "Databases and resources",
    "section": "",
    "text": "Knowledege data bases",
    "crumbs": [
      "Supplementary",
      "Databases and resources"
    ]
  },
  {
    "objectID": "supplementary/bioinformatics_resources.html#do-it-yourself",
    "href": "supplementary/bioinformatics_resources.html#do-it-yourself",
    "title": "Databases and resources",
    "section": "Do it yourself:",
    "text": "Do it yourself:",
    "crumbs": [
      "Supplementary",
      "Databases and resources"
    ]
  },
  {
    "objectID": "assignments.html",
    "href": "assignments.html",
    "title": "Assignments",
    "section": "",
    "text": "Mandatory assignments are handed in through assignments in Brightspace\nInformation about assignments can be found under “Schedule” in the menu bar.",
    "crumbs": [
      "Assignments"
    ]
  },
  {
    "objectID": "exam.html",
    "href": "exam.html",
    "title": "Exam info",
    "section": "",
    "text": "Download the course homepage and Python documentation\nDownload the HTML course website for offline viewing at the exam (unzip once downloaded and double-click index.html).\nDownload the HTML Python documentation for offline viewing at the exam (unzip once downloaded and double-click index.html).",
    "crumbs": [
      "Exam info"
    ]
  },
  {
    "objectID": "exam.html#example-of-exam-assignment",
    "href": "exam.html#example-of-exam-assignment",
    "title": "Exam info",
    "section": "Example of exam assignment",
    "text": "Example of exam assignment\nThere is no test script for this assignment. You need a data file for this assignment, which you can also get below. Your exam assignment will not need any data from input files.",
    "crumbs": [
      "Exam info"
    ]
  },
  {
    "objectID": "exam.html#about-the-written-exam",
    "href": "exam.html#about-the-written-exam",
    "title": "Exam info",
    "section": "About the written exam",
    "text": "About the written exam\n\nInformationen på denne side fremgår også af eksamensopgaven.\n\nEksamensopgave består af to dele, som vægtes lige i bedømmelsen:\n\nEt sæt programmeringsopgaver.\nEt sæt bioinformatikopgaver.",
    "crumbs": [
      "Exam info"
    ]
  },
  {
    "objectID": "exam.html#filer-til-brug-ved-eksamen",
    "href": "exam.html#filer-til-brug-ved-eksamen",
    "title": "Exam info",
    "section": "Filer til brug ved eksamen",
    "text": "Filer til brug ved eksamen\nUdover denne PDF-fil som indeholder eksamensopgaverne, har du også downloaded tre andre filer fra eksamenssystemet, som du skal bruge til at løse eksamensopgaven:\n\nprogexam.py: Det er i denne fil, du skal skrive de Python funktioner, der bedes om i eksamensopgavens programmeringsdel.\ntest_progexam.py: Det er denne fil, du kan bruge til at teste de funktioner du skriver i progexam.py.\nbioinfexam.py: Det er i denne fil, du skriver svarene på eksamensopgavens bioinformatik-del.",
    "crumbs": [
      "Exam info"
    ]
  },
  {
    "objectID": "exam.html#sådan-løser-du-programmeringsopgaverne",
    "href": "exam.html#sådan-løser-du-programmeringsopgaverne",
    "title": "Exam info",
    "section": "Sådan løser du programmeringsopgaverne",
    "text": "Sådan løser du programmeringsopgaverne\nStart med at åbne din terminal og naviger ind i den folder, som eksamenssystemet har lavet på din computer. Der er muligt at folderens navn indeholder mellemrum. For at navigere ind i en folder der indeholder et mellemrum vha. terminalen, kan man skrive starten af folder-navnet og så trykke på Tab. Så fuldendes navnet automatisk. F.eks.: Hvis folderen hedder “Eksamen Bioinf”, kan man skrive: “cd Eksamen og så trykke Tab. Så fuldendes navnet og man kan trykke Enter.\nSom i programmeringsprojekterne fra kurset skriver du din kode i progexam.py og kører koden sådan her:\npython progexam.py\nSom i programmeringsprojekterne i kurset kan du teste din kode sådan her:\npython test_progexam.py\nTest scriptet er tilgængeligt som en hjælp til at teste din kode, men du har selv det fulde ansvar for rigtigheden af din kode.\nDet er tilladt at bruge løsninger af opgaver til at løse senere opgaver. Man må altså gerne kalde tidligere definerede funktioner inde i andre funktioner, man senere bliver bedt om at skrive.\nFølgende er afgørende for at din eksamensbesvarelse kan evalueres korrekt:\n\nHver funktion skal navngives præcis som angivet i opgaven. Funktioner der ikke er navngivet korrekt, regnes som ikke besvarede.\nDet er ikke tilladt importere kode fra andre filer, du har skrevet eller installeret. Det vil sige, at du ikke må bruge import statements i din fil.\nNår du afleverer progexam.py må den kun indeholde definitioner af de funktioner, der er beskrevet i eksamensopgaven. Al kode udenfor funktionsdefinitioner skal slettes inden du afleverer, så sørg for at teste i god tid inden aflevering, om dine funktioner stadig virker, når du sletter sådan ekstra kode.\n\nAllervigtigst: Funktioner der ikke fuldstænding opfylder opgavens beskrivelse regnes som ikke besvarede. Så sørg for at lave dine funktioner færdige, så de klarer alle tests. Hvis ingen af dine funktioner er helt rigtigt besvaret får du ingen point.",
    "crumbs": [
      "Exam info"
    ]
  },
  {
    "objectID": "exam.html#sådan-løser-du-bioinformatikopgaverne",
    "href": "exam.html#sådan-løser-du-bioinformatikopgaverne",
    "title": "Exam info",
    "section": "Sådan løser du bioinformatikopgaverne",
    "text": "Sådan løser du bioinformatikopgaverne\nBioinformatikdelen af eksamensopgaven består af et sæt af opgaver, der hver dækker et emne. Hver opgave indeholder flere delopgaver. Der er tre typer delopgaver:\n\nUdsagn der enten er sande eller falske og som skal besvares med True eller False.\nSpørgsmål der skal besvares med et tal (int eller float).\nSpørgsmål der skal besvares med en tekst streng (f.eks. 'Dette er mit bedste svar')\n\nFilen bioinfexam.py er en Python fil og indeholder en variabel for hver delopgave. For eksempel: den variabel der hører til delopgave tre i emne syv hedder emne_7_del_3. Hver variabel har en default værdi som enten er None eller en tom streng (' '):\nemne_7_del_3 = None\nemne_7_del_4 = ' '\n\nDu besvarer sandt/falsk udsagn ved at udskifte None med enten True eller False.\nDu besvarer tal-spørgsmål ved at udskifte None med et tal.\nDu besvarer tekst-opgaver ved at fylde tekst i den tomme streng.\n\nDet er anført i bioinfexam.py om en delopgave skal besvares med True/False, et tal, eller tekst.\nFølgende er afgørende for at din eksamensbesvarelse kan evalueres korrekt: Delopgaver som ikke er besvaret betragtes som forkert besvarede, så du er bedst tjent med at gætte fremfor ikke at svare.\nI nogle af opgaveemnerne refererer statements til en vist illustration. Alt efter størrelsen på din skærm kan du være nødt til at “zoome ind” på illustrationerne i det program du bruger til at vise denne PDF, ellers kan der være detaljer du ikke kan se.",
    "crumbs": [
      "Exam info"
    ]
  },
  {
    "objectID": "exam.html#sådan-afleverer-du-din-eksamensopgave-i-wiseflow",
    "href": "exam.html#sådan-afleverer-du-din-eksamensopgave-i-wiseflow",
    "title": "Exam info",
    "section": "Sådan afleverer du din eksamensopgave i Wiseflow",
    "text": "Sådan afleverer du din eksamensopgave i Wiseflow\nInden du afleverer, skal du tjekke at progexam.py kun indeholder definitioner af de funktioner der er beskrevet i eksamensopgaven. Hvis du har skrevet yderligere kode for at teste dine funktioner, skal du slette den inden du oplader din fil.\nDu afleverer din eksamensbesvarelse ved at uploade disse to filer til Wiseflow:\n\nprogexam.py skal afleveres som hoveddokument\nbioinfexam.py skal afleveres som bilag.",
    "crumbs": [
      "Exam info"
    ]
  }
]