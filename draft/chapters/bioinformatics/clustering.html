<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>47&nbsp; Clustering of sequences – Bioinformatics and Programming</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/project/seqdist_project/index.html" rel="next">
<link href="../../chapters/project/hiv_project/index.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7348364bef02e149b83741bff427fbde.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-7265a01e67a7770ed9b564cd1d2c99b1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/preface.html">Bioinformatics</a></li><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/clustering.html"><span class="chapter-number">47</span>&nbsp; <span class="chapter-title">Clustering of sequences</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Content</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Exam information</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../curriculum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Curriculum</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Learning Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Preface</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/before_you_begin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Before you begin</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/writing_a_program.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Writing a program</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/dealing_with_values.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dealing with values</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/the_order_of_events.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">The order of events</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/course_tools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Course tools</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/controlling_behavior.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Controlling behavior</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/organizing_your_code.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Organizing code</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/python_values_are_objects.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Values are objects</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/lists.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Lists of things</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/dictionaries.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Pairs of things</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/gluing_values_in_sequence.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Grouping values</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/iteration_over_values.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Iterating values</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/working_with_data_files.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Working with files</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/data_structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Structuring data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/unleash_your_functions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Recursion</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/testing_your_code.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Testing your code</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/your_own_types_of_objects.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Your Own Types of Objects: Python Classes</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/using_code_from_other_files.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Code in other files</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/on_the_shoulders_of_giants.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Giant’s shoulders</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/appendix_bsf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Appendix: PyMol for BSF</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Bioinformatics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Preface</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/association.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Genome-Wide Association Studies: From Statistical Foundations to Clinical Applications</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/gwas_databases/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">GWAS candidates</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/databases.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Databases</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/database_searching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Sequence Database Searching and BLAST</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/translation_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Translating ORFs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/hidden_markov_models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">29</span>&nbsp; <span class="chapter-title">Hidden Markov Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/new_hmm_exercise/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">30</span>&nbsp; <span class="chapter-title">Membrane proteins</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/orf_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">31</span>&nbsp; <span class="chapter-title">Finding genes</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/neural_networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">32</span>&nbsp; <span class="chapter-title">Neural networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/neural_networks/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">33</span>&nbsp; <span class="chapter-title">Neural networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/folding_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">34</span>&nbsp; <span class="chapter-title">Primer analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/assembly_and_mapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">35</span>&nbsp; <span class="chapter-title">Genome Sequencing, Assembly, and Read Mapping</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/assembly_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">36</span>&nbsp; <span class="chapter-title">Genome assembly</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/pairwise_global_alignment.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">37</span>&nbsp; <span class="chapter-title">Pairwise Global Sequence Alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/pairwise_local_alignment.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">38</span>&nbsp; <span class="chapter-title">Pairwise global alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/multiple_alignment.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">39</span>&nbsp; <span class="chapter-title">Multiple Sequence Alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/alignment_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">40</span>&nbsp; <span class="chapter-title">Pairwise alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/ccr5_pwalign/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">41</span>&nbsp; <span class="chapter-title">CCR5-delta32</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/protein_substitution_matrices.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">42</span>&nbsp; <span class="chapter-title">Protein Substitution Matrices</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/database_searching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Sequence Database Searching and BLAST</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/mrsa_blast_multalign/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">44</span>&nbsp; <span class="chapter-title">MRSA</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/hiv_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">45</span>&nbsp; <span class="chapter-title">HIV sub-groups</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/multiple_alignment.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">39</span>&nbsp; <span class="chapter-title">Multiple Sequence Alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/clustering.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">47</span>&nbsp; <span class="chapter-title">Clustering of sequences</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/seqdist_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">48</span>&nbsp; <span class="chapter-title">Sequence trees</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/models_of_dna_evolution.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">49</span>&nbsp; <span class="chapter-title">Models of DNA Evolution</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/phylogenetics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">50</span>&nbsp; <span class="chapter-title">Phylogenetics: Tree-Based Analysis of Evolutionary Relationships</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/aardwark_seqdist/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">51</span>&nbsp; <span class="chapter-title">Aardvark?</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/orf_finding/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">52</span>&nbsp; <span class="chapter-title">Plasmid ORFs</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Supplementary</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/project_files.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Project files</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/recordings2025.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture recordings</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/slides2024.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture slides</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/bioinformatics_resources.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Databases and resources</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../assignments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Assignments</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../exam.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exam info</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/trouble_shooting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Trouble shooting</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#princibles-of-clustering" id="toc-princibles-of-clustering" class="nav-link active" data-scroll-target="#princibles-of-clustering"><span class="header-section-number">48</span> Princibles of clustering</a>
  <ul class="collapse">
  <li><a href="#which-pair-to-cluster-next" id="toc-which-pair-to-cluster-next" class="nav-link" data-scroll-target="#which-pair-to-cluster-next"><span class="header-section-number">48.1</span> Which pair to cluster next</a></li>
  <li><a href="#how-to-computes-distances-from-the-new-cluster" id="toc-how-to-computes-distances-from-the-new-cluster" class="nav-link" data-scroll-target="#how-to-computes-distances-from-the-new-cluster"><span class="header-section-number">48.2</span> How to computes distances from the new cluster</a></li>
  </ul></li>
  <li><a href="#sec-molecularclock" id="toc-sec-molecularclock" class="nav-link" data-scroll-target="#sec-molecularclock"><span class="header-section-number">49</span> Molecular clock</a>
  <ul class="collapse">
  <li><a href="#example-of-wrong-tree-produced-in-absence-of-molecular-clock" id="toc-example-of-wrong-tree-produced-in-absence-of-molecular-clock" class="nav-link" data-scroll-target="#example-of-wrong-tree-produced-in-absence-of-molecular-clock"><span class="header-section-number">49.1</span> Example of wrong tree produced in absence of molecular clock</a></li>
  <li><a href="#sec-upgma" id="toc-sec-upgma" class="nav-link" data-scroll-target="#sec-upgma"><span class="header-section-number">49.2</span> UPGMA</a>
  <ul class="collapse">
  <li><a href="#worked-example-of-upgma-clustering" id="toc-worked-example-of-upgma-clustering" class="nav-link" data-scroll-target="#worked-example-of-upgma-clustering"><span class="header-section-number">49.2.1</span> Worked Example of UPGMA Clustering</a></li>
  </ul></li>
  <li><a href="#sec-upgma" id="toc-sec-upgma" class="nav-link" data-scroll-target="#sec-upgma"><span class="header-section-number">49.3</span> Neighbor-joining</a>
  <ul class="collapse">
  <li><a href="#additive-distances-non-recombining-sequence-ancestry" id="toc-additive-distances-non-recombining-sequence-ancestry" class="nav-link" data-scroll-target="#additive-distances-non-recombining-sequence-ancestry"><span class="header-section-number">49.3.1</span> Additive distances / Non-recombining sequence ancestry</a></li>
  <li><a href="#minimal-evolution-principle" id="toc-minimal-evolution-principle" class="nav-link" data-scroll-target="#minimal-evolution-principle"><span class="header-section-number">49.3.2</span> Minimal evolution principle</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-bootstrap" id="toc-sec-bootstrap" class="nav-link" data-scroll-target="#sec-bootstrap"><span class="header-section-number">50</span> Bootstrap Analysis in Phylogenetic Reconstruction</a>
  <ul class="collapse">
  <li><a href="#statistical-principles-of-bootstrapping" id="toc-statistical-principles-of-bootstrapping" class="nav-link" data-scroll-target="#statistical-principles-of-bootstrapping"><span class="header-section-number">50.1</span> Statistical Principles of Bootstrapping</a></li>
  <li><a href="#bootstrap-assumptions-and-requirements" id="toc-bootstrap-assumptions-and-requirements" class="nav-link" data-scroll-target="#bootstrap-assumptions-and-requirements"><span class="header-section-number">50.2</span> Bootstrap Assumptions and Requirements</a></li>
  <li><a href="#what-bootstrap-values-quantify" id="toc-what-bootstrap-values-quantify" class="nav-link" data-scroll-target="#what-bootstrap-values-quantify"><span class="header-section-number">50.3</span> What Bootstrap Values Quantify</a></li>
  <li><a href="#when-bootstrap-analysis-is-appropriate" id="toc-when-bootstrap-analysis-is-appropriate" class="nav-link" data-scroll-target="#when-bootstrap-analysis-is-appropriate"><span class="header-section-number">50.4</span> When Bootstrap Analysis is Appropriate</a></li>
  <li><a href="#computational-implementation" id="toc-computational-implementation" class="nav-link" data-scroll-target="#computational-implementation"><span class="header-section-number">50.5</span> Computational Implementation</a></li>
  <li><a href="#interpreting-bootstrap-results" id="toc-interpreting-bootstrap-results" class="nav-link" data-scroll-target="#interpreting-bootstrap-results"><span class="header-section-number">50.6</span> Interpreting Bootstrap Results</a></li>
  <li><a href="#advanced-bootstrap-methods" id="toc-advanced-bootstrap-methods" class="nav-link" data-scroll-target="#advanced-bootstrap-methods"><span class="header-section-number">50.7</span> Advanced Bootstrap Methods</a></li>
  </ul></li>
  <li><a href="#applications-and-future-directions" id="toc-applications-and-future-directions" class="nav-link" data-scroll-target="#applications-and-future-directions"><span class="header-section-number">51</span> Applications and Future Directions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/preface.html">Bioinformatics</a></li><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/clustering.html"><span class="chapter-number">47</span>&nbsp; <span class="chapter-title">Clustering of sequences</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-clustering" class="quarto-section-identifier"><span class="chapter-number">47</span>&nbsp; <span class="chapter-title">Clustering of sequences</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In the realm of bioinformatics, clustering represents one of the most fundamental approaches to understanding the evolutionary relationships and functional similarities between biological sequences. Whether we are examining DNA sequences that encode the blueprints of life or protein sequences that carry out cellular functions, the ability to group related sequences together provides invaluable insights into evolution, function, and biological organization. This lecture note explores the comprehensive landscape of sequence clustering, from its theoretical foundations to practical applications in modern genomics and proteomics.</p>
<p>The importance of sequence clustering cannot be overstated in contemporary biological research. As sequencing technologies continue to advance at an unprecedented pace, researchers are confronted with enormous databases containing millions of sequences. The human genome alone contains approximately 3 billion base pairs, and when we consider the diversity of life on Earth, the amount of sequence data becomes truly astronomical. Clustering provides a systematic approach to organize, analyze, and interpret this vast biological information, enabling scientists to identify patterns, predict functions, and trace evolutionary histories.</p>
<p>At its core, sequence clustering is about finding meaningful relationships in biological data. When we cluster DNA sequences, we might be looking for genes that share common evolutionary origins, regulatory elements that control similar biological processes, or sequences that have been horizontally transferred between organisms. For protein sequences, clustering can reveal functional domains, identify protein families, and predict the three-dimensional structures and functions of newly discovered proteins. These applications extend far beyond academic curiosity – they directly impact drug discovery, disease diagnosis, agricultural improvements, and our fundamental understanding of life itself.</p>
<p>The process of clustering sequences involves multiple interconnected concepts from biology, mathematics, and computer science. We must consider how to measure similarity between sequences, which mathematical models best represent evolutionary processes, and how to efficiently compute relationships among potentially millions of sequences. This interdisciplinary nature makes sequence clustering both challenging and intellectually rewarding, requiring practitioners to bridge multiple fields of knowledge.</p>
<section id="princibles-of-clustering" class="level1" data-number="48">
<h1 data-number="48"><span class="header-section-number">48</span> Princibles of clustering</h1>
<p>The fundamental principles underlying sequence clustering rest on the assumption that similarity in sequence reflects similarity in function and evolutionary origin. This assumption, while generally valid, requires careful consideration of the biological context and the specific goals of the analysis. The principles of clustering guide us in making decisions about how to group sequences, what criteria to use for similarity assessment, and how to interpret the resulting clusters in biological terms.</p>
<p>Distance metrics form the foundation of clustering algorithms. In the context of biological sequences, distance can be measured in various ways, each with its own biological interpretation and computational implications. The simplest approach might count the number of positions where two sequences differ, known as the Hamming distance. However, this approach treats all changes equally, ignoring the biological reality that some mutations are more likely than others. For example, transitions (purine to purine or pyrimidine to pyrimidine changes) occur more frequently than transversions in DNA sequences, and certain amino acid substitutions are more conservative than others in proteins.</p>
<p>More sophisticated distance measures incorporate evolutionary models that account for these biological realities. The Jukes-Cantor model, one of the simplest, assumes equal rates of substitution between all nucleotides but corrects for multiple substitutions at the same site. The Kimura two-parameter model distinguishes between transitions and transversions, while more complex models like the General Time Reversible (GTR) model allow for different substitution rates between all pairs of nucleotides. For protein sequences, matrices like PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) encode empirically observed substitution frequencies, providing biologically meaningful distance measures.</p>
<p>The choice of clustering algorithm profoundly impacts the results and their interpretation. Hierarchical clustering methods, which build tree-like structures (dendrograms) showing relationships at multiple levels of granularity, are particularly popular in biological applications because they naturally represent evolutionary relationships. These methods can be agglomerative, starting with individual sequences and progressively merging them into larger clusters, or divisive, starting with all sequences in one cluster and recursively splitting them. Non-hierarchical methods, such as k-means clustering, partition sequences into a predetermined number of clusters without imposing a hierarchical structure, which can be useful when the goal is to identify functional groups rather than evolutionary relationships.</p>
<p>The concept of homology plays a central role in sequence clustering. Homologous sequences share a common evolutionary ancestor, and identifying homology is often the primary goal of clustering analyses. However, homology is not directly observable – we infer it from sequence similarity. This inference becomes complicated by the fact that sequences can be similar due to convergent evolution (homoplasy) rather than common ancestry. Furthermore, the relationship between sequence similarity and homology is not linear; sequences with less than 20-30% identity can still be homologous, while sequences with higher similarity might have arisen independently.</p>
<p>Alignment quality significantly affects clustering results. Before sequences can be clustered, they must be aligned to identify corresponding positions. For closely related sequences, this alignment is straightforward, but for distantly related sequences, alignment becomes challenging and uncertain. Multiple sequence alignment algorithms must balance biological accuracy with computational efficiency, particularly when dealing with large datasets. Progressive alignment methods, which align sequences in the order determined by a guide tree, are commonly used but can propagate early errors throughout the alignment. Iterative refinement methods can improve alignment quality but at increased computational cost.</p>
<section id="which-pair-to-cluster-next" class="level2" data-number="48.1">
<h2 data-number="48.1" class="anchored" data-anchor-id="which-pair-to-cluster-next"><span class="header-section-number">48.1</span> Which pair to cluster next</h2>
<p>The decision of which sequences or clusters to merge at each step is crucial in hierarchical clustering algorithms. This decision is based on a linkage criterion that defines the distance between clusters based on the distances between their constituent sequences. The choice of linkage criterion can dramatically affect the resulting cluster structure and its biological interpretation.</p>
<p>Single linkage clustering, also known as nearest-neighbor clustering, defines the distance between two clusters as the minimum distance between any pair of sequences, one from each cluster. This approach tends to produce elongated clusters and can suffer from “chaining,” where clusters grow by progressively adding sequences that are similar to the most recently added member but potentially quite different from early members. In biological contexts, single linkage can be useful for identifying sequences connected by a series of intermediates, such as in studying protein evolution through gene duplication and divergence.</p>
<p>Complete linkage clustering, or furthest-neighbor clustering, uses the maximum distance between sequences in different clusters. This approach tends to produce compact, spherical clusters and is less susceptible to chaining than single linkage. However, complete linkage can be overly conservative, failing to group sequences that share clear evolutionary relationships but have diverged significantly in some regions. This method might be appropriate when the goal is to identify tight functional groups where all members maintain high similarity.</p>
<p>Average linkage clustering computes the mean distance between all pairs of sequences in different clusters. This approach, which includes variants like UPGMA (Unweighted Pair Group Method with Arithmetic Mean) and WPGMA (Weighted Pair Group Method with Arithmetic Mean), provides a balance between the extremes of single and complete linkage. UPGMA, in particular, has been widely used in phylogenetic analysis, though its assumption of a constant evolutionary rate (molecular clock) can lead to incorrect trees when this assumption is violated.</p>
<p>Ward’s method, another popular linkage criterion, minimizes the within-cluster variance when merging clusters. This approach tends to produce clusters of similar size and is particularly effective when the true clusters in the data have roughly equal variance. In biological applications, Ward’s method can be useful for identifying functional modules in protein families or gene expression data, where we expect relatively homogeneous groups.</p>
<p>The choice of linkage criterion should be guided by both the biological question and the characteristics of the data. For evolutionary studies, methods that respect the tree-like nature of descent with modification are preferred. For functional classification, methods that produce compact, well-separated clusters might be more appropriate. It’s often valuable to try multiple linkage criteria and compare the results, as consistent patterns across methods provide stronger evidence for genuine biological relationships.</p>
</section>
<section id="how-to-computes-distances-from-the-new-cluster" class="level2" data-number="48.2">
<h2 data-number="48.2" class="anchored" data-anchor-id="how-to-computes-distances-from-the-new-cluster"><span class="header-section-number">48.2</span> How to computes distances from the new cluster</h2>
<p>Once two sequences or clusters have been merged, we need a method to compute distances from this new cluster to all remaining sequences and clusters. This computation must be efficient, as it will be performed many times during the clustering process, and it should preserve the biological meaning of the distances.</p>
<p>In UPGMA, the distance from a new cluster to any other cluster is computed as the arithmetic mean of all pairwise distances between sequences in the two clusters. If cluster <span class="math inline">\(C\)</span> is formed by merging clusters <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, and we want to compute the distance to cluster <span class="math inline">\(D\)</span>, we use the formula:</p>
<p><span class="math display">\[d(C,D) = \frac{n_A \times d(A,D) + n_B \times d(B,D)}{n_A + n_B}\]</span></p>
<p>Let’s break down this formula: - <span class="math inline">\(n_A\)</span> = number of sequences in cluster <span class="math inline">\(A\)</span> - <span class="math inline">\(n_B\)</span> = number of sequences in cluster <span class="math inline">\(B\)</span> - <span class="math inline">\(d(A,D)\)</span> = distance between clusters <span class="math inline">\(A\)</span> and <span class="math inline">\(D\)</span> - <span class="math inline">\(d(B,D)\)</span> = distance between clusters <span class="math inline">\(B\)</span> and <span class="math inline">\(D\)</span></p>
<p>The numerator <span class="math inline">\(n_A \times d(A,D) + n_B \times d(B,D)\)</span> represents the sum of all pairwise distances between sequences in the merged cluster and cluster <span class="math inline">\(D\)</span>. The denominator <span class="math inline">\(n_A + n_B\)</span> is the total number of sequences in the new cluster <span class="math inline">\(C\)</span>. This formula ensures that each original sequence contributes equally to the averaged distance, maintaining the unweighted nature of the method.</p>
<p>For example, if cluster <span class="math inline">\(A\)</span> contains 3 sequences, cluster <span class="math inline">\(B\)</span> contains 2 sequences, <span class="math inline">\(d(A,D) = 0.4\)</span>, and <span class="math inline">\(d(B,D) = 0.6\)</span>:</p>
<p><span class="math display">\[d(C,D) = \frac{3 \times 0.4 + 2 \times 0.6}{3 + 2} = \frac{1.2 + 1.2}{5} = \frac{2.4}{5} = 0.48\]</span></p>
<p>The WPGMA method modifies this calculation by giving equal weight to the two subclusters being merged, regardless of how many sequences each contains. The formula becomes:</p>
<p><span class="math display">\[d(C,D) = \frac{d(A,D) + d(B,D)}{2}\]</span></p>
<p>Using the same example values as above: <span class="math display">\[d(C,D) = \frac{0.4 + 0.6}{2} = \frac{1.0}{2} = 0.5\]</span></p>
<p>Note how WPGMA gives a different result (0.5) compared to UPGMA (0.48) because it doesn’t account for the different sizes of clusters <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. This can be interpreted as giving more recent speciation events greater influence on the computed distances, which might be appropriate if recent evolutionary changes are of particular interest.</p>
<p>For neighbor-joining, a more sophisticated approach is used that doesn’t assume a molecular clock. The algorithm maintains a matrix of distances and iteratively selects the pair of sequences that minimizes the total branch length of the tree. When clusters are merged, new distances are computed using a formula that accounts for the evolutionary distance along each branch, allowing for different rates of evolution in different lineages. The specific formula involves corrections for the average divergence of each taxon from all others, ensuring that the method remains consistent even when evolutionary rates vary.</p>
<p>The computational efficiency of distance updates is crucial for practical applications. Naive implementations that recompute all distances from scratch have O(n³) complexity for n sequences, which becomes prohibitive for large datasets. Efficient implementations maintain auxiliary data structures that allow distance updates in O(n²) time, making it feasible to cluster thousands of sequences. For even larger datasets, approximate methods or sampling strategies may be necessary.</p>
<p>The Lance-Williams formula provides a general framework for updating distances in hierarchical clustering. This formula expresses the distance from a new cluster to any other cluster as a linear combination of the distances from the constituent clusters, with coefficients that depend on the specific linkage criterion. Understanding this formula helps in implementing efficient clustering algorithms and in developing new linkage criteria tailored to specific biological questions.</p>
</section>
</section>
<section id="sec-molecularclock" class="level1" data-number="49">
<h1 data-number="49"><span class="header-section-number">49</span> Molecular clock</h1>
<p>The molecular clock hypothesis, proposed by Emile Zuckerkandl and Linus Pauling in the 1960s, suggests that genetic mutations accumulate at a roughly constant rate over evolutionary time. This concept has profound implications for sequence clustering and phylogenetic reconstruction, as it allows us to not only determine relationships between sequences but also estimate the timing of evolutionary events.</p>
<p>The molecular clock hypothesis is based on the observation that many mutations are selectively neutral – they neither benefit nor harm the organism. These neutral mutations accumulate randomly over time, and if the mutation rate is constant, the number of differences between two sequences should be proportional to the time since they diverged from a common ancestor. This principle allows us to use sequence differences as a “molecular chronometer” to date evolutionary events.</p>
<p>However, the assumption of a constant molecular clock is often violated in real biological systems. Different lineages can evolve at different rates due to factors such as generation time, metabolic rate, DNA repair efficiency, and selective pressures. For example, rodents generally evolve faster than primates at the molecular level, possibly due to their shorter generation times. Similarly, genes under strong selective pressure may evolve at different rates than neutrally evolving sequences.</p>
<p>The validity of the molecular clock assumption has important consequences for clustering algorithms. Methods like UPGMA explicitly assume a molecular clock, which means they assume that all sequences have evolved for the same amount of time from their common ancestor. This assumption leads to the expectation that all contemporary sequences should be equidistant from their common ancestor, a property called ultrametricity. When this assumption is violated, UPGMA can produce incorrect tree topologies that misrepresent the true evolutionary relationships.</p>
<p>Testing for the presence of a molecular clock involves statistical approaches that compare the fit of clock-constrained and unconstrained models to the data. The likelihood ratio test compares the likelihood of the data under a model that enforces a molecular clock with the likelihood under a model that allows different rates in different lineages. Significant differences indicate that the molecular clock hypothesis should be rejected. Other tests, such as Tajima’s relative rate test, compare the evolutionary rates between lineages without requiring an outgroup.</p>
<p>When a strict molecular clock is rejected, several alternatives can be considered. Local molecular clocks allow different rates in different parts of the tree while maintaining constant rates within specific clades. Relaxed molecular clocks allow rates to vary continuously across the tree according to some statistical distribution, such as a lognormal or gamma distribution. These models can be incorporated into Bayesian phylogenetic methods that simultaneously estimate tree topology, branch lengths, and rate variation.</p>
<section id="example-of-wrong-tree-produced-in-absence-of-molecular-clock" class="level2" data-number="49.1">
<h2 data-number="49.1" class="anchored" data-anchor-id="example-of-wrong-tree-produced-in-absence-of-molecular-clock"><span class="header-section-number">49.1</span> Example of wrong tree produced in absence of molecular clock</h2>
<p>To understand how violation of the molecular clock assumption can lead to incorrect phylogenetic trees, consider a scenario with four species: A, B, C, and D. Suppose the true evolutionary history is ((A,B),(C,D)), meaning A and B share a more recent common ancestor with each other than with C or D, and likewise for C and D. However, imagine that after the split between the (A,B) and (C,D) lineages, species C experienced a dramatically increased rate of evolution, perhaps due to a change in DNA repair mechanisms or intense selective pressure.</p>
<p>As a result of this rate variation, species C accumulates many more mutations than the other species. When we measure pairwise distances, we might observe:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Species Pair</th>
<th>Distance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(d(A,B)\)</span></td>
<td>10</td>
</tr>
<tr class="even">
<td><span class="math inline">\(d(C,D)\)</span></td>
<td>30</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(d(A,C)\)</span></td>
<td>40</td>
</tr>
<tr class="even">
<td><span class="math inline">\(d(A,D)\)</span></td>
<td>25</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(d(B,C)\)</span></td>
<td>42</td>
</tr>
<tr class="even">
<td><span class="math inline">\(d(B,D)\)</span></td>
<td>27</td>
</tr>
</tbody>
</table>
<p>Using UPGMA, which assumes all species have evolved for the same amount of time, let’s trace through the clustering process:</p>
<p><strong>Step 1:</strong> Find the minimum distance - Minimum is <span class="math inline">\(d(A,B) = 10\)</span> - Cluster A and B together to form cluster (A,B) - Height in dendrogram = <span class="math inline">\(10/2 = 5\)</span></p>
<p><strong>Step 2:</strong> Calculate new distances to cluster (A,B) Using the UPGMA formula with <span class="math inline">\(n_A = n_B = 1\)</span>:</p>
<p><span class="math display">\[d((A,B),C) = \frac{1 \times d(A,C) + 1 \times d(B,C)}{1 + 1} = \frac{40 + 42}{2} = \frac{82}{2} = 41\]</span></p>
<p><span class="math display">\[d((A,B),D) = \frac{1 \times d(A,D) + 1 \times d(B,D)}{1 + 1} = \frac{25 + 27}{2} = \frac{52}{2} = 26\]</span></p>
<p>The remaining distance <span class="math inline">\(d(C,D) = 30\)</span>.</p>
<p><strong>Step 3:</strong> Find the next minimum distance - Comparing: <span class="math inline">\(d((A,B),C) = 41\)</span>, <span class="math inline">\(d((A,B),D) = 26\)</span>, <span class="math inline">\(d(C,D) = 30\)</span> - Minimum is <span class="math inline">\(d((A,B),D) = 26\)</span> - Cluster (A,B) with D to form ((A,B),D) - Height = <span class="math inline">\(26/2 = 13\)</span></p>
<p><strong>Step 4:</strong> Final clustering - Only C remains to be added - Final tree topology: (((A,B),D),C)</p>
<p>This produces the incorrect topology (((A,B),D),C), suggesting that D is more closely related to A and B than to C, when the true topology should be ((A,B),(C,D)).</p>
<p>The error arises because UPGMA interprets the large distances to C as indicating ancient divergence, when in fact they reflect rapid evolution in the C lineage. This phenomenon, known as long-branch attraction in a different context, demonstrates how rate variation can mislead clustering algorithms that assume a molecular clock. The correct tree would be recovered by methods that don’t assume a molecular clock, such as neighbor-joining or maximum likelihood methods.</p>
<p>This example illustrates a general principle: when evolutionary rates vary significantly among lineages, methods that assume a molecular clock will tend to group slowly-evolving lineages together, regardless of their true evolutionary relationships. This can lead to systematic biases in phylogenetic reconstruction, particularly when studying groups that have experienced different selective pressures or have different biological characteristics affecting their mutation rates.</p>
<p>Real-world examples of molecular clock violations abound. The evolution of HIV shows extreme rate variation, with some lineages evolving orders of magnitude faster than others due to differences in immune pressure and transmission dynamics. In mammals, the lineage leading to modern rodents shows accelerated evolution compared to primates, affecting everything from phylogenetic reconstruction to estimates of divergence times. Understanding these violations is crucial for choosing appropriate clustering methods and interpreting their results correctly.</p>
</section>
<section id="sec-upgma" class="level2" data-number="49.2">
<h2 data-number="49.2" class="anchored" data-anchor-id="sec-upgma"><span class="header-section-number">49.2</span> UPGMA</h2>
<p>UPGMA (Unweighted Pair Group Method with Arithmetic Mean) is one of the oldest and simplest hierarchical clustering methods used in bioinformatics. Despite its limitations, particularly the assumption of a molecular clock, UPGMA remains widely used due to its simplicity, computational efficiency, and ease of interpretation. Understanding UPGMA provides a foundation for appreciating more sophisticated clustering methods.</p>
<p>The UPGMA algorithm begins with each sequence as its own cluster and a matrix of pairwise distances between all sequences. At each iteration, it identifies the pair of clusters with the smallest distance and merges them into a new cluster. The height of the merge in the dendrogram is set to half the distance between the merged clusters, reflecting the assumption that both lineages have evolved for equal time from their common ancestor. Distances from the new cluster to all other clusters are computed as the arithmetic mean of the constituent distances, and the process repeats until all sequences are in a single cluster.</p>
<p>The mathematical formulation of UPGMA distance updates is straightforward. If clusters <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are merged to form cluster <span class="math inline">\(k\)</span>, and we need to compute the distance from <span class="math inline">\(k\)</span> to another cluster <span class="math inline">\(l\)</span>, we use:</p>
<p><span class="math display">\[d(k,l) = \frac{n_i \times d(i,l) + n_j \times d(j,l)}{n_i + n_j}\]</span></p>
<p>Where: - <span class="math inline">\(n_i\)</span> = number of sequences in cluster <span class="math inline">\(i\)</span> - <span class="math inline">\(n_j\)</span> = number of sequences in cluster <span class="math inline">\(j\)</span> - <span class="math inline">\(d(i,l)\)</span> = distance between clusters <span class="math inline">\(i\)</span> and <span class="math inline">\(l\)</span> - <span class="math inline">\(d(j,l)\)</span> = distance between clusters <span class="math inline">\(j\)</span> and <span class="math inline">\(l\)</span></p>
<p>This formula ensures that each original sequence contributes equally to the averaged distance, maintaining the unweighted nature of the method. The logic is that we’re computing a weighted average where the weights are the cluster sizes.</p>
<p>UPGMA’s assumption of a molecular clock leads to ultrametric trees, where the distance from the root to any leaf is constant. This property can be tested in real data; if the distances satisfy the ultrametric inequality (for any three sequences, the two largest distances are equal), then UPGMA will correctly recover the tree topology. However, real biological data rarely satisfies this condition perfectly, and the degree of deviation from ultrametricity indicates how poorly the molecular clock assumption fits the data.</p>
<p>The computational efficiency of UPGMA makes it attractive for large-scale analyses. With appropriate data structures, UPGMA can be implemented to run in O(n²) time for n sequences, compared to O(n³) for naive implementations. This efficiency, combined with its deterministic nature (always producing the same tree for given data), makes UPGMA useful for initial explorations of large sequence datasets, even when its assumptions are not perfectly met.</p>
<p>Despite its limitations, UPGMA has practical applications where its assumptions are reasonable. For closely related sequences that have diverged recently, rate variation may be minimal, making UPGMA appropriate. In studies of viral quasispecies within a single host, where all sequences have evolved for approximately the same time, UPGMA can provide meaningful clusters. The method is also useful as a starting point for more sophisticated analyses, providing an initial tree that can be refined using methods that relax the molecular clock assumption.</p>
<section id="worked-example-of-upgma-clustering" class="level3" data-number="49.2.1">
<h3 data-number="49.2.1" class="anchored" data-anchor-id="worked-example-of-upgma-clustering"><span class="header-section-number">49.2.1</span> Worked Example of UPGMA Clustering</h3>
<p>To illustrate the UPGMA algorithm in action, let’s work through a complete example with six sequences (A, B, C, D, E, F) and their pairwise distances. This example demonstrates how the distance matrix is progressively reduced and how the dendrogram is built step by step.</p>
<div id="fig-upgma-example" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-upgma-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/upgma-template-figure.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-upgma-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;49.1: Step-by-step UPGMA clustering process. The figure shows the progressive reduction of the distance matrix and simultaneous construction of the dendrogram through five steps (panels A-E). In each panel, the left side shows the current distance matrix with the minimum distance highlighted in red, newly formed clusters labeled with letters (V, W, X, Y, Z), and previously merged elements shown with colored backgrounds. The right side shows the growing dendrogram with height scale from 0 to 4, where merge heights equal half the distance between clusters being joined. Panel (A) shows the initial 6×6 distance matrix with d(A,D)=1 as the minimum. Panel (B) shows the 5×5 matrix after merging A and D into cluster V. Panel (C) shows the 4×4 matrix after merging V and E into cluster W. Panel (D) shows the 3×3 matrix after merging B and F into cluster X. Panel (E) shows the final 2×2 matrix and complete dendrogram after all sequences have been clustered. The final tree topology is (((A,D),E),(B,F),C) with C as the outgroup joining at the highest level.
</figcaption>
</figure>
</div>
<p><strong>Step 1: Initial Distance Matrix</strong> We begin with the complete distance matrix shown in panel (A) of <a href="#fig-upgma-example" class="quarto-xref">Figure&nbsp;<span>49.1</span></a>:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>-</td>
<td>6</td>
<td>8</td>
<td>1</td>
<td>2</td>
<td>6</td>
</tr>
<tr class="even">
<td>B</td>
<td></td>
<td>-</td>
<td>8</td>
<td>6</td>
<td>6</td>
<td>4</td>
</tr>
<tr class="odd">
<td>C</td>
<td></td>
<td></td>
<td>-</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr class="even">
<td>D</td>
<td></td>
<td></td>
<td></td>
<td>-</td>
<td>2</td>
<td>6</td>
</tr>
<tr class="odd">
<td>E</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>-</td>
<td>6</td>
</tr>
<tr class="even">
<td>F</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>-</td>
</tr>
</tbody>
</table>
<p>The smallest distance is <span class="math inline">\(d(A,D) = 1\)</span>. Therefore, we cluster A and D together to form a new cluster V = (A,D). The height of this merge in the dendrogram is <span class="math inline">\(1/2 = 0.5\)</span>.</p>
<p><strong>Step 2: Computing Distances to Cluster V</strong> Panel (B) of <a href="#fig-upgma-example" class="quarto-xref">Figure&nbsp;<span>49.1</span></a> shows the reduced matrix after clustering A and D. We need to compute distances from the new cluster V to all remaining sequences using the UPGMA formula. Since both A and D are single sequences, <span class="math inline">\(n_A = n_D = 1\)</span>:</p>
<p><span class="math display">\[d(V,B) = \frac{1 \times d(A,B) + 1 \times d(D,B)}{1 + 1} = \frac{6 + 6}{2} = 6\]</span></p>
<p><span class="math display">\[d(V,C) = \frac{1 \times d(A,C) + 1 \times d(D,C)}{1 + 1} = \frac{8 + 8}{2} = 8\]</span></p>
<p><span class="math display">\[d(V,E) = \frac{1 \times d(A,E) + 1 \times d(D,E)}{1 + 1} = \frac{2 + 2}{2} = 2\]</span></p>
<p><span class="math display">\[d(V,F) = \frac{1 \times d(A,F) + 1 \times d(D,F)}{1 + 1} = \frac{6 + 6}{2} = 6\]</span></p>
<p>The smallest distance in the new matrix is <span class="math inline">\(d(V,E) = 2\)</span>. We cluster V and E to form W = ((A,D),E) at height <span class="math inline">\(2/2 = 1\)</span>.</p>
<p><strong>Step 3: Computing Distances to Cluster W</strong> Panel (C) of <a href="#fig-upgma-example" class="quarto-xref">Figure&nbsp;<span>49.1</span></a> shows the matrix after forming cluster W = ((A,D),E). Since cluster V contained 2 sequences (A and D) and E is a single sequence, we use <span class="math inline">\(n_V = 2\)</span> and <span class="math inline">\(n_E = 1\)</span> in our calculations:</p>
<p><span class="math display">\[d(W,B) = \frac{2 \times d(V,B) + 1 \times d(E,B)}{2 + 1} = \frac{2 \times 6 + 1 \times 6}{3} = \frac{18}{3} = 6\]</span></p>
<p><span class="math display">\[d(W,C) = \frac{2 \times d(V,C) + 1 \times d(E,C)}{2 + 1} = \frac{2 \times 8 + 1 \times 8}{3} = \frac{24}{3} = 8\]</span></p>
<p><span class="math display">\[d(W,F) = \frac{2 \times d(V,F) + 1 \times d(E,F)}{2 + 1} = \frac{2 \times 6 + 1 \times 6}{3} = \frac{18}{3} = 6\]</span></p>
<p>The smallest distance is <span class="math inline">\(d(B,F) = 4\)</span>. We cluster B and F to form X = (B,F) at height <span class="math inline">\(4/2 = 2\)</span>.</p>
<p><strong>Step 4: Computing Distances Between Three Clusters</strong> Panel (D) of <a href="#fig-upgma-example" class="quarto-xref">Figure&nbsp;<span>49.1</span></a> shows the matrix with three clusters: W (containing A, D, E), X (containing B, F), and C. We compute the distance between W and X using the fact that B and F were both single sequences when merged:</p>
<p><span class="math display">\[d(W,X) = \frac{1 \times d(W,B) + 1 \times d(W,F)}{1 + 1} = \frac{6 + 6}{2} = 6\]</span></p>
<p>Similarly, for the distance between C and X:</p>
<p><span class="math display">\[d(C,X) = \frac{1 \times d(C,B) + 1 \times d(C,F)}{1 + 1} = \frac{8 + 8}{2} = 8\]</span></p>
<p>The smallest distance is <span class="math inline">\(d(W,X) = 6\)</span>. We cluster W and X to form Y = (((A,D),E),(B,F)) at height <span class="math inline">\(6/2 = 3\)</span>.</p>
<p><strong>Step 5: Final Clustering</strong> Panel (E) of <a href="#fig-upgma-example" class="quarto-xref">Figure&nbsp;<span>49.1</span></a> shows the final step with only two clusters remaining: Y and C. The distance between them is 8, so they merge at height <span class="math inline">\(8/2 = 4\)</span>.</p>
<p>The complete UPGMA tree shows the hierarchical clustering with merge heights: - A and D merge at height 0.5 - (A,D) and E merge at height 1 - B and F merge at height 2 - ((A,D),E) and (B,F) merge at height 3 - (((A,D),E),(B,F)) and C merge at height 4</p>
<p>This example illustrates several key features of UPGMA: the algorithm always selects the minimum distance at each step, the merge height equals half the distance (assuming a molecular clock), and the distance calculations use weighted averages based on cluster sizes to maintain the unweighted nature of the method.</p>
</section>
</section>
<section id="sec-upgma" class="level2" data-number="49.3">
<h2 data-number="49.3" class="anchored" data-anchor-id="sec-upgma"><span class="header-section-number">49.3</span> Neighbor-joining</h2>
<p>Neighbor-joining (NJ), developed by Naruya Saitou and Masatoshi Nei in 1987, represents a major advance in phylogenetic reconstruction methods. Unlike UPGMA, neighbor-joining does not assume a molecular clock, making it more robust to rate variation among lineages. The method is based on the principle of minimum evolution, seeking the tree topology that minimizes the total branch length.</p>
<p>The neighbor-joining algorithm operates on a matrix of pairwise distances but uses a modified distance measure that accounts for the average divergence of each sequence from all others. For each pair of sequences <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, it computes a corrected distance:</p>
<p><span class="math display">\[Q(i,j) = (n-2) \times d(i,j) - R_i - R_j\]</span></p>
<p>Where: - <span class="math inline">\(n\)</span> = the total number of sequences (or taxa) - <span class="math inline">\(d(i,j)\)</span> = the original distance between sequences <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> - <span class="math inline">\(R_i = \sum_{k=1}^{n} d(i,k)\)</span> = the sum of distances from sequence <span class="math inline">\(i\)</span> to all other sequences - <span class="math inline">\(R_j = \sum_{k=1}^{n} d(j,k)\)</span> = the sum of distances from sequence <span class="math inline">\(j\)</span> to all other sequences</p>
<p>The pair with the minimum <span class="math inline">\(Q\)</span> value is selected for joining. The logic behind this formula is to find the pair that minimizes the total tree length. The term <span class="math inline">\((n-2) \times d(i,j)\)</span> scales the distance between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, while subtracting <span class="math inline">\(R_i\)</span> and <span class="math inline">\(R_j\)</span> corrects for the average divergence of each sequence.</p>
<p>For example, with 4 sequences and distances: - <span class="math inline">\(d(1,2) = 0.3\)</span>, <span class="math inline">\(d(1,3) = 0.5\)</span>, <span class="math inline">\(d(1,4) = 0.6\)</span> - <span class="math inline">\(d(2,3) = 0.4\)</span>, <span class="math inline">\(d(2,4) = 0.7\)</span> - <span class="math inline">\(d(3,4) = 0.8\)</span></p>
<p>First, calculate the row sums: - <span class="math inline">\(R_1 = 0.3 + 0.5 + 0.6 = 1.4\)</span> - <span class="math inline">\(R_2 = 0.3 + 0.4 + 0.7 = 1.4\)</span> - <span class="math inline">\(R_3 = 0.5 + 0.4 + 0.8 = 1.7\)</span> - <span class="math inline">\(R_4 = 0.6 + 0.7 + 0.8 = 2.1\)</span></p>
<p>Then compute <span class="math inline">\(Q\)</span> values: - <span class="math inline">\(Q(1,2) = (4-2) \times 0.3 - 1.4 - 1.4 = 0.6 - 2.8 = -2.2\)</span> - <span class="math inline">\(Q(1,3) = 2 \times 0.5 - 1.4 - 1.7 = 1.0 - 3.1 = -2.1\)</span> - And so on…</p>
<p>When two sequences are joined in neighbor-joining, they are connected to a new internal node, and the branch lengths from this node to each sequence are computed to reflect their individual evolutionary distances. This differs from UPGMA, where both branches from a merge point have equal length. The formulas for branch lengths in NJ are:</p>
<p><span class="math display">\[v_i = \frac{d(i,j)}{2} + \frac{R_i - R_j}{2(n-2)}\]</span></p>
<p><span class="math display">\[v_j = d(i,j) - v_i\]</span></p>
<p>Where <span class="math inline">\(v_i\)</span> and <span class="math inline">\(v_j\)</span> are the branch lengths from the new internal node to sequences <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> respectively.</p>
<p>The first formula can be understood as: - <span class="math inline">\(\frac{d(i,j)}{2}\)</span> = half the distance between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> (if they evolved at equal rates) - <span class="math inline">\(\frac{R_i - R_j}{2(n-2)}\)</span> = correction factor based on the difference in average divergence</p>
<p>The second formula ensures that <span class="math inline">\(v_i + v_j = d(i,j)\)</span>, preserving the original distance between the sequences.</p>
<p>The neighbor-joining algorithm has several desirable theoretical properties. It is consistent, meaning that given sufficient data from a tree-like evolutionary process, it will recover the correct tree topology. It is also relatively robust to modest violations of its assumptions, such as mild deviations from additivity in the distance matrix. These properties, combined with its computational efficiency (O(n³) but with a small constant factor), have made neighbor-joining one of the most widely used methods in molecular phylogenetics.</p>
<p>However, neighbor-joining also has limitations. It assumes that the distance matrix is additive or nearly additive, meaning that distances can be perfectly represented as the sum of branch lengths on a tree. When this assumption is violated, such as in the presence of homoplasy or horizontal gene transfer, NJ can produce incorrect topologies. Additionally, NJ produces a single point estimate of the tree without measures of uncertainty, though bootstrap resampling can be used to assess the reliability of different parts of the tree.</p>
<p>The implementation of neighbor-joining requires careful attention to numerical precision, particularly when dealing with very similar or very divergent sequences. Round-off errors can accumulate during the iterative process, potentially affecting the final tree topology. Various optimizations have been developed to improve both the speed and accuracy of NJ implementations, including fast neighbor-joining algorithms that reduce the computational complexity for large datasets.</p>
<section id="additive-distances-non-recombining-sequence-ancestry" class="level3" data-number="49.3.1">
<h3 data-number="49.3.1" class="anchored" data-anchor-id="additive-distances-non-recombining-sequence-ancestry"><span class="header-section-number">49.3.1</span> Additive distances / Non-recombining sequence ancestry</h3>
<p>The concept of additive distances is fundamental to understanding when distance-based clustering methods will accurately recover evolutionary relationships. A distance matrix is additive if the distances can be exactly represented as path lengths on a tree with non-negative branch lengths. In other words, for any four sequences, the distances satisfy the four-point condition:</p>
<p>For any four taxa <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>, <span class="math inline">\(k\)</span>, and <span class="math inline">\(l\)</span>, we compute three sums: - <span class="math inline">\(S_1 = d(i,j) + d(k,l)\)</span> - <span class="math inline">\(S_2 = d(i,k) + d(j,l)\)</span> - <span class="math inline">\(S_3 = d(i,l) + d(j,k)\)</span></p>
<p>The four-point condition states that the two largest of these three sums must be equal. Mathematically:</p>
<p><span class="math display">\[\max(S_1, S_2, S_3) = \text{second largest}(S_1, S_2, S_3)\]</span></p>
<p>This can also be written as: the two largest sums among <span class="math inline">\(\{d(i,j) + d(k,l), d(i,k) + d(j,l), d(i,l) + d(j,k)\}\)</span> are equal.</p>
<p>For example, consider four sequences with the following distance matrix:</p>
<pre><code>    1    2    3    4
1   0   0.2  0.5  0.6
2  0.2   0   0.5  0.6
3  0.5  0.5   0   0.3
4  0.6  0.6  0.3   0</code></pre>
<p>Let’s check the four-point condition: - <span class="math inline">\(S_1 = d(1,2) + d(3,4) = 0.2 + 0.3 = 0.5\)</span> - <span class="math inline">\(S_2 = d(1,3) + d(2,4) = 0.5 + 0.6 = 1.1\)</span> - <span class="math inline">\(S_3 = d(1,4) + d(2,3) = 0.6 + 0.5 = 1.1\)</span></p>
<p>Here, <span class="math inline">\(S_2 = S_3 = 1.1\)</span> are the two largest values, so the four-point condition is satisfied, indicating these distances can be perfectly represented on a tree.</p>
<p>In biological terms, additive distances arise when sequences evolve according to a tree-like process without recombination or horizontal gene transfer. Each mutation occurs on a specific branch of the tree and contributes to the distance between all pairs of sequences separated by that branch. The total distance between any two sequences is then the sum of the lengths of the branches on the path connecting them in the tree.</p>
<p>Real biological sequences often violate the additivity assumption to some degree. Recombination, which is common in many organisms, can cause different parts of a sequence to have different evolutionary histories. Horizontal gene transfer, particularly prevalent in prokaryotes, can move genetic material between distantly related lineages. Homoplasy, where independent mutations produce the same character state, can cause distances to underestimate the true evolutionary divergence. These violations can lead to distance matrices that cannot be perfectly represented on any tree.</p>
<p>Testing for additivity involves checking whether the four-point condition holds for all quartets of sequences. In practice, perfect additivity is rare, and methods have been developed to measure the degree of deviation from additivity. The delta score quantifies how well a distance matrix fits a tree topology, with lower scores indicating better fit. Statistical tests can assess whether observed deviations from additivity are greater than expected from sampling error alone.</p>
<p>When distances are approximately additive, methods like neighbor-joining can still recover the correct tree topology with high probability. The robustness of these methods to mild violations of additivity is one reason for their continued popularity. However, when additivity is strongly violated, alternative approaches may be needed, such as network-based methods that can represent conflicting signals in the data or methods that explicitly model recombination and horizontal gene transfer.</p>
</section>
<section id="minimal-evolution-principle" class="level3" data-number="49.3.2">
<h3 data-number="49.3.2" class="anchored" data-anchor-id="minimal-evolution-principle"><span class="header-section-number">49.3.2</span> Minimal evolution principle</h3>
<p>The principle of minimum evolution, also known as the principle of parsimony at the level of tree length, suggests that among all possible tree topologies, the one requiring the least total amount of evolutionary change is most likely to be correct. This principle underlies many phylogenetic methods, including neighbor-joining, and provides a criterion for choosing among alternative evolutionary hypotheses.</p>
<p>The minimum evolution principle can be justified on both philosophical and statistical grounds. Philosophically, it embodies Occam’s razor – the simplest explanation consistent with the data is preferred. Statistically, under certain models of evolution, the tree with minimum length is the maximum likelihood estimate of the true tree. The principle is particularly compelling when evolutionary changes are rare relative to the time scales being considered, as unnecessary postulation of extra changes reduces the probability of the observed data.</p>
<p>In the context of distance-based clustering, minimum evolution seeks the tree topology and branch lengths that minimize the sum of all branch lengths while fitting the observed distances as closely as possible. This is typically formulated as a least-squares problem: find the tree T and branch lengths that minimize the sum of squared differences between observed distances and path lengths on the tree. Neighbor-joining can be viewed as a greedy heuristic for this optimization problem, making locally optimal choices that often lead to the globally optimal or near-optimal tree.</p>
<p>The minimum evolution criterion can be applied more generally through methods like minimum evolution distance methods and least-squares tree fitting. These methods search more extensively through tree space than neighbor-joining, potentially finding better trees at the cost of increased computation. Some implementations use branch swapping operations to explore local modifications of an initial tree, while others use more sophisticated search strategies.</p>
<p>It’s important to note that minimum evolution, like all optimality criteria, can be misled by certain patterns in the data. Long-branch attraction, where rapidly evolving lineages are incorrectly grouped together, can cause minimum evolution methods to prefer incorrect trees. Model misspecification, such as failing to account for rate variation among sites, can also lead to systematic biases. These limitations highlight the importance of using multiple methods and carefully considering the assumptions underlying each approach.</p>
</section>
</section>
</section>
<section id="sec-bootstrap" class="level1" data-number="50">
<h1 data-number="50"><span class="header-section-number">50</span> Bootstrap Analysis in Phylogenetic Reconstruction</h1>
<p>Bootstrap analysis has become an indispensable tool in phylogenetic reconstruction and sequence clustering, providing a statistical framework for assessing the reliability and robustness of inferred evolutionary relationships. Introduced to phylogenetics by Joseph Felsenstein in 1985, the bootstrap method addresses a fundamental challenge in evolutionary biology: how can we quantify our confidence in a particular tree topology when we have only a single dataset representing millions of years of evolution? This section explores the statistical principles underlying bootstrap analysis, its assumptions and limitations, what it actually quantifies, when its application is appropriate, and the computational methods used to implement it.</p>
<section id="statistical-principles-of-bootstrapping" class="level2" data-number="50.1">
<h2 data-number="50.1" class="anchored" data-anchor-id="statistical-principles-of-bootstrapping"><span class="header-section-number">50.1</span> Statistical Principles of Bootstrapping</h2>
<p>The bootstrap is a resampling technique that estimates the sampling distribution of a statistic by repeatedly resampling with replacement from the original data. In the context of phylogenetic analysis, the “data” consists of aligned sequence positions (sites or columns in the alignment), and the “statistic” is typically the tree topology or specific clades within the tree. The fundamental principle is that if our inference method is robust, it should produce similar results when applied to slightly different datasets that could plausibly have been observed.</p>
<p>To understand why bootstrap analysis works, it’s essential to grasp how phylogenetic information is encoded in sequence alignments. Each column in an alignment represents a site that has evolved along the tree, and the pattern of nucleotides or amino acids at that site carries information about the evolutionary history. Consider a simple case with four sequences where a site shows the pattern AAGA. This pattern, where sequences 1, 2, and 4 share state A while sequence 3 has G, provides evidence for grouping sequences 1, 2, and 4 together, separated from sequence 3. The strength of this evidence depends on how many sites show consistent patterns supporting the same grouping.</p>
<p>Different site patterns provide evidence for different branches in the tree. Sites that change along deep branches in the tree create patterns that support the major divisions among sequences, while sites that change along recent branches support the grouping of closely related sequences. The frequency of each site pattern in the alignment directly relates to the length of the corresponding branch in the true tree—longer branches accumulate more changes and thus generate more sites with patterns supporting those branches. This is why phylogenetic methods can estimate both tree topology and branch lengths from the distribution of site patterns.</p>
<p>When an alignment contains many informative sites with strong, consistent signals, resampling these sites will likely reproduce similar site pattern frequencies in each bootstrap replicate. Even though each bootstrap sample contains a different mix of the original sites (with some appearing multiple times and others not at all), the overall distribution of site patterns remains relatively stable. Consequently, the same tree topology will be recovered from most bootstrap replicates, resulting in high bootstrap support values. For instance, if 100 sites strongly support grouping sequences A and B together, and only 10 sites weakly suggest alternative groupings, then most bootstrap replicates will still contain enough A-B supporting sites to recover that clade, even with the random variation introduced by resampling.</p>
<p>Conversely, when an alignment is short or contains few informative sites, the phylogenetic signal is weaker and more susceptible to sampling variation. If only 5 sites support grouping A with B while 3 sites support grouping A with C, bootstrap resampling can easily shift this delicate balance. Some bootstrap replicates might sample more A-B supporting sites, while others might happen to include multiple copies of the A-C supporting sites. This sampling variation leads to different trees being recovered from different bootstrap replicates, resulting in low bootstrap support values. This explains why short sequences or rapidly evolving regions with high noise-to-signal ratios tend to produce low bootstrap values—not necessarily because the relationships are wrong, but because the data provide insufficient evidence to overcome sampling variation.</p>
<p>Mathematically, let <span class="math inline">\(X = \{x_1, x_2, ..., x_n\}\)</span> represent our original alignment with <span class="math inline">\(n\)</span> sites. A bootstrap replicate <span class="math inline">\(X^*_b\)</span> is created by randomly sampling <span class="math inline">\(n\)</span> sites from <span class="math inline">\(X\)</span> with replacement:</p>
<p><span class="math display">\[X^*_b = \{x^*_{b,1}, x^*_{b,2}, ..., x^*_{b,n}\}\]</span></p>
<p>where each <span class="math inline">\(x^*_{b,i}\)</span> is randomly drawn from <span class="math inline">\(\{x_1, x_2, ..., x_n\}\)</span> with probability <span class="math inline">\(1/n\)</span>.</p>
<p>The probability that a specific site <span class="math inline">\(x_i\)</span> appears exactly <span class="math inline">\(k\)</span> times in a bootstrap replicate follows a binomial distribution:</p>
<p><span class="math display">\[P(x_i \text{ appears } k \text{ times}) = \binom{n}{k} \left(\frac{1}{n}\right)^k \left(1-\frac{1}{n}\right)^{n-k}\]</span></p>
<p>For large <span class="math inline">\(n\)</span>, this approximates a Poisson distribution with parameter <span class="math inline">\(\lambda = 1\)</span>. Consequently, the probability that a site doesn’t appear in a bootstrap replicate is:</p>
<p><span class="math display">\[P(x_i \text{ absent}) = \left(1-\frac{1}{n}\right)^n \approx e^{-1} \approx 0.368\]</span></p>
<p>This means approximately 36.8% of the original sites will be absent from any given bootstrap replicate, while others will appear multiple times. This variation in site composition creates the diversity needed to assess uncertainty.</p>
<p>The bootstrap procedure for phylogenetic analysis follows these steps:</p>
<ol type="1">
<li>Generate <span class="math inline">\(B\)</span> bootstrap replicates (typically <span class="math inline">\(B = 100\)</span> to <span class="math inline">\(1000\)</span>)</li>
<li>For each replicate <span class="math inline">\(b = 1, ..., B\)</span>:
<ul>
<li>Create bootstrap alignment <span class="math inline">\(X^*_b\)</span> by resampling sites</li>
<li>Reconstruct phylogenetic tree <span class="math inline">\(T^*_b\)</span> using the same method applied to original data</li>
</ul></li>
<li>Calculate bootstrap support for each clade as:</li>
</ol>
<p><span class="math display">\[BS(clade) = \frac{\#\{T^*_b : clade \in T^*_b\}}{B} \times 100\%\]</span></p>
<p>The bootstrap support value represents the percentage of bootstrap trees containing the specific clade. For example, if a clade appears in 850 out of 1000 bootstrap trees, it has 85% bootstrap support.</p>
</section>
<section id="bootstrap-assumptions-and-requirements" class="level2" data-number="50.2">
<h2 data-number="50.2" class="anchored" data-anchor-id="bootstrap-assumptions-and-requirements"><span class="header-section-number">50.2</span> Bootstrap Assumptions and Requirements</h2>
<p>The validity of bootstrap analysis in phylogenetics rests on several critical assumptions that must be carefully considered when interpreting results. The most fundamental assumption is that sequence sites evolve independently and identically distributed (i.i.d.). This means each site evolves according to the same stochastic process, independent of other sites. Mathematically, if <span class="math inline">\(L(D|T,\theta)\)</span> is the likelihood of data <span class="math inline">\(D\)</span> given tree <span class="math inline">\(T\)</span> and model parameters <span class="math inline">\(\theta\)</span>:</p>
<p><span class="math display">\[L(D|T,\theta) = \prod_{i=1}^{n} L(x_i|T,\theta)\]</span></p>
<p>This multiplicative decomposition is only valid under the i.i.d. assumption. In reality, this assumption is often violated in several important ways. Linkage and recombination create dependencies where physically linked sites share evolutionary histories rather than evolving independently. Structural constraints in proteins and RNA molecules mean that sites must co-evolve to maintain three-dimensional structure and function, creating strong correlations between positions. The phenomenon of covarion evolution, where the evolutionary rate at one site depends on the states at other sites, further violates independence. Additionally, heterotachy, the variation in evolutionary rates across the tree at the same site, violates the identically distributed assumption.</p>
<p>When these assumptions are violated, bootstrap values may be misleading. For instance, if sites are positively correlated due to structural constraints, bootstrap resampling may underestimate the true variance, leading to inflated bootstrap values.</p>
<p>Another crucial assumption is that the alignment is correct and fixed. Bootstrap analysis does not account for alignment uncertainty. If the alignment contains errors, these errors are propagated through all bootstrap replicates, potentially giving high support to incorrect relationships. This is particularly problematic for divergent sequences where alignment ambiguity is high.</p>
<p>The bootstrap also assumes that the phylogenetic reconstruction method is consistent—that is, it converges to the true tree given infinite data. If the method is statistically inconsistent due to model misspecification, high bootstrap values may support incorrect clades. This phenomenon, known as “high support for the wrong tree,” can occur under conditions like long-branch attraction with parsimony methods.</p>
</section>
<section id="what-bootstrap-values-quantify" class="level2" data-number="50.3">
<h2 data-number="50.3" class="anchored" data-anchor-id="what-bootstrap-values-quantify"><span class="header-section-number">50.3</span> What Bootstrap Values Quantify</h2>
<p>A common misconception is that bootstrap values represent the probability that a clade is true. However, bootstrap values actually quantify something more subtle: the repeatability or stability of the inference given data resampling. Specifically, a bootstrap value estimates:</p>
<p><span class="math display">\[BS(clade) \approx P(clade \in \hat{T}^* | D)\]</span></p>
<p>where <span class="math inline">\(\hat{T}^*\)</span> is the estimated tree from a hypothetical replicate dataset drawn from the same underlying distribution as the original data.</p>
<p>To understand what this means, consider the relationship between bootstrap values and actual accuracy. Simulation studies have shown that the relationship is complex and depends on multiple factors. For well-supported clades, bootstrap values tend to be conservative, underestimating the actual accuracy of the inference. In contrast, for weakly-supported clades, bootstrap values may either overestimate or underestimate accuracy depending on the specific conditions. Most importantly, the relationship is non-linear—a 70% bootstrap value doesn’t translate directly to a 70% probability of the clade being correct.</p>
<p>Hillis and Bull (1993) found through simulations that bootstrap proportions of 70% or higher usually correspond to a 95% or greater probability of recovering true clades, suggesting bootstrap values are generally conservative. However, this relationship varies considerably with several factors. Sequence length plays a crucial role, with longer sequences generally yielding more reliable bootstrap estimates because they contain more information to overcome sampling variation. Substitution rate heterogeneity can distort bootstrap values, as greater heterogeneity violates model assumptions and may lead to systematic biases. The tree reconstruction method also matters significantly, with different methods showing different bootstrap behaviors—maximum likelihood methods often produce higher bootstrap values than parsimony for the same data. Finally, the true tree topology itself affects bootstrap performance, with balanced trees typically showing different patterns than highly imbalanced trees.</p>
<p>The bootstrap can be interpreted from a frequentist perspective as assessing sampling variance. If we could repeatedly sample sequences from the same evolutionary process, how often would we recover the same clade? This interpretation makes clear that bootstrap values reflect both the strength of phylogenetic signal and the sensitivity of our inference method to sampling variation.</p>
</section>
<section id="when-bootstrap-analysis-is-appropriate" class="level2" data-number="50.4">
<h2 data-number="50.4" class="anchored" data-anchor-id="when-bootstrap-analysis-is-appropriate"><span class="header-section-number">50.4</span> When Bootstrap Analysis is Appropriate</h2>
<p>Bootstrap analysis is most appropriate when several key conditions are met. First and foremost, sufficient data must exist for meaningful resampling—with very short sequences containing fewer than 100 sites, bootstrap values are often uninformatively low because the limited data cannot support stable inference under resampling variation. The method works best when sites can be considered approximately independent, which is typically the case for single genes or carefully selected multi-gene datasets where linkage effects are minimal. Bootstrap is particularly valuable when the primary goal is to assess topological uncertainty rather than uncertainty in branch lengths, as branch length estimates are more sensitive to model assumptions. The technique also excels at comparing support across different nodes within the same analysis, providing a consistent framework for evaluating which relationships are well-supported versus questionable.</p>
<p>Bootstrap analysis may be less appropriate or require modification under certain circumstances. When analyzing genome-scale data, the independence assumption is strongly violated because genes on the same chromosome share evolutionary histories through linkage, and different genomic regions may have experienced different selective pressures or recombination events. Sites showing strong correlation, such as paired sites in RNA secondary structures that must co-evolve to maintain base-pairing, violate the independence assumption in ways that standard bootstrap cannot accommodate. High alignment uncertainty presents another challenge, as bootstrap doesn’t account for alignment errors, which become fixed across all bootstrap replicates and can lead to false confidence in incorrect relationships. Finally, bootstrap values aren’t directly comparable across different studies because they depend heavily on the specific dataset characteristics, reconstruction method, and model assumptions used in each analysis.</p>
<p>For genome-scale data, alternatives like the multi-scale bootstrap or site-pattern bootstrap may be more appropriate. These methods adjust for the fact that phylogenomic datasets violate traditional bootstrap assumptions.</p>
</section>
<section id="computational-implementation" class="level2" data-number="50.5">
<h2 data-number="50.5" class="anchored" data-anchor-id="computational-implementation"><span class="header-section-number">50.5</span> Computational Implementation</h2>
<p>The computational cost of bootstrap analysis can be substantial, as it requires reconstructing many trees. The total computational complexity is:</p>
<p><span class="math display">\[O(B \times C(n,m))\]</span></p>
<p>where <span class="math inline">\(B\)</span> is the number of bootstrap replicates, and <span class="math inline">\(C(n,m)\)</span> is the complexity of the tree reconstruction method for <span class="math inline">\(n\)</span> taxa and <span class="math inline">\(m\)</span> sites.</p>
<p>Here’s a detailed algorithm for implementing bootstrap analysis:</p>
<pre><code>Algorithm: Phylogenetic Bootstrap
Input: Alignment D (n taxa × m sites), method M, replicates B
Output: Original tree T with bootstrap support values

1. T ← ReconstructTree(D, M)  // Original tree
2. Initialize clade_counts ← empty dictionary
3. For b = 1 to B:
4.     D* ← BootstrapSample(D, m)  // Resample m sites with replacement
5.     T* ← ReconstructTree(D*, M)
6.     For each clade in T*:
7.         clade_counts[clade] ← clade_counts[clade] + 1
8. For each clade in T:
9.     support[clade] ← (clade_counts[clade] / B) × 100
10. Return T with support values</code></pre>
<p>Efficient implementation requires careful optimization through several strategies. Parallel processing is particularly effective because bootstrap replicates are completely independent, allowing different replicates to be computed simultaneously on different processors without any communication overhead. Rapid bootstrapping methods, such as RAxML’s rapid bootstrap algorithm, combine fast hill-climbing searches with selective thorough optimization to reduce computation time by an order of magnitude while maintaining accuracy. The transfer bootstrap approach modifies the support calculation by using transfer distance instead of simple clade presence/absence, providing more nuanced support values that better reflect topological similarity. UFBoot (Ultrafast bootstrap) implements an approximation algorithm with statistical correction for bias, enabling bootstrap analysis of very large datasets that would be computationally prohibitive with standard methods.</p>
</section>
<section id="interpreting-bootstrap-results" class="level2" data-number="50.6">
<h2 data-number="50.6" class="anchored" data-anchor-id="interpreting-bootstrap-results"><span class="header-section-number">50.6</span> Interpreting Bootstrap Results</h2>
<p>Bootstrap values should be interpreted carefully in biological context. General guidelines suggest that values above 95% indicate very strong support where the clade is highly reliable and unlikely to change with additional data. Values between 70% and 95% represent moderate to strong support, suggesting the clade is likely correct though some uncertainty remains. Bootstrap values from 50% to 70% indicate weak support where the clade is uncertain and should be treated with caution. Values below 50% provide no meaningful support, and such clades should be considered unreliable for biological inference.</p>
<p>However, these thresholds are somewhat arbitrary and depend heavily on the specific analysis context. Several factors profoundly affect the interpretation of bootstrap values. Dataset size plays a major role, as larger datasets generally yield higher bootstrap values simply because more data provides more consistent signal that survives resampling. The evolutionary rate of the sequences matters significantly—rapidly evolving sequences often show lower bootstrap support because they accumulate more homoplasy and conflicting signals. Taxonomic scope influences values as well, with broader taxonomic sampling potentially reducing bootstrap values by introducing more variation and potential for conflicting signals. The reconstruction method used also affects absolute values, with maximum likelihood methods often producing higher bootstrap values than parsimony for the same dataset due to their more sophisticated modeling of the evolutionary process.</p>
<p>Bootstrap values can also serve as diagnostic tools to identify problematic regions of the tree. Consistently low values across multiple nodes may indicate rapid radiation events where multiple lineages diverged in quick succession, leaving insufficient time for synapomorphies to accumulate along internal branches. Such low values might also reveal conflicting phylogenetic signals arising from processes like incomplete lineage sorting or horizontal gene transfer. In some cases, low bootstrap support simply reflects insufficient data to confidently resolve relationships, suggesting that longer sequences or more genes are needed. Persistent patterns of low support in specific parts of the tree can also indicate systematic biases such as long-branch attraction, where the reconstruction method is being misled by convergent evolution or model misspecification.</p>
</section>
<section id="advanced-bootstrap-methods" class="level2" data-number="50.7">
<h2 data-number="50.7" class="anchored" data-anchor-id="advanced-bootstrap-methods"><span class="header-section-number">50.7</span> Advanced Bootstrap Methods</h2>
<p>Several variations and improvements to the standard bootstrap have been developed:</p>
<p><strong>Parametric Bootstrap</strong>: Instead of resampling sites, simulate new datasets under the fitted model: <span class="math display">\[D^*_b \sim P(D|\hat{T}, \hat{\theta})\]</span></p>
<p>This approach can be more powerful when the model is correctly specified but requires accurate parameter estimation.</p>
<p><strong>Weighted Bootstrap</strong>: Assign random weights <span class="math inline">\(w_i \sim Exponential(1)\)</span> to sites instead of resampling, maintaining continuous information.</p>
<p><strong>Multi-scale Bootstrap</strong>: Adjusts for data size by resampling <span class="math inline">\(n'\)</span> sites where <span class="math inline">\(n' = n^\alpha\)</span> for various <span class="math inline">\(\alpha\)</span> values, then extrapolates to <span class="math inline">\(\alpha = 1\)</span>.</p>
<p><strong>Posterior Predictive Bootstrap</strong>: Combines Bayesian and bootstrap approaches by resampling from the posterior predictive distribution.</p>
<p>In conclusion, bootstrap analysis provides a practical and widely-applicable method for assessing uncertainty in phylogenetic reconstruction. While it has limitations and its values don’t directly translate to probabilities of correctness, it remains one of the most important tools for evaluating the robustness of evolutionary inferences. Understanding its statistical foundations, assumptions, and proper interpretation is essential for anyone conducting phylogenetic analyses or sequence clustering studies.</p>
</section>
</section>
<section id="applications-and-future-directions" class="level1" data-number="51">
<h1 data-number="51"><span class="header-section-number">51</span> Applications and Future Directions</h1>
<p>The applications of sequence clustering extend throughout modern biology and medicine. In genomics, clustering is used to identify gene families, predict gene function, and understand genome evolution. The identification of orthologous genes (genes in different species derived from a common ancestor) relies heavily on sequence clustering, enabling functional annotation of newly sequenced genomes. Clustering of regulatory sequences helps identify co-regulated genes and understand transcriptional networks.</p>
<p>In protein science, clustering reveals functional and structural relationships that would be difficult to discern through experimental methods alone. Protein families identified through sequence clustering often share three-dimensional structures and biochemical functions, even when sequence similarity is modest. This relationship between sequence, structure, and function underlies homology modeling approaches to protein structure prediction and guides experimental characterization of protein function.</p>
<p>Medical applications of sequence clustering are increasingly important in the era of precision medicine. Clustering of pathogen sequences enables tracking of disease outbreaks, identification of drug resistance mutations, and vaccine design. In cancer genomics, clustering of tumor sequences reveals subtypes with different prognoses and treatment responses. The clustering of human genetic variants helps identify disease-causing mutations and understand population structure and migration patterns.</p>
<p>The future of sequence clustering will be shaped by several technological and methodological advances. The continued explosion of sequence data, driven by decreasing costs and new sequencing technologies, demands ever more efficient clustering algorithms. Methods that can incrementally update clusters as new sequences are added, rather than reclustering from scratch, will become increasingly important. Cloud computing and distributed algorithms will enable clustering of datasets that are too large for single machines.</p>
<p>Machine learning approaches are beginning to transform sequence clustering. Deep learning models can learn complex representations of sequences that capture both local and global patterns, potentially revealing relationships invisible to traditional methods. These learned representations can be used as the basis for clustering, or neural networks can be trained end-to-end to perform clustering directly. However, the interpretability of these models remains a challenge, as understanding why sequences are grouped together is often as important as the grouping itself.</p>
<p>Integration of multiple data types represents another frontier in sequence clustering. Modern biology generates not just sequences but also expression data, interaction networks, structural information, and phenotypic measurements. Methods that can combine these diverse data types to produce biologically meaningful clusters will provide deeper insights than sequence-based methods alone. This integration requires new theoretical frameworks and computational methods that can handle heterogeneous data while maintaining biological interpretability.</p>
<p>The challenges of horizontal gene transfer, recombination, and other processes that violate tree-like evolution continue to motivate new methodological developments. Network-based approaches that can represent conflicting evolutionary signals are becoming more sophisticated and computationally feasible. Methods that explicitly model different evolutionary processes for different genes or regions of the genome provide more accurate pictures of evolutionary history.</p>
<p>In conclusion, sequence clustering remains a vibrant and essential area of bioinformatics research. From its roots in simple distance-based methods to modern machine learning approaches, the field continues to evolve in response to biological discoveries and technological advances. As we generate ever more sequence data and ask increasingly sophisticated biological questions, the development of new clustering methods and the refinement of existing approaches will remain crucial for extracting biological insight from the vast universe of molecular sequences. The principles and methods discussed in this lecture provide the foundation for understanding and contributing to this ongoing scientific enterprise, whether in basic research, medical applications, or biotechnology. The future promises even more powerful methods that will help us understand the intricate relationships among the molecules of life, ultimately advancing our ability to predict, prevent, and treat disease, engineer biological systems, and understand our place in the tree of life.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../chapters/project/hiv_project/index.html" class="pagination-link" aria-label="HIV sub-groups">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">45</span>&nbsp; <span class="chapter-title">HIV sub-groups</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/project/seqdist_project/index.html" class="pagination-link" aria-label="Sequence trees">
        <span class="nav-page-text"><span class="chapter-number">48</span>&nbsp; <span class="chapter-title">Sequence trees</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>