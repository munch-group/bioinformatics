<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>37&nbsp; Pairwise Alignment – Bioinformatics and Programming</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/bioinformatics/multiple_alignment.html" rel="next">
<link href="../../chapters/project/assembly_project/index.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-5a65f6d6a6cb2564d1aec56f7fed0acc.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-7b6dd81834b739ce5ef7482f5ddde1ad.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/preface.html">Bioinformatics</a></li><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/pairwise_alignment.html"><span class="chapter-number">37</span>&nbsp; <span class="chapter-title">Pairwise Alignment</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Content</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Exam information</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../curriculum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Curriculum</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Learning Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Preface</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/before_you_begin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Before you begin</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/writing_a_program.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Writing a program</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/dealing_with_values.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dealing with values</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/the_order_of_events.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">The order of events</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/course_tools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Course tools</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/controlling_behavior.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Controlling behavior</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/organizing_your_code.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Organizing code</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/python_values_are_objects.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Values are objects</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/lists.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Lists of things</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/dictionaries.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Pairs of things</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/gluing_values_in_sequence.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Grouping values</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/iteration_over_values.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Iterating values</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/working_with_data_files.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Working with files</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/data_structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Structuring data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/unleash_your_functions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Recursion</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/testing_your_code.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Testing your code</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/your_own_types_of_objects.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Your Own Objects</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/using_code_from_other_files.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Code in other files</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/on_the_shoulders_of_giants.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Giant’s shoulders</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/appendix_bsf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Appendix: PyMol for BSF</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Bioinformatics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Preface</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/association.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Genetic Association</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/gwas_databases/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">GWAS candidates</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/databases.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Databases</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/database_searching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Database Searching</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/translation_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Translating ORFs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/hidden_markov_models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">29</span>&nbsp; <span class="chapter-title">Hidden Markov Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/new_hmm_exercise/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">30</span>&nbsp; <span class="chapter-title">Membrane proteins</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/orf_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">31</span>&nbsp; <span class="chapter-title">Finding genes</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/neural_networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">32</span>&nbsp; <span class="chapter-title">Neural networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/neural_networks/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">33</span>&nbsp; <span class="chapter-title">Neural networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/folding_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">34</span>&nbsp; <span class="chapter-title">Primer analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/assembly_and_mapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">35</span>&nbsp; <span class="chapter-title">Genome Sequencing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/assembly_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">36</span>&nbsp; <span class="chapter-title">Genome assembly</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/pairwise_alignment.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">37</span>&nbsp; <span class="chapter-title">Pairwise Alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/multiple_alignment.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">38</span>&nbsp; <span class="chapter-title">Multiple Alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/alignment_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">39</span>&nbsp; <span class="chapter-title">Pairwise alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/ccr5_pwalign/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">40</span>&nbsp; <span class="chapter-title">CCR5-delta32</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/protein_substitution_matrices.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">41</span>&nbsp; <span class="chapter-title">Scoring Matrices</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/database_searching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Database Searching</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/mrsa_blast_multalign/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">43</span>&nbsp; <span class="chapter-title">MRSA</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/hiv_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">44</span>&nbsp; <span class="chapter-title">HIV sub-groups</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/multiple_alignment.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">38</span>&nbsp; <span class="chapter-title">Multiple Alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/clustering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">46</span>&nbsp; <span class="chapter-title">Clustering of sequences</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/seqdist_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">47</span>&nbsp; <span class="chapter-title">Sequence trees</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/models_of_dna_evolution.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">48</span>&nbsp; <span class="chapter-title">Models of DNA Evolution</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/phylogenetics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">49</span>&nbsp; <span class="chapter-title">Phylogenetics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/aardwark_seqdist/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">50</span>&nbsp; <span class="chapter-title">Aardvark?</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/orf_finding/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">51</span>&nbsp; <span class="chapter-title">Plasmid ORFs</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Supplementary</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/project_files.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Project files</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/recordings2025.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture recordings</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/slides2024.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture slides</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/bioinformatics_resources.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Databases and resources</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../assignments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Assignments</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../exam.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exam info</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/trouble_shooting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Trouble shooting</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#the-alignment-problem" id="toc-the-alignment-problem" class="nav-link active" data-scroll-target="#the-alignment-problem">The alignment problem</a></li>
  <li><a href="#why-alignment-is-computationally-hard" id="toc-why-alignment-is-computationally-hard" class="nav-link" data-scroll-target="#why-alignment-is-computationally-hard">Why alignment is computationally hard</a>
  <ul class="collapse">
  <li><a href="#visualizing-the-alignment-space" id="toc-visualizing-the-alignment-space" class="nav-link" data-scroll-target="#visualizing-the-alignment-space">Visualizing the alignment space</a></li>
  <li><a href="#how-fast-is-fast-enough" id="toc-how-fast-is-fast-enough" class="nav-link" data-scroll-target="#how-fast-is-fast-enough">How fast is fast enough?</a></li>
  </ul></li>
  <li><a href="#counting-all-possible-alignments" id="toc-counting-all-possible-alignments" class="nav-link" data-scroll-target="#counting-all-possible-alignments">Counting all possible alignments</a></li>
  <li><a href="#what-makes-an-alignment-optimal" id="toc-what-makes-an-alignment-optimal" class="nav-link" data-scroll-target="#what-makes-an-alignment-optimal">What makes an alignment optimal?</a></li>
  <li><a href="#scoring-matrices-and-gap-penalties" id="toc-scoring-matrices-and-gap-penalties" class="nav-link" data-scroll-target="#scoring-matrices-and-gap-penalties">Scoring matrices and gap penalties</a></li>
  <li><a href="#gap-penalties" id="toc-gap-penalties" class="nav-link" data-scroll-target="#gap-penalties">Gap penalties</a></li>
  <li><a href="#the-principle-of-optimality" id="toc-the-principle-of-optimality" class="nav-link" data-scroll-target="#the-principle-of-optimality">The principle of optimality</a></li>
  <li><a href="#the-recurrence-relation" id="toc-the-recurrence-relation" class="nav-link" data-scroll-target="#the-recurrence-relation">The recurrence relation</a></li>
  <li><a href="#the-needleman-wunsch-algorithm" id="toc-the-needleman-wunsch-algorithm" class="nav-link" data-scroll-target="#the-needleman-wunsch-algorithm">The Needleman-Wunsch algorithm</a></li>
  <li><a href="#understanding-memoization-and-the-dynamic-programming-matrix" id="toc-understanding-memoization-and-the-dynamic-programming-matrix" class="nav-link" data-scroll-target="#understanding-memoization-and-the-dynamic-programming-matrix">Understanding memoization and the dynamic programming matrix</a></li>
  <li><a href="#variations-and-extensions" id="toc-variations-and-extensions" class="nav-link" data-scroll-target="#variations-and-extensions">Variations and Extensions</a>
  <ul class="collapse">
  <li><a href="#affine-gap-penalties" id="toc-affine-gap-penalties" class="nav-link" data-scroll-target="#affine-gap-penalties">Affine Gap Penalties</a></li>
  <li><a href="#local-alignment" id="toc-local-alignment" class="nav-link" data-scroll-target="#local-alignment">Local Alignment</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/preface.html">Bioinformatics</a></li><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/pairwise_alignment.html"><span class="chapter-number">37</span>&nbsp; <span class="chapter-title">Pairwise Alignment</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-pairwisealignment" class="quarto-section-identifier"><span class="chapter-number">37</span>&nbsp; <span class="chapter-title">Pairwise Alignment</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>This chapter is about finding the best way to line up two biological sequences to reveal their similarities and differences. Alignment is fundamental to understanding how sequences are related evolutionarily and what functions they might perform.</em></p>
<section id="the-alignment-problem" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="the-alignment-problem">The alignment problem</h2>
<p>Imagine you are looking at two DNA sequences, and you want to figure out if they are related. Maybe they are the same gene from two different species, or maybe they are two different versions of a gene in the same population. How do you compare them? You could just look at them and see if they look similar, but that is not very precise. What you really want is a systematic way to line them up so you can see exactly where they match and where they differ. This is the problem of sequence alignment, and it is one of the most fundamental operations in all of bioinformatics. The question seems simple enough: given two biological sequences, what is the best way to align them from beginning to end to reveal their similarities and differences? But as you will see, this apparently simple question leads to some fascinating computational challenges and beautiful algorithmic solutions. The alignment problem is deceptively tricky because sequences evolve over time through mutations, insertions, and deletions, so two sequences that descended from the same ancestral sequence may now look quite different.</p>
<div id="fig-alignment-example" class="cell styled-output quarto-float quarto-figure quarto-figure-center anchored" data-execution_count="1">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-alignment-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output cell-output-stdout">
<pre><code>Seq1: ATGCGATCG-A
      |||·| ||| |
Seq2: ATGGG-TCGGA

Matches: 7, Mismatches: 2, Gaps: 2</code></pre>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-alignment-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;37.1
</figcaption>
</figure>
</div>
<p>The problem of sequence alignment arises from a fundamental principle of molecular evolution. Biological sequences—whether DNA, RNA, or protein sequences—evolve through time via mutations. These mutations include substitutions, where one nucleotide or amino acid is replaced by another, and insertions and deletions (collectively called indels), where material is added or removed from the sequence. When we observe two sequences today, they may have diverged from a common ancestor millions or even billions of years ago, and the evolutionary processes that have shaped these sequences leave traces in the form of similarities and differences that alignment algorithms seek to uncover. By finding the optimal alignment between sequences, we can infer their evolutionary relationship, identify functionally important regions that have been conserved over evolutionary time, and predict the structure and function of unknown sequences based on their similarity to sequences we already understand. The better we can align sequences, the better we can understand their biology. So getting alignment right really matters.</p>
<p>Global alignment, as distinguished from local alignment, seeks to align entire sequences from their first position to their last. This approach makes sense when comparing sequences that you expect to be similar over their entire length, such as homologous proteins from closely related species or different versions (alleles) of the same gene within a population. When you perform a global alignment, you are making the assumption that the sequences correspond to each other from beginning to end, and your job is to figure out the best way to match them up, inserting gaps where necessary to accommodate insertions and deletions. The requirement to align complete sequences introduces unique computational challenges, as the algorithm must consider all possible ways of introducing gaps to accommodate insertions and deletions while maintaining the overall correspondence between sequences. As you will see, the number of possible alignments grows astronomically with sequence length, so we need clever algorithms to find the best alignment without having to explicitly consider every single possibility.</p>
<p>The development of efficient algorithms for global sequence alignment represents one of the early triumphs of computational biology. The application of dynamic programming to this problem, first introduced by Needleman and Wunsch in 1970, provided an elegant solution that guarantees finding the optimal alignment while completely avoiding the need to enumerate the astronomical number of possible alignments that a brute-force approach would require. This algorithmic innovation not only solved a practical problem—allowing biologists to align sequences that would otherwise be impossible to compare systematically—but also established a computational paradigm that has been applied to numerous other problems in bioinformatics and beyond. The dynamic programming approach to sequence alignment is a beautiful example of how the right algorithm can transform an apparently intractable problem into one that can be solved efficiently. As you work through this chapter, you will see exactly how this transformation works, and hopefully you will develop an appreciation for the elegance of the solution.</p>
<p>Why does all of this matter? Because sequence alignment is not just an abstract computational problem—it is a fundamental tool that underlies much of modern biology and medicine. Global sequence alignment is essential to evolutionary biology, providing quantitative measures of sequence similarity that can be used to infer phylogenetic relationships and understand how species are related. When you align sequences from different species, you can identify conserved regions that have been maintained by natural selection because they are functionally important, and you can identify variable regions that have accumulated neutral or adaptive mutations over evolutionary time. One of the most common applications is functional annotation—inferring the function of a newly sequenced gene or protein based on its similarity to sequences of known function. The logic is straightforward: proteins with similar sequences typically fold into similar three-dimensional structures and perform similar biochemical functions, so if you find that your unknown sequence aligns well with a protein of known function, that is strong evidence that they share that function. In medical genetics, sequence alignment plays a crucial role in identifying disease-causing mutations by aligning a patient’s gene sequence with a reference sequence to identify variations that may be pathogenic. In the era of whole-genome sequencing, alignment algorithms help us compare entire genomes to reveal patterns of conserved gene order, identify corresponding genes in different species, and understand the evolutionary forces that have shaped genome structure. So as you learn about the algorithms and mathematics of sequence alignment in this chapter, keep in mind that these tools have very real applications in understanding the biology of life and in improving human health.</p>
</section>
<section id="why-alignment-is-computationally-hard" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="why-alignment-is-computationally-hard">Why alignment is computationally hard</h2>
<p>You might think that aligning two sequences would be straightforward. After all, if you just want to line them up and see how similar they are, why not just do it? The problem is that there are so many different ways to align two sequences that trying them all would take longer than the age of the universe—even for sequences that are not particularly long. Let me show you why. If you have two sequences and you are not allowed to insert any gaps, then there is only one way to align them: position one in the first sequence lines up with position one in the second sequence, position two with position two, and so on. Easy. But biological sequences do not work like that. Evolution introduces insertions and deletions, so if you want to find the true evolutionary relationship between two sequences, you need to allow gaps. And once you allow gaps, the number of possible alignments explodes.</p>
<p>Think about it this way. For two sequences of lengths m and n, every possible alignment corresponds to a way of inserting gaps into both sequences such that they end up the same length and then lining them up. How many ways can you do that? It turns out that the number of possible global alignments can be expressed using a formula involving binomial coefficients, and while I could write out the formula for you, what really matters is how fast this number grows. Even for relatively short sequences of 100 nucleotides or amino acids each, the number of possible alignments exceeds 10^60. To put that in perspective, the observable universe contains roughly 10^80 atoms, so we are talking about a number that is not unimaginably far from that scale. This combinatorial explosion means that any algorithm that tries to enumerate and evaluate all possible alignments will fail spectacularly for sequences of any biologically relevant length. If you tried to check all possible alignments of two 100-residue sequences, evaluating one alignment per nanosecond, you would still be working on the problem billions of years after the heat death of the universe. So clearly, we need a smarter approach.</p>
<section id="visualizing-the-alignment-space" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="visualizing-the-alignment-space">Visualizing the alignment space</h3>
<p>Here is a helpful way to think about the alignment problem. Imagine a graph where each path from the starting point to the ending point represents one possible alignment. In this graph, you start at position <span class="math inline">\((0,0)\)</span>, which represents the beginning of both sequences. From there, you can move in three directions. You can move diagonally, which represents aligning one nucleotide or amino acid from each sequence. You can move horizontally, which represents putting a gap in the vertical sequence (so you advance in the horizontal sequence but not the vertical one). Or you can move vertically, which represents putting a gap in the horizontal sequence. Every path through this graph, from the start to the end, corresponds to one valid alignment. The total number of paths through this graph—that is, the number of possible alignments—is astronomical, as we just saw. But notice something important: while the number of paths is enormous, the graph itself has a very regular structure.</p>
<p>This regular structure is the key to solving the problem efficiently. Every node in the graph represents a partial alignment—a state where you have aligned some prefix of the first sequence with some prefix of the second sequence. From each node, you have only three choices for how to extend the alignment: match or mismatch (diagonal move), insert a gap in one sequence (horizontal move), or insert a gap in the other sequence (vertical move). The graph representation reveals that although there are exponentially many paths through the graph, there are only a polynomial number of nodes. Specifically, if the sequences have lengths <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, there are only <span class="math inline">\((m+1) \times (n+1)\)</span> possible nodes in the graph. This observation is crucial. It means that while we cannot afford to enumerate all possible paths (alignments), we can afford to visit all possible nodes (partial alignments). This is the insight that makes dynamic programming work: we can systematically explore the alignment space in a way that guarantees finding the optimal path without explicitly enumerating every single path. The key is to recognize that many different paths pass through the same nodes, and we can exploit this overlap to avoid redundant work.</p>
<div id="cell-fig-alignment-graph" class="cell styled-output" data-fig-format="svg" data-fig-width="7" data-execution_count="2">
<div class="cell-output cell-output-display">
<div id="fig-alignment-graph" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-alignment-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="pairwise_alignment_files/figure-html/fig-alignment-graph-output-1.png" width="496" height="471" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-alignment-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;37.2: The alignment graph for aligning sequences ‘ATC’ and ‘AGC’. Each path from (0,0) to (3,3) represents a possible alignment. Diagonal moves align characters (match/mismatch), horizontal moves insert a gap in the vertical sequence, and vertical moves insert a gap in the horizontal sequence. Two example paths are shown in different colors.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="how-fast-is-fast-enough" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="how-fast-is-fast-enough">How fast is fast enough?</h3>
<p>Now that we have established that exhaustive search is hopeless, let me tell you the good news. The dynamic programming algorithm for sequence alignment, which we will explore in detail later, has a time complexity of <span class="math inline">\(O(mn)\)</span> for two sequences of lengths <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>. What does this mean? It means that the time required to align two sequences grows as the product of their lengths. This is quadratic growth, which is vastly better than the exponential growth of exhaustive search. If you double the length of both sequences, the time required goes up by a factor of four. That is manageable. For protein sequences, which typically have a few hundred amino acids, and for shorter DNA sequences, the <span class="math inline">\(O(mn)\)</span> complexity is very manageable on modern computers. You can align two sequences of length 1000 in a fraction of a second. The space complexity is also <span class="math inline">\(O(mn)\)</span>, meaning that the amount of memory you need grows quadratically with sequence length as well.</p>
<p>Of course, quadratic complexity is not perfect. For genomic sequences that can contain millions or billions of base pairs, this scaling behavior does start to present challenges. Aligning two sequences of length one million would require a matrix with a trillion cells, which starts to push the limits of memory on typical computers. This is why, when we need to align very long sequences like entire chromosomes or genomes, we often turn to heuristic methods that trade off guaranteed optimality for speed. But for most everyday bioinformatics tasks involving genes and proteins, the <span class="math inline">\(O(mn)\)</span> complexity of the Needleman-Wunsch algorithm is perfectly acceptable. It is worth noting, however, that when you extend the alignment problem to more than two sequences—that is, multiple sequence alignment—the problem becomes significantly harder. In fact, multiple sequence alignment with arbitrary scoring schemes has been proven to be NP-hard, which means that it is unlikely that we will ever find an algorithm that can solve it efficiently for large numbers of sequences. This theoretical result underscores the fundamental difficulty of alignment and explains why multiple sequence alignment remains an active area of research where people continue to develop better heuristics and approximation algorithms.</p>
<div id="cell-fig-complexity-comparison" class="cell styled-output" data-fig-format="svg" data-fig-width="7" data-execution_count="3">
<div class="cell-output cell-output-display">
<div id="fig-complexity-comparison" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-complexity-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="pairwise_alignment_files/figure-html/fig-complexity-comparison-output-1.png" width="656" height="469" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-complexity-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;37.3: Comparison of exponential (exhaustive search) versus quadratic (dynamic programming) time complexity for sequence alignment. The number of operations required for exhaustive search grows astronomically with sequence length, while the O(mn) dynamic programming approach remains practical even for moderately long sequences. The shaded region indicates the practical range for typical computers.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="counting-all-possible-alignments" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="counting-all-possible-alignments">Counting all possible alignments</h2>
<p>Let me make the magnitude of the alignment problem more concrete by showing you exactly how many possible alignments exist for sequences of different lengths. The number of global alignments between two sequences can be calculated using the concept of lattice paths. Think of it this way: an alignment is a path through a rectangular grid from coordinates <span class="math inline">\((0,0)\)</span> to <span class="math inline">\((m,n)\)</span>, where <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are the lengths of the two sequences. Each step in the path represents one of three operations: moving right (inserting a gap in the first sequence), moving down (inserting a gap in the second sequence), or moving diagonally (aligning two residues). The total number of such paths is given by what mathematicians call the Delannoy number, which has a formula involving binomial coefficients. But rather than dwell on the formula, let me just show you how these numbers grow. For two sequences of length 10, there are about 8.4 million possible alignments. Not too bad. For sequences of length 20, there are about 14 trillion alignments. Getting worse. For sequences of length 50, there are approximately <span class="math inline">\(5.7 \times 10^{35}\)</span> alignments. And for sequences of length 100—which is still quite short by biological standards—there are roughly <span class="math inline">\(9 \times 10^{73}\)</span> possible alignments. That is a number so large that it defies intuition.</p>
<p>The growth of this number is exponential. In fact, for two sequences of equal length <span class="math inline">\(n\)</span>, the number of alignments grows approximately as <span class="math inline">\(9^n\)</span> (more precisely, like <span class="math inline">\(3^{2n}\)</span> divided by a slowly growing factor). This exponential growth is what makes exhaustive search impossible. But it gets even worse when you think about what is actually involved in finding the optimal alignment. You cannot just count the alignments—you have to score each one to determine which is best. Scoring an alignment takes time proportional to the alignment length, which is <span class="math inline">\(O(m+n)\)</span>. So if you wanted to exhaustively search all alignments, you would need <span class="math inline">\(O((m+n) \times D(m,n))\)</span> time, where <span class="math inline">\(D(m,n)\)</span> is that astronomical Delannoy number. For two sequences of length 100, even if you could evaluate one alignment per nanosecond, you would need more time than has elapsed since the Big Bang to check them all. This is why we absolutely need a better algorithm.</p>
<p>The key insight that saves us is this: while there are exponentially many possible alignments, there are only polynomially many distinct subproblems that we actually need to solve. What do I mean by subproblems? A subproblem is the task of aligning some prefix of the first sequence with some prefix of the second sequence. How many such prefixes are there? Well, the first sequence has <span class="math inline">\(m+1\)</span> possible prefixes (the empty prefix, the first nucleotide, the first two nucleotides, and so on, up to the entire sequence). Similarly, the second sequence has <span class="math inline">\(n+1\)</span> possible prefixes. So there are <span class="math inline">\((m+1) \times (n+1)\)</span> possible subproblems—and that is a polynomial number, not an exponential number. For sequences of length 100, that is about 10,000 subproblems, which is eminently manageable. This observation is the foundation of the dynamic programming approach. Instead of enumerating all possible complete alignments, we will systematically solve all possible subproblems and use those solutions to build up the solution to the full problem. This changes the problem from one that requires exponential time to one that requires only polynomial time.</p>
</section>
<section id="what-makes-an-alignment-optimal" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="what-makes-an-alignment-optimal">What makes an alignment optimal?</h2>
<p>Before we can talk about finding the optimal alignment, we need to be clear about what we mean by “optimal.” An alignment is considered optimal if it achieves the highest possible score among all valid alignments, where the score is calculated according to some predetermined scoring scheme. The scoring scheme is crucial here. It is how we formalize our biological assumptions about what makes sequences similar. A good scoring scheme rewards alignments that reflect true evolutionary relationships while penalizing alignments that merely reflect random similarity. Think about it this way: we assign a score to each possible alignment, and then we look for the alignment with the best score. But how do we score an alignment? Typically, we give positive scores for matching nucleotides or amino acids (or at least higher scores than mismatches), and we penalize gaps because insertions and deletions are evolutionary events that have some cost. The exact numbers we use for these scores and penalties embody our understanding of molecular evolution. The scoring scheme is our way of telling the algorithm what we think is biologically important.</p>
<p>The optimality criterion reflects our understanding of molecular evolution. Sequences that are more similar are presumed to be more closely related evolutionarily, and the optimal alignment should reveal this relationship by maximizing measured similarity while accounting for the evolutionary events—substitutions, insertions, and deletions—that have occurred since the sequences diverged from their common ancestor. Here is the formal definition. Let <span class="math inline">\(A\)</span> be the set of all possible alignments between sequences <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span>. Each alignment <span class="math inline">\(a\)</span> in <span class="math inline">\(A\)</span> can be assigned a score based on our scoring function. The optimal alignment <span class="math inline">\(a^*\)</span> is the one that maximizes this score. We write this mathematically as <span class="math inline">\(a^* = \underset{a\in A}{\operatorname{argmax}} \text{Score}(a)\)</span> over all alignments <span class="math inline">\(a\)</span> in <span class="math inline">\(A\)</span>. This definition assumes we are maximizing similarity, which is the usual convention. Alternatively, we could frame the problem as minimizing distance, in which case we would seek the minimum score, but the principle is the same either way.</p>
<p>Now, here is something important to understand: the optimal alignment represents our best hypothesis about how the sequences are related evolutionarily, but it is only optimal with respect to the chosen scoring scheme. Different scoring schemes can produce different optimal alignments for the same pair of sequences. This is not a bug—it is a feature. It reflects the fact that different evolutionary scenarios may be best modeled by different scoring parameters. For example, if you are comparing very closely related sequences, you might want to use harsh penalties for mismatches and gaps because you expect almost everything to match. But if you are comparing distantly related sequences, you might want to use more permissive scoring because you expect many differences to have accumulated over evolutionary time. The choice of scoring scheme should reflect your biological assumptions about the sequences you are aligning. This is why sequence alignment is not just a computational problem—it requires biological judgment as well.</p>
<p>One more thing to keep in mind: the optimal alignment may not be unique. Multiple different alignments may achieve the same optimal score, particularly for sequences with repetitive regions or regions of low complexity. This non-uniqueness can actually be biologically meaningful—it may reflect genuine uncertainty about the evolutionary relationship between sequences. When multiple optimal alignments exist, most algorithms will just report one of them (typically the first one encountered during the search), but it is worth remembering that other equally good alignments might exist. Some sophisticated implementations can enumerate all optimal alignments or sample from the set of near-optimal alignments, which can be useful for assessing confidence in the alignment. The existence of multiple optimal alignments also raises important questions about how much we should trust specific features of any single reported alignment, especially in regions where the sequences are difficult to align.</p>
</section>
<section id="scoring-matrices-and-gap-penalties" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="scoring-matrices-and-gap-penalties">Scoring matrices and gap penalties</h2>
<p>Now that we have established what an optimal alignment is—the one with the best score—we need to talk about how we actually compute the score of an alignment. This is where scoring matrices and gap penalties come in. A scoring matrix is a table that tells you the score for aligning each possible pair of residues. For protein sequences, this is a 20 by 20 matrix because there are 20 amino acids. For DNA sequences, it is a 4 by 4 matrix for the four nucleotides. The scoring matrix embodies our assumptions about which substitutions are more or less likely during evolution. For DNA, we might use a simple scheme like +1 for a match and -1 for a mismatch, though more sophisticated schemes account for the fact that transitions (A to G or C to T) are more common than transversions (A to C, A to T, G to C, or G to T). For proteins, the scoring schemes are more complex because amino acids have different chemical properties, and some substitutions are much more likely than others. A substitution between two chemically similar amino acids—like leucine and isoleucine, which are both hydrophobic—is much more likely to be tolerated than a substitution between chemically very different amino acids—like aspartate (acidic) and lysine (basic).</p>
<p>The most commonly used scoring matrices for protein alignment are the PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) families. These matrices were derived from empirical observations of substitution patterns in aligned sequences known to be homologous. The idea is simple: look at a large collection of aligned protein sequences, count how often each type of substitution occurs, and use those counts to estimate the probability that two residues are aligned because of homology versus by random chance. The elements of a substitution matrix S are typically log-odds scores. Specifically, S(a,b) is the logarithm of the ratio of two probabilities: the probability of observing residues a and b aligned in homologous sequences divided by the probability of observing them aligned by chance. If this ratio is greater than one, the log is positive, meaning that observing this pair is evidence for homology. If the ratio is less than one, the log is negative, meaning that this pair is more likely to occur by chance than by homology. This log-odds formulation has nice mathematical properties and allows us to add up scores across an alignment to get a total alignment score.</p>
<p>The choice of scoring matrix has a big effect on the resulting alignment. Different scoring matrices are appropriate for sequences at different evolutionary distances. Matrices derived from closely related sequences, like BLOSUM80, have high scores for identities and harsh penalties for mismatches, making them suitable for detecting recent homologs where you expect high sequence identity. Matrices derived from more divergent sequences, like BLOSUM45, are more permissive of substitutions and are better suited for detecting remote homologs where many substitutions have accumulated over evolutionary time. The number in the matrix name gives you a hint about the evolutionary distance it is designed for: BLOSUM62 is a general-purpose matrix suitable for moderate evolutionary distances, while BLOSUM80 is for closely related sequences and BLOSUM45 for distantly related ones. Choosing the right matrix for your specific biological question is important and requires some knowledge of how diverged you expect your sequences to be. In practice, BLOSUM62 is a safe default choice for many applications, but you should be aware that this choice affects your results.</p>
<div id="cell-fig-blosum-matrix" class="cell styled-output" data-fig-format="svg" data-fig-width="6" data-execution_count="4">
<div class="cell-output cell-output-display">
<div id="fig-blosum-matrix" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-blosum-matrix-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="pairwise_alignment_files/figure-html/fig-blosum-matrix-output-1.png" width="557" height="471" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-blosum-matrix-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;37.4: Partial BLOSUM62 substitution matrix showing scores for a subset of amino acids. Positive scores (green) indicate that observing this pair is evidence for homology, while negative scores (red) suggest the pair is more likely due to chance. The diagonal elements (self-matches) have the highest scores. Notice that chemically similar amino acids (like I and L, both hydrophobic) have positive off-diagonal scores.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="gap-penalties" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="gap-penalties">Gap penalties</h2>
<p>Beyond the scoring matrix, which tells us how to score aligned pairs of residues, we also need to decide how to penalize gaps. A gap represents an insertion or deletion event in the evolutionary history of the sequences, and we need some way to account for the cost of introducing gaps into the alignment. The simplest approach is called linear gap costs. Under this model, the cost of a gap is directly proportional to its length. If you have a gap of length k and your gap penalty is d, then the cost of that gap is k times d.&nbsp;So a gap of length 3 costs three times as much as a gap of length 1. The total score of an alignment under linear gap costs is the sum of all the substitution scores from the scoring matrix minus the gap penalty times the total number of gap positions. Mathematically, that is: Score equals the sum over all aligned pairs of S(a_i, b_j) minus d times the number of gaps, where S(a_i, b_j) is the substitution score for aligning residues a_i and b_j from the scoring matrix, and d is the gap penalty.</p>
<p>Now, the linear gap model has a significant biological limitation that you should be aware of. It assumes that each gap position corresponds to an independent insertion or deletion event. So a gap of length 3 is treated as if three separate single-nucleotide indels occurred. But in reality, that is often not how evolution works. Insertions and deletions often occur in larger chunks—a single mutational event might insert or delete multiple residues at once. This means that the evolutionary cost of opening a gap (creating a new gap where there was not one before) is typically higher than the cost of extending an existing gap (making an existing gap one residue longer). The linear gap model does not capture this distinction. It penalizes each gap position equally, whether it is opening a new gap or extending an existing one. Despite this limitation, linear gap costs are still useful. They are mathematically simple, which makes them a good starting point for understanding how alignment algorithms work. They also lead to elegant and efficient dynamic programming algorithms, as you will see shortly.</p>
<div id="fig-gap-penalty-comparison" class="cell quarto-float quarto-figure quarto-figure-center anchored" data-execution_count="5">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gap-penalty-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output cell-output-stdout">
<pre><code>Gap Penalty Models Comparison
============================================================

LINEAR GAP PENALTY (d = 2):
------------------------------------------------------------
Alignment 1 (three separate single-base gaps):
  Seq1: ATGC---GAT
  Seq2: ATGCGGGGA-
  Cost: 3 × d = 3 × 2 = 6

Alignment 2 (one three-base gap):
  Seq1: ATGC---GAT
  Seq2: ATGCGGGGA-
  Cost: 3 × d = 3 × 2 = 6

  → Both alignments have the same cost!


AFFINE GAP PENALTY (d_open = 5, d_extend = 1):
------------------------------------------------------------
Alignment 1 (three separate gaps):
  Seq1: A-TGC-GA-T
  Seq2: ATGGCGGGAT
  Cost: 3 × (d_open + 0 × d_extend) = 3 × 5 = 15

Alignment 2 (one three-base gap):
  Seq1: ATGC---GAT
  Seq2: ATGCGGGGA-
  Cost: d_open + 2 × d_extend = 5 + 2 = 7

  → Alignment 2 (fewer, longer gaps) is preferred!
  → This better reflects how evolution actually works</code></pre>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-gap-penalty-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;37.5
</figcaption>
</figure>
</div>
<p>In the dynamic programming framework, linear gap costs lead to a particularly simple recurrence relation. When we are trying to compute the score for aligning prefixes of length <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, we have exactly three possibilities to consider. First, we could align position <span class="math inline">\(i\)</span> from the first sequence with position <span class="math inline">\(j\)</span> from the second sequence—this corresponds to a diagonal move in our alignment graph. Second, we could align position <span class="math inline">\(i\)</span> from the first sequence with a gap—this corresponds to a horizontal move. Third, we could align a gap with position <span class="math inline">\(j\)</span> from the second sequence—this corresponds to a vertical move. Each of these three possibilities can be evaluated in constant time using our scoring matrix and gap penalty, and we just take the maximum of the three. This gives us our <span class="math inline">\(O(mn)\)</span> time complexity: we have <span class="math inline">\(O(mn)\)</span> cells to fill in our dynamic programming matrix, and each cell requires constant time to compute, so the total time is <span class="math inline">\(O(mn)\)</span>. Nice and simple.</p>
</section>
<section id="the-principle-of-optimality" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="the-principle-of-optimality">The principle of optimality</h2>
<p>Now we come to the key insight that makes dynamic programming work for sequence alignment. It is called the principle of optimality, and it states that an optimal solution to a problem contains optimal solutions to its subproblems. Let me make this concrete. Suppose you have found the optimal alignment of two sequences <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span>. This alignment is the best possible—it has the highest score among all possible alignments. Now, pick any portion of this alignment. Maybe you look at the portion from position <span class="math inline">\(i\)</span> to position <span class="math inline">\(j\)</span> in the first sequence and from position <span class="math inline">\(k\)</span> to position <span class="math inline">\(l\)</span> in the second sequence. The principle of optimality says that this portion must itself be an optimal alignment of the corresponding subsequences <span class="math inline">\(S_1[i..j]\)</span> and <span class="math inline">\(S_2[k..l]\)</span>. Think about why this must be true. If that portion were not optimal, that would mean there exists some better way to align those particular subsequences. But then you could take your overall alignment, cut out the suboptimal portion, plug in the better alignment of those subsequences, and you would have an alignment with a better total score than your supposedly optimal alignment. That is a contradiction. So every portion of an optimal alignment must itself be an optimal alignment of the corresponding subsequences.</p>
<p>This might seem like an abstract property, but it has profound implications for algorithm design. Let me show you why. The principle of optimality tells us that we can build up an optimal alignment by combining optimal alignments of smaller pieces. This is the essence of dynamic programming: solve small problems first, store their solutions, and then use those solutions to solve bigger problems. For sequence alignment, here is how it works. Instead of trying to find the optimal alignment of the full sequences all at once, we systematically compute optimal alignments of all possible pairs of prefixes. What is a prefix? It is just the first <span class="math inline">\(k\)</span> characters of a sequence for some <span class="math inline">\(k\)</span>. Every sequence of length <span class="math inline">\(m\)</span> has <span class="math inline">\(m+1\)</span> prefixes: the empty sequence, the first character, the first two characters, and so on up to the entire sequence. So if we have two sequences of lengths <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, there are <span class="math inline">\((m+1) \times (n+1)\)</span> possible pairs of prefixes. For each pair of prefixes, we compute the optimal alignment score and store it. Then, when we need to compute the optimal alignment of longer prefixes, we can use the stored results for shorter prefixes. This transforms the problem from one requiring exponential time to one requiring only polynomial time.</p>
<p>Let me prove this principle of optimality to you so you can see why it is true. We will use proof by contradiction. Suppose we have an optimal alignment <span class="math inline">\(A^*\)</span> of sequences <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span>, and suppose we look at some portion of this alignment covering positions <span class="math inline">\(i_1\)</span> to <span class="math inline">\(i_2\)</span> in the first sequence and <span class="math inline">\(j_1\)</span> to <span class="math inline">\(j_2\)</span> in the second sequence. Now, assume for the sake of contradiction that this portion is not optimal. That means there exists some other alignment <span class="math inline">\(B\)</span> of these subsequences that has a better score than the corresponding portion of <span class="math inline">\(A^*\)</span>. Okay, so what can we do? We can construct a new alignment <span class="math inline">\(A'\)</span> by taking <span class="math inline">\(A^*\)</span> and replacing the portion from <span class="math inline">\(i_1\)</span> to <span class="math inline">\(i_2\)</span> and <span class="math inline">\(j_1\)</span> to <span class="math inline">\(j_2\)</span> with <span class="math inline">\(B\)</span> while leaving everything else unchanged. What is the score of this new alignment <span class="math inline">\(A'\)</span>? Well, it is the score of <span class="math inline">\(A^*\)</span> minus the score of the portion we removed plus the score of <span class="math inline">\(B\)</span>. Since <span class="math inline">\(B\)</span> has a higher score than the portion we removed, <span class="math inline">\(A'\)</span> has a higher score than <span class="math inline">\(A^*\)</span>. But wait—we said <span class="math inline">\(A^*\)</span> was optimal, meaning it had the highest possible score. So we have a contradiction. Therefore, our assumption must have been wrong, and every portion of an optimal alignment must itself be optimal. This principle is what makes dynamic programming possible for sequence alignment.</p>
</section>
<section id="the-recurrence-relation" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="the-recurrence-relation">The recurrence relation</h2>
<p>The principle of optimality leads directly to a recursive formulation of the alignment problem. Let <span class="math inline">\(F(i,j)\)</span> denote the score of the optimal alignment of the first <span class="math inline">\(i\)</span> characters of sequence <span class="math inline">\(S_1\)</span> with the first <span class="math inline">\(j\)</span> characters of sequence <span class="math inline">\(S_2\)</span>. In other words, <span class="math inline">\(F(i,j)\)</span> is the optimal score for aligning the prefix <span class="math inline">\(S_1[1..i]\)</span> with the prefix <span class="math inline">\(S_2[1..j]\)</span>. Now think about how we could compute <span class="math inline">\(F(i,j)\)</span>. If we have an optimal alignment of these two prefixes, what are the possible ways it could end? There are exactly three possibilities. First, the alignment could end with position <span class="math inline">\(i\)</span> from <span class="math inline">\(S_1\)</span> aligned to position <span class="math inline">\(j\)</span> from <span class="math inline">\(S_2\)</span>—we call this a match if the two residues are the same or a mismatch if they are different. Second, the alignment could end with position <span class="math inline">\(i\)</span> from <span class="math inline">\(S_1\)</span> aligned to a gap—this corresponds to a deletion from <span class="math inline">\(S_1\)</span> or equivalently an insertion into <span class="math inline">\(S_2\)</span>. Third, the alignment could end with a gap aligned to position <span class="math inline">\(j\)</span> from <span class="math inline">\(S_2\)</span>—this corresponds to an insertion into <span class="math inline">\(S_1\)</span> or equivalently a deletion from <span class="math inline">\(S_2\)</span>. These are the only three possibilities, and by the principle of optimality, the best alignment must come from taking the best of these three options.</p>
<p>This gives us our fundamental recurrence relation:</p>
<p><span class="math display">\[
F(i,j) = \max \begin{cases}
F(i-1,j-1) + S(S_1[i], S_2[j]) &amp; \text{(match/mismatch)} \\
F(i-1,j) - d &amp; \text{(deletion)} \\
F(i,j-1) - d &amp; \text{(insertion)}
\end{cases}
\]</span></p>
<p>Here, <span class="math inline">\(S(S_1[i], S_2[j])\)</span> is the score from our substitution matrix for aligning the residue at position <span class="math inline">\(i\)</span> in sequence one with the residue at position <span class="math inline">\(j\)</span> in sequence two, and <span class="math inline">\(d\)</span> is our gap penalty. We take the maximum of these three values, and that is our optimal score for aligning the first <span class="math inline">\(i\)</span> positions of <span class="math inline">\(S_1\)</span> with the first <span class="math inline">\(j\)</span> positions of <span class="math inline">\(S_2\)</span>. This recurrence relation is the heart of the Needleman-Wunsch algorithm, and understanding it is crucial to understanding how dynamic programming solves the alignment problem.</p>
<div class="cell" data-layout-align="default">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>flowchart TD</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    A["F(i-1,j-1)&lt;br/&gt;diagonal&lt;br/&gt;+S(S₁[i],S₂[j])"] --&gt;|match/mismatch| D["MAX"]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    B["F(i-1,j)&lt;br/&gt;above&lt;br/&gt;-d"] --&gt;|deletion| D</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    C["F(i,j-1)&lt;br/&gt;left&lt;br/&gt;-d"] --&gt;|insertion| D</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    D --&gt; E["F(i,j)"]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    style A fill:#e1f5ff,stroke:#0066cc,stroke-width:2px</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    style B fill:#ffe1e1,stroke:#cc0000,stroke-width:2px</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    style C fill:#e1ffe1,stroke:#00cc00,stroke-width:2px</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    style D fill:#fff4e1,stroke:#ff9900,stroke-width:3px</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    style E fill:#f0e1ff,stroke:#9900cc,stroke-width:3px,font-weight:bold</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output-display">
<div id="fig-dp-dependencies" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-dp-dependencies-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<pre class="mermaid mermaid-js" data-label="fig-dp-dependencies">flowchart TD
    A["F(i-1,j-1)&lt;br/&gt;diagonal&lt;br/&gt;+S(S₁[i],S₂[j])"] --&gt;|match/mismatch| D["MAX"]
    B["F(i-1,j)&lt;br/&gt;above&lt;br/&gt;-d"] --&gt;|deletion| D
    C["F(i,j-1)&lt;br/&gt;left&lt;br/&gt;-d"] --&gt;|insertion| D
    D --&gt; E["F(i,j)"]

    style A fill:#e1f5ff,stroke:#0066cc,stroke-width:2px
    style B fill:#ffe1e1,stroke:#cc0000,stroke-width:2px
    style C fill:#e1ffe1,stroke:#00cc00,stroke-width:2px
    style D fill:#fff4e1,stroke:#ff9900,stroke-width:3px
    style E fill:#f0e1ff,stroke:#9900cc,stroke-width:3px,font-weight:bold
</pre>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-dp-dependencies-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;37.6: Computing F(i,j) requires only three previously computed values: F(i-1,j-1) from the diagonal, F(i-1,j) from above, and F(i,j-1) from the left. This local dependency structure is what makes dynamic programming efficient—each cell depends only on its immediate neighbors, not on the entire matrix.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Of course, every recurrence relation needs base cases—initial values that we can compute directly without using the recurrence. For sequence alignment, the base cases are straightforward:</p>
<p><span class="math display">\[
F(0,0) = 0
\]</span></p>
<p><span class="math display">\[
F(i,0) = -i \times d \quad \text{for } i &gt; 0
\]</span></p>
<p><span class="math display">\[
F(0,j) = -j \times d \quad \text{for } j &gt; 0
\]</span></p>
<p>The first base case says that aligning two empty sequences has a score of zero—there is nothing to align, so nothing to score. The other base cases say that aligning a sequence of length <span class="math inline">\(k\)</span> with an empty sequence requires introducing <span class="math inline">\(k\)</span> gaps, each with penalty <span class="math inline">\(d\)</span>. These base cases give us the initial values along the top edge and left edge of our dynamic programming matrix, and from there we can use the recurrence relation to fill in the rest of the matrix row by row or column by column.</p>
<div id="cell-fig-dp-matrix-example" class="cell styled-output" data-fig-format="svg" data-fig-width="5" data-execution_count="6">
<div class="cell-output cell-output-display">
<div id="fig-dp-matrix-example" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-dp-matrix-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="pairwise_alignment_files/figure-html/fig-dp-matrix-example-output-1.png" width="442" height="372" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-dp-matrix-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;37.7: A complete dynamic programming matrix for aligning ‘AGC’ with ‘ATC’ using match=+1, mismatch=-1, gap=-2. The matrix is filled row by row using the recurrence relation. Each cell shows the optimal score for aligning the corresponding prefixes. Arrows indicate which predecessor contributed the maximum score: ↖ = diagonal (match/mismatch), ↑ = up (deletion), ← = left (insertion).
</figcaption>
</figure>
</div>
</div>
</div>
<p>Now, here is an important point about the recursive structure. You might be tempted to implement this recurrence directly as a recursive function. But if you did that without memoization, you would get exponential time complexity. Why? Because the same subproblems would be computed over and over again. For example, <span class="math inline">\(F(i-1,j-1)\)</span> could be reached through multiple different paths in the recursion tree. You might compute it once when computing <span class="math inline">\(F(i,j)\)</span>, and then compute it again when computing <span class="math inline">\(F(i,j-1)\)</span>, and yet again when computing <span class="math inline">\(F(i-1,j)\)</span>. All these redundant computations would add up to exponential time. This is why we use dynamic programming instead of naive recursion. Dynamic programming solves each subproblem exactly once and stores the result in a table, so we never have to recompute the same subproblem. This is what reduces the time complexity from exponential to polynomial.</p>
<p>One final note about the recurrence relation: while it allows us to compute the score of the optimal alignment, recovering the alignment itself—the actual sequence of matches, mismatches, and gaps—requires some additional bookkeeping. As we compute <span class="math inline">\(F(i,j)\)</span> for each cell, we need to remember which of the three options (match/mismatch, deletion, or insertion) gave us the maximum score. We can store this information in a separate traceback matrix, where each cell records which predecessor cell we came from. Then, after we have filled in the entire scoring matrix and know that <span class="math inline">\(F(m,n)\)</span> is the optimal score, we can recover the actual alignment by following the traceback pointers backwards from position <span class="math inline">\((m,n)\)</span> to position <span class="math inline">\((0,0)\)</span>. Each step of the traceback tells us one operation in the alignment: diagonal move means match or mismatch, vertical move means gap in the horizontal sequence, horizontal move means gap in the vertical sequence. By following these traceback pointers, we reconstruct the optimal alignment.</p>
<div id="cell-fig-traceback-path" class="cell styled-output" data-fig-format="svg" data-fig-width="7" data-execution_count="7">
<div class="cell-output cell-output-display">
<div id="fig-traceback-path" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-traceback-path-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="pairwise_alignment_files/figure-html/fig-traceback-path-output-1.png" width="663" height="382" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-traceback-path-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;37.8: Traceback visualization showing the optimal path (in bold red) through the DP matrix from (3,3) back to (0,0). Following this path backwards reconstructs the alignment: A-GC vs ATC-, with score -1. The path interpretation: 1. Start at (3,3), 2. ↖ diagonal: C ↔︎ C (match), 3. ↖ diagonal: G ↔︎ T (mismatch), 4. ↑ up: A ↔︎ - (gap in seq2), 5. ↖ diagonal: A ↔︎ A (match)
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="the-needleman-wunsch-algorithm" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="the-needleman-wunsch-algorithm">The Needleman-Wunsch algorithm</h2>
<p>Now we are ready to see how all of these pieces fit together into the Needleman-Wunsch algorithm. Published in 1970 by Saul Needleman and Christian Wunsch, this was the first application of dynamic programming to biological sequence alignment, and it remains one of the foundational algorithms in bioinformatics. The algorithm systematically fills a two-dimensional table where entry <span class="math inline">\((i,j)\)</span> contains the score of the optimal alignment of the first <span class="math inline">\(i\)</span> characters of <span class="math inline">\(S_1\)</span> with the first <span class="math inline">\(j\)</span> characters of <span class="math inline">\(S_2\)</span>. Once the table is filled, we can read off the optimal score from the bottom-right corner, and we can recover the actual alignment by tracing back through the table. The algorithm has two phases: the forward phase, where we fill in the scoring matrix, and the traceback phase, where we reconstruct the optimal alignment. Let me walk you through both phases step by step.</p>
<p><strong>Phase 1: Fill the scoring matrix</strong></p>
<pre><code># Initialize base cases
F[0,0] = 0
for i = 1 to m:
    F[i,0] = -i × d
    Traceback[i,0] = UP
for j = 1 to n:
    F[0,j] = -j × d
    Traceback[0,j] = LEFT

# Fill the matrix
for i = 1 to m:
    for j = 1 to n:
        match = F[i-1,j-1] + S[S₁[i], S₂[j]]
        delete = F[i-1,j] - d
        insert = F[i,j-1] - d

        F[i,j] = max(match, delete, insert)

        if F[i,j] == match:
            Traceback[i,j] = DIAGONAL
        else if F[i,j] == delete:
            Traceback[i,j] = UP
        else:
            Traceback[i,j] = LEFT</code></pre>
<p>In the forward phase, we start by initializing the base cases. We set <span class="math inline">\(F(0,0)\)</span> equal to zero because aligning two empty sequences has a score of zero. Then, for <span class="math inline">\(i\)</span> from 1 to <span class="math inline">\(m\)</span>, we set <span class="math inline">\(F(i,0)\)</span> equal to <span class="math inline">\(-i \times d\)</span>, representing the cost of aligning a prefix of <span class="math inline">\(S_1\)</span> with the empty sequence. Similarly, for <span class="math inline">\(j\)</span> from 1 to <span class="math inline">\(n\)</span>, we set <span class="math inline">\(F(0,j)\)</span> equal to <span class="math inline">\(-j \times d\)</span>. These initializations fill in the top row and leftmost column of our matrix. Now comes the main computation. We have two nested loops: the outer loop over <span class="math inline">\(i\)</span> from 1 to <span class="math inline">\(m\)</span>, and the inner loop over <span class="math inline">\(j\)</span> from 1 to <span class="math inline">\(n\)</span>. For each cell <span class="math inline">\((i,j)\)</span>, we compute three quantities. First, match equals <span class="math inline">\(F(i-1,j-1) + S(S_1[i], S_2[j])\)</span>—this is the score if we align position <span class="math inline">\(i\)</span> with position <span class="math inline">\(j\)</span>. Second, delete equals <span class="math inline">\(F(i-1,j) - d\)</span>—this is the score if we align position <span class="math inline">\(i\)</span> with a gap. Third, insert equals <span class="math inline">\(F(i,j-1) - d\)</span>—this is the score if we align a gap with position <span class="math inline">\(j\)</span>. We set <span class="math inline">\(F(i,j)\)</span> equal to the maximum of these three values. Crucially, we also record which of the three operations gave us the maximum, because we will need this information during traceback. This recording can be done with a separate traceback matrix that stores a pointer or code indicating whether we came from the diagonal, from above, or from the left.</p>
<div id="cell-fig-algorithm-stages" class="cell styled-output" data-fig-format="svg" data-fig-width="6" data-execution_count="8">
<div class="cell-output cell-output-display">
<div id="fig-algorithm-stages" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-algorithm-stages-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="pairwise_alignment_files/figure-html/fig-algorithm-stages-output-1.png" width="536" height="563" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-algorithm-stages-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;37.9: Progressive stages of the Needleman-Wunsch algorithm. (a) Empty matrix, (b) Base cases initialized, (c) After first row computed, (d) Complete matrix with all cells filled. The matrix is filled systematically row by row, with each cell depending only on previously computed neighbors.
</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Phase 2: Traceback to recover the alignment</strong></p>
<pre><code># Start at bottom-right cell
i = m
j = n
alignment₁ = ""
alignment₂ = ""

# Follow traceback pointers
while i &gt; 0 or j &gt; 0:
    if Traceback[i,j] == DIAGONAL:
        alignment₁ = S₁[i] + alignment₁
        alignment₂ = S₂[j] + alignment₂
        i = i - 1
        j = j - 1
    else if Traceback[i,j] == UP:
        alignment₁ = S₁[i] + alignment₁
        alignment₂ = "-" + alignment₂
        i = i - 1
    else:  # LEFT
        alignment₁ = "-" + alignment₁
        alignment₂ = S₂[j] + alignment₂
        j = j - 1

return (alignment₁, alignment₂, F[m,n])</code></pre>
<p>After the forward phase completes, <span class="math inline">\(F(m,n)\)</span> contains the score of the optimal alignment of the full sequences. But we usually also want to know what the actual alignment is, not just its score. This is where the traceback phase comes in. We start at cell <span class="math inline">\((m,n)\)</span> and work our way back to cell <span class="math inline">\((0,0)\)</span>, following the traceback pointers we recorded during the forward phase. At each step, we look at the traceback pointer for the current cell. If it points diagonally (to cell <span class="math inline">\((i-1,j-1)\)</span>), that means we aligned <span class="math inline">\(S_1[i]\)</span> with <span class="math inline">\(S_2[j]\)</span>, so we add this pair to our alignment. If it points upward (to cell <span class="math inline">\((i-1,j)\)</span>), that means we aligned <span class="math inline">\(S_1[i]\)</span> with a gap, so we add a gap character in the second sequence. If it points leftward (to cell <span class="math inline">\((i,j-1)\)</span>), that means we aligned a gap with <span class="math inline">\(S_2[j]\)</span>, so we add a gap character in the first sequence. We continue following these pointers until we reach <span class="math inline">\((0,0)\)</span>, at which point we have reconstructed the entire alignment. Note that we build the alignment from right to left (prepending characters), so it comes out in the correct order. The beauty of this algorithm is that it guarantees finding the optimal alignment in <span class="math inline">\(O(mn)\)</span> time by cleverly avoiding all the redundant computation that a naive recursive approach would entail. <!-- 
The space complexity of the standard Needleman-Wunsch algorithm is also $O(mn)$ because we need to store the entire scoring matrix and traceback matrix. For very long sequences, this can become prohibitive. If you only need the score and not the alignment itself, you can reduce the space complexity to $O(\min(m,n))$ by observing that when you compute row $i$, you only need the values from row $i-1$, so you can discard all earlier rows. Even better, there is a clever divide-and-conquer algorithm called Hirschberg's algorithm that computes the actual alignment in $O(mn)$ time but using only $O(m+n)$ space. The trick is to find the midpoint of the optimal alignment using a clever space-efficient technique, and then recursively align the sequences before and after this midpoint. Hirschberg's algorithm is beyond the scope of this chapter, but it is worth knowing that it exists for when you need to align very long sequences and memory is a constraint. 


::::::{.cell layout-align="default"}

```{.default .cell-code}
flowchart LR
    subgraph full["Full Matrix O(mn)"]
        A1["Row 0<br/>(base cases)"]
        A2["Row 1"]
        A3["Row 2"]
        A4["Row 3"]
        A5["..."]
        A6["Row m"]
        A1 -.-> A2
        A2 -.-> A3
        A3 -.-> A4
        A4 -.-> A5
        A5 -.-> A6
    end

    subgraph opt["Space-Optimized O(min(m,n))"]
        B1["Previous Row<br/>(read only)"]
        B2["Current Row<br/>(being computed)"]
        B1 ==>|depends on| B2
        B2 -.->|becomes previous| B1
    end

    full ==>|optimize| opt

    style full fill:#ffe1e1,stroke:#cc0000,stroke-width:2px
    style opt fill:#e1ffe1,stroke:#00cc00,stroke-width:3px
    style A1 fill:#fff4e1,stroke:#666666
    style A2 fill:#fff4e1,stroke:#666666
    style A3 fill:#fff4e1,stroke:#666666
    style A4 fill:#fff4e1,stroke:#666666
    style A5 fill:#fff4e1,stroke:#666666
    style A6 fill:#fff4e1,stroke:#666666
    style B1 fill:#e1f5ff,stroke:#0066cc,stroke-width:2px
    style B2 fill:#f0e1ff,stroke:#9900cc,stroke-width:2px
```

:::::{.cell-output-display}

::::{#fig-space-optimization}

:::{}

<pre class="mermaid mermaid-js" data-label="fig-space-optimization">
flowchart LR
    subgraph full[&quot;Full Matrix O(mn)&quot;]
        A1[&quot;Row 0&lt;br/&gt;(base cases)&quot;]
        A2[&quot;Row 1&quot;]
        A3[&quot;Row 2&quot;]
        A4[&quot;Row 3&quot;]
        A5[&quot;...&quot;]
        A6[&quot;Row m&quot;]
        A1 -.-&gt; A2
        A2 -.-&gt; A3
        A3 -.-&gt; A4
        A4 -.-&gt; A5
        A5 -.-&gt; A6
    end

    subgraph opt[&quot;Space-Optimized O(min(m,n))&quot;]
        B1[&quot;Previous Row&lt;br/&gt;(read only)&quot;]
        B2[&quot;Current Row&lt;br/&gt;(being computed)&quot;]
        B1 ==&gt;|depends on| B2
        B2 -.-&gt;|becomes previous| B1
    end

    full ==&gt;|optimize| opt

    style full fill:#ffe1e1,stroke:#cc0000,stroke-width:2px
    style opt fill:#e1ffe1,stroke:#00cc00,stroke-width:3px
    style A1 fill:#fff4e1,stroke:#666666
    style A2 fill:#fff4e1,stroke:#666666
    style A3 fill:#fff4e1,stroke:#666666
    style A4 fill:#fff4e1,stroke:#666666
    style A5 fill:#fff4e1,stroke:#666666
    style A6 fill:#fff4e1,stroke:#666666
    style B1 fill:#e1f5ff,stroke:#0066cc,stroke-width:2px
    style B2 fill:#f0e1ff,stroke:#9900cc,stroke-width:2px
</pre>
:::


Space optimization for computing alignment scores. The full matrix (left) requires O(mn) space. However, since each row only depends on the previous row, we only need to keep two rows in memory at once (right), reducing space to O(min(m,n)). The current row being computed uses values from the previous row, which can then be discarded.
::::
:::::
::::::

A few practical implementation considerations are worth mentioning. First, for long sequences or extreme scoring parameters, the scores can become very large (or very negative), potentially exceeding the range of standard integer types, so you may need to use larger integer types or even floating-point numbers. Second, when multiple operations yield the same maximum score—which happens frequently—you need consistent tie-breaking rules. Usually, implementations just pick one ordering (like preferring diagonal over vertical over horizontal), but the choice can affect which of multiple equally optimal alignments you report. Third, for large sequences, careful attention to memory access patterns can significantly affect performance due to cache effects. Finally, the algorithm has some inherent parallelism: all cells along a given anti-diagonal can be computed in parallel because they do not depend on each other. This property can be exploited on multi-core systems or GPUs to speed up the computation for very large alignment problems. --></p>
</section>
<section id="understanding-memoization-and-the-dynamic-programming-matrix" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="understanding-memoization-and-the-dynamic-programming-matrix">Understanding memoization and the dynamic programming matrix</h2>
<p>The magic of dynamic programming lies in a technique called memoization, which just means storing the results of computations so you do not have to repeat them. For sequence alignment, each subproblem corresponds to aligning a prefix of one sequence with a prefix of the other sequence. The key insight is simple but powerful: once we have computed the optimal score for aligning the first <span class="math inline">\(i\)</span> characters of <span class="math inline">\(S_1\)</span> with the first <span class="math inline">\(j\)</span> characters of <span class="math inline">\(S_2\)</span>, we store that score in a table, and whenever we need it again, we just look it up instead of recomputing it. The storage mechanism is a two-dimensional array <span class="math inline">\(F\)</span>, where <span class="math inline">\(F[i,j]\)</span> stores the score of the optimal alignment of <span class="math inline">\(S_1[1..i]\)</span> with <span class="math inline">\(S_2[1..j]\)</span>. This array is our memoization table, and it is what transforms an exponential-time recursive algorithm into a polynomial-time iterative one. Without memoization, we would recompute the same subproblems over and over again, leading to exponential time complexity. With memoization, we compute each subproblem exactly once and then reuse the stored result whenever we need it.</p>
<p>The dynamic programming approach builds solutions to larger problems from solutions to smaller problems in a systematic way. The key is to compute things in an order that ensures all the values we need are already available when we need them. For sequence alignment, this usually means filling the matrix row by row from top to bottom or column by column from left to right, though any order that respects the dependencies between cells will work. What are these dependencies? For each cell <span class="math inline">\(F[i,j]\)</span>, we need three previously computed values: <span class="math inline">\(F[i-1,j-1]\)</span> (the diagonal predecessor), <span class="math inline">\(F[i-1,j]\)</span> (the predecessor directly above), and <span class="math inline">\(F[i,j-1]\)</span> (the predecessor directly to the left). As long as we fill cells in an order that ensures these three predecessors are already computed when we need them, we are fine. This local dependency structure is what makes the algorithm efficient. Each cell only depends on three immediate neighbors, not on the entire matrix, so we can compute cells incrementally without having to store or process unnecessary information.</p>
<p>The completed dynamic programming matrix is more than just a tool for computing the optimal score—it contains rich information about the relationship between the sequences. The bottom-right cell <span class="math inline">\(F[m,n]\)</span> gives us the optimal alignment score, but every other cell also tells us something interesting. <span class="math inline">\(F[i,j]\)</span> gives the optimal score for aligning the first <span class="math inline">\(i\)</span> characters of <span class="math inline">\(S_1\)</span> with the first <span class="math inline">\(j\)</span> characters of <span class="math inline">\(S_2\)</span>, so the entire matrix gives us optimal scores for all possible pairs of prefixes. This can be useful if, for example, you want to find the best alignment of a short prefix of one sequence with the full other sequence. The pattern of values in the matrix also reveals regions of high and low similarity between the sequences. High scores in a region indicate strong similarity, while low scores indicate dissimilarity. You can even use the matrix to identify alternative alignments that score nearly as well as the optimal one by tracing near-optimal paths through the matrix. This can be valuable for assessing how confident we should be in specific features of the reported alignment.</p>
</section>
<section id="variations-and-extensions" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="variations-and-extensions">Variations and Extensions</h2>
<section id="affine-gap-penalties" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="affine-gap-penalties">Affine Gap Penalties</h3>
<p>While linear gap costs provide a simple model, affine gap penalties offer a more biologically realistic representation of insertion and deletion events. Under the affine gap model, the cost of a gap of length <span class="math inline">\(k\)</span> is:</p>
<p><span class="math display">\[
\text{Gap cost} = d_{\text{open}} + (k-1) \times d_{\text{extend}}
\]</span></p>
<p>where <span class="math inline">\(d_{\text{open}}\)</span> is the gap opening penalty and <span class="math inline">\(d_{\text{extend}}\)</span> is the gap extension penalty, with typically <span class="math inline">\(d_{\text{open}} \gg d_{\text{extend}}\)</span>.</p>
<p>Implementing affine gap penalties requires a modified dynamic programming approach with three matrices instead of one: - <span class="math inline">\(M[i,j]\)</span>: Best score ending with <span class="math inline">\(S_1[i]\)</span> aligned to <span class="math inline">\(S_2[j]\)</span> - <span class="math inline">\(I_x[i,j]\)</span>: Best score ending with <span class="math inline">\(S_1[i]\)</span> aligned to a gap - <span class="math inline">\(I_y[i,j]\)</span>: Best score ending with a gap aligned to <span class="math inline">\(S_2[j]\)</span></p>
<p>The recurrence relations become more complex but maintain the same <span class="math inline">\(O(mn)\)</span> time complexity.</p>
</section>
<section id="local-alignment" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="local-alignment">Local Alignment</h3>
<p>While global alignment aligns entire sequences, local alignment (Smith-Waterman algorithm) finds the best-matching subsequences within two sequences. This is achieved through two key modifications:</p>
<ol type="1">
<li>Allow the alignment to start at any position by initializing all edges to 0</li>
<li>Allow the alignment to end at any position by taking the maximum over the entire matrix</li>
</ol>
<p>The recurrence relation becomes:</p>
<p><span class="math display">\[
F(i,j) = \max \begin{cases}
0 &amp; \text{(start new alignment)} \\
F(i-1,j-1) + S(S_1[i], S_2[j]) \\
F(i-1,j) - d \\
F(i,j-1) - d
\end{cases}
\]</span></p>
</section>
</section>
<section id="conclusion" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Pairwise global sequence alignment represents a fundamental operation in computational biology, providing the foundation for understanding evolutionary relationships, predicting function, and identifying important biological features. The application of dynamic programming to this problem, first demonstrated by Needleman and Wunsch, transformed an exponentially complex problem into one solvable in polynomial time, enabling the analysis of biological sequences at scale.</p>
<p>The elegance of the dynamic programming solution lies in its exploitation of the principle of optimality—the recognition that optimal alignments contain optimal sub-alignments. This principle allows us to build up the solution systematically, storing and reusing the scores of sub-alignments to avoid redundant computation. The resulting algorithm, with its <span class="math inline">\(O(mn)\)</span> time complexity, makes it feasible to align sequences of biologically relevant length, from individual genes to entire chromosomes.</p>
<p>The scoring framework for alignment, encompassing substitution matrices and gap penalties, provides a flexible system for modeling different evolutionary scenarios. While simple scoring schemes like linear gap costs have limitations, they serve as important baselines and teaching tools. More sophisticated models, such as affine gap penalties and position-specific scoring, better capture biological reality but require more complex algorithms.</p>
<p>The impact of pairwise global alignment extends far beyond its original application. The algorithmic framework has inspired solutions to numerous other problems in bioinformatics, from RNA structure prediction to gene finding. The conceptual framework—representing biological problems as optimization problems solvable by dynamic programming—has become a cornerstone of computational biology.</p>
<p>Looking forward, sequence alignment continues to evolve in response to new challenges and opportunities. The massive scale of modern sequence databases requires continued algorithmic innovation. The integration of machine learning approaches promises to capture complex patterns in sequence evolution that traditional methods might miss. The increasing availability of structural information provides new constraints that can improve alignment accuracy.</p>
<p>As we enter an era where sequencing entire genomes is routine and comparing thousands of genomes is feasible, the principles established by the study of pairwise global alignment remain relevant. The fundamental challenge—finding meaningful similarities between sequences despite the noise introduced by billions of years of evolution—continues to drive innovation in computational biology. The solutions to this challenge, built on the foundation of dynamic programming and optimal alignment, will continue to provide insights into the molecular basis of life for years to come.</p>
<p>The story of pairwise global sequence alignment is thus not just a tale of algorithmic elegance but a testament to the power of computational thinking in biology. By formulating biological questions in precise mathematical terms and developing efficient algorithms to answer them, we gain not just practical tools but deeper understanding of the principles governing molecular evolution. As sequencing technologies continue to advance and our databases continue to grow, the methods and insights derived from the study of sequence alignment will remain central to our efforts to decode the information written in the language of DNA and proteins.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../chapters/project/assembly_project/index.html" class="pagination-link" aria-label="Genome assembly">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">36</span>&nbsp; <span class="chapter-title">Genome assembly</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/bioinformatics/multiple_alignment.html" class="pagination-link" aria-label="Multiple Alignment">
        <span class="nav-page-text"><span class="chapter-number">38</span>&nbsp; <span class="chapter-title">Multiple Alignment</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>