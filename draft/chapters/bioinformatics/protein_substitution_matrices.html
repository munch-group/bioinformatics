<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>41&nbsp; Scoring Matrices – Bioinformatics and Programming</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/web/mrsa_blast_multalign/index.html" rel="next">
<link href="../../chapters/web/ccr5_pwalign/index.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-20f424e7bd2e25dfd45129c9906c9df5.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-7b6dd81834b739ce5ef7482f5ddde1ad.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/preface.html">Bioinformatics</a></li><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/protein_substitution_matrices.html"><span class="chapter-number">41</span>&nbsp; <span class="chapter-title">Scoring Matrices</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Content</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Exam information</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../curriculum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Curriculum</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Learning Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Preface</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/before_you_begin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Before you begin</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/writing_a_program.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Writing a program</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/dealing_with_values.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dealing with values</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/the_order_of_events.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">The order of events</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/course_tools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Course tools</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/controlling_behavior.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Controlling behavior</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/organizing_your_code.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Organizing code</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/python_values_are_objects.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Values are objects</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/lists.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Lists of things</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/dictionaries.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Pairs of things</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/gluing_values_in_sequence.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Grouping values</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/iteration_over_values.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Iterating values</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/working_with_data_files.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Working with files</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/data_structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Structuring data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/unleash_your_functions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Recursion</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/testing_your_code.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Testing your code</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/your_own_types_of_objects.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Your Own Objects</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/using_code_from_other_files.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Code in other files</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/on_the_shoulders_of_giants.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Giant’s shoulders</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/python/appendix_bsf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Appendix: PyMol for BSF</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Bioinformatics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Preface</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/association.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Genetic Association</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/gwas_databases/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">GWAS candidates</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/databases.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Databases</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/database_searching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Database Searching</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/translation_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Translating ORFs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/hidden_markov_models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">29</span>&nbsp; <span class="chapter-title">Hidden Markov Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/new_hmm_exercise/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">30</span>&nbsp; <span class="chapter-title">Membrane proteins</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/orf_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">31</span>&nbsp; <span class="chapter-title">Finding genes</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/neural_networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">32</span>&nbsp; <span class="chapter-title">Neural networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/neural_networks/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">33</span>&nbsp; <span class="chapter-title">Neural networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/folding_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">34</span>&nbsp; <span class="chapter-title">Primer analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/assembly_and_mapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">35</span>&nbsp; <span class="chapter-title">Genome Sequencing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/assembly_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">36</span>&nbsp; <span class="chapter-title">Genome assembly</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/pairwise_alignment.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">37</span>&nbsp; <span class="chapter-title">Pairwise Alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/multiple_alignment.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">38</span>&nbsp; <span class="chapter-title">Multiple Alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/alignment_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">39</span>&nbsp; <span class="chapter-title">Pairwise alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/ccr5_pwalign/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">40</span>&nbsp; <span class="chapter-title">CCR5-delta32</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/protein_substitution_matrices.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">41</span>&nbsp; <span class="chapter-title">Scoring Matrices</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/database_searching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Database Searching</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/mrsa_blast_multalign/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">43</span>&nbsp; <span class="chapter-title">MRSA</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/hiv_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">44</span>&nbsp; <span class="chapter-title">HIV sub-groups</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/multiple_alignment.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">38</span>&nbsp; <span class="chapter-title">Multiple Alignment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/clustering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">46</span>&nbsp; <span class="chapter-title">Clustering of sequences</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/project/seqdist_project/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">47</span>&nbsp; <span class="chapter-title">Sequence trees</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/models_of_dna_evolution.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">48</span>&nbsp; <span class="chapter-title">Models of DNA Evolution</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/bioinformatics/phylogenetics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">49</span>&nbsp; <span class="chapter-title">Phylogenetics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/aardwark_seqdist/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">50</span>&nbsp; <span class="chapter-title">Aardvark?</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/web/orf_finding/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">51</span>&nbsp; <span class="chapter-title">Plasmid ORFs</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Supplementary</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/project_files.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Project files</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/recordings2025.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture recordings</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/slides2024.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture slides</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../supplementary/bioinformatics_resources.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Databases and resources</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../assignments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Assignments</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../exam.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exam info</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/trouble_shooting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Trouble shooting</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction-to-protein-sequence-scoring" id="toc-introduction-to-protein-sequence-scoring" class="nav-link active" data-scroll-target="#introduction-to-protein-sequence-scoring">Introduction to Protein Sequence Scoring</a>
  <ul class="collapse">
  <li><a href="#evolution-as-natures-experiment-in-protein-engineering" id="toc-evolution-as-natures-experiment-in-protein-engineering" class="nav-link" data-scroll-target="#evolution-as-natures-experiment-in-protein-engineering">Evolution as Nature’s Experiment in Protein Engineering</a></li>
  <li><a href="#quantifying-substitution-patterns" id="toc-quantifying-substitution-patterns" class="nav-link" data-scroll-target="#quantifying-substitution-patterns">Quantifying Substitution Patterns</a></li>
  <li><a href="#the-need-for-multiple-scoring-matrices" id="toc-the-need-for-multiple-scoring-matrices" class="nav-link" data-scroll-target="#the-need-for-multiple-scoring-matrices">The Need for Multiple Scoring Matrices</a></li>
  </ul></li>
  <li><a href="#pam-matrices-modeling-evolution-through-time" id="toc-pam-matrices-modeling-evolution-through-time" class="nav-link" data-scroll-target="#pam-matrices-modeling-evolution-through-time">PAM Matrices: Modeling Evolution Through Time</a>
  <ul class="collapse">
  <li><a href="#the-evolutionary-model-behind-pam" id="toc-the-evolutionary-model-behind-pam" class="nav-link" data-scroll-target="#the-evolutionary-model-behind-pam">The Evolutionary Model Behind PAM</a></li>
  <li><a href="#constructing-pam-matrices-from-data" id="toc-constructing-pam-matrices-from-data" class="nav-link" data-scroll-target="#constructing-pam-matrices-from-data">Constructing PAM Matrices from Data</a></li>
  <li><a href="#extrapolating-to-higher-pam-distances" id="toc-extrapolating-to-higher-pam-distances" class="nav-link" data-scroll-target="#extrapolating-to-higher-pam-distances">Extrapolating to Higher PAM Distances</a></li>
  <li><a href="#worked-example-constructing-a-pam1-matrix" id="toc-worked-example-constructing-a-pam1-matrix" class="nav-link" data-scroll-target="#worked-example-constructing-a-pam1-matrix">Worked Example: Constructing a PAM1 Matrix</a></li>
  <li><a href="#python-implementation-pam-matrix-from-pairwise-alignment" id="toc-python-implementation-pam-matrix-from-pairwise-alignment" class="nav-link" data-scroll-target="#python-implementation-pam-matrix-from-pairwise-alignment">Python Implementation: PAM Matrix from Pairwise Alignment</a></li>
  <li><a href="#limitations-and-assumptions-of-pam-matrices" id="toc-limitations-and-assumptions-of-pam-matrices" class="nav-link" data-scroll-target="#limitations-and-assumptions-of-pam-matrices">Limitations and Assumptions of PAM Matrices</a></li>
  </ul></li>
  <li><a href="#blosum-matrices-an-empirical-approach" id="toc-blosum-matrices-an-empirical-approach" class="nav-link" data-scroll-target="#blosum-matrices-an-empirical-approach">BLOSUM Matrices: An Empirical Approach</a>
  <ul class="collapse">
  <li><a href="#the-blocks-database-foundation" id="toc-the-blocks-database-foundation" class="nav-link" data-scroll-target="#the-blocks-database-foundation">The BLOCKS Database Foundation</a></li>
  <li><a href="#computing-blosum-matrices" id="toc-computing-blosum-matrices" class="nav-link" data-scroll-target="#computing-blosum-matrices">Computing BLOSUM Matrices</a></li>
  <li><a href="#the-log-odds-scoring-system" id="toc-the-log-odds-scoring-system" class="nav-link" data-scroll-target="#the-log-odds-scoring-system">The Log-Odds Scoring System</a></li>
  <li><a href="#the-blosum-series-and-clustering-thresholds" id="toc-the-blosum-series-and-clustering-thresholds" class="nav-link" data-scroll-target="#the-blosum-series-and-clustering-thresholds">The BLOSUM Series and Clustering Thresholds</a></li>
  <li><a href="#worked-example-constructing-a-blosum-matrix" id="toc-worked-example-constructing-a-blosum-matrix" class="nav-link" data-scroll-target="#worked-example-constructing-a-blosum-matrix">Worked Example: Constructing a BLOSUM Matrix</a></li>
  </ul></li>
  <li><a href="#comparative-analysis-of-pam-and-blosum" id="toc-comparative-analysis-of-pam-and-blosum" class="nav-link" data-scroll-target="#comparative-analysis-of-pam-and-blosum">Comparative Analysis of PAM and BLOSUM</a>
  <ul class="collapse">
  <li><a href="#theoretical-versus-empirical-approaches" id="toc-theoretical-versus-empirical-approaches" class="nav-link" data-scroll-target="#theoretical-versus-empirical-approaches">Theoretical Versus Empirical Approaches</a></li>
  <li><a href="#information-content-and-entropy-considerations" id="toc-information-content-and-entropy-considerations" class="nav-link" data-scroll-target="#information-content-and-entropy-considerations">Information Content and Entropy Considerations</a></li>
  <li><a href="#statistical-significance-and-e-values" id="toc-statistical-significance-and-e-values" class="nav-link" data-scroll-target="#statistical-significance-and-e-values">Statistical Significance and E-values</a></li>
  </ul></li>
  <li><a href="#specialized-matrices-and-modern-developments" id="toc-specialized-matrices-and-modern-developments" class="nav-link" data-scroll-target="#specialized-matrices-and-modern-developments">Specialized Matrices and Modern Developments</a>
  <ul class="collapse">
  <li><a href="#position-specific-scoring-matrices-pssms" id="toc-position-specific-scoring-matrices-pssms" class="nav-link" data-scroll-target="#position-specific-scoring-matrices-pssms">Position-Specific Scoring Matrices (PSSMs)</a></li>
  <li><a href="#structure-based-substitution-matrices" id="toc-structure-based-substitution-matrices" class="nav-link" data-scroll-target="#structure-based-substitution-matrices">Structure-Based Substitution Matrices</a></li>
  <li><a href="#compositionally-adjusted-matrices" id="toc-compositionally-adjusted-matrices" class="nav-link" data-scroll-target="#compositionally-adjusted-matrices">Compositionally Adjusted Matrices</a></li>
  </ul></li>
  <li><a href="#practical-considerations-in-matrix-selection" id="toc-practical-considerations-in-matrix-selection" class="nav-link" data-scroll-target="#practical-considerations-in-matrix-selection">Practical Considerations in Matrix Selection</a>
  <ul class="collapse">
  <li><a href="#choosing-matrices-for-specific-applications" id="toc-choosing-matrices-for-specific-applications" class="nav-link" data-scroll-target="#choosing-matrices-for-specific-applications">Choosing Matrices for Specific Applications</a></li>
  <li><a href="#gap-penalties-and-matrix-scaling" id="toc-gap-penalties-and-matrix-scaling" class="nav-link" data-scroll-target="#gap-penalties-and-matrix-scaling">Gap Penalties and Matrix Scaling</a></li>
  <li><a href="#performance-evaluation-and-benchmarking" id="toc-performance-evaluation-and-benchmarking" class="nav-link" data-scroll-target="#performance-evaluation-and-benchmarking">Performance Evaluation and Benchmarking</a></li>
  </ul></li>
  <li><a href="#future-directions-and-emerging-approaches" id="toc-future-directions-and-emerging-approaches" class="nav-link" data-scroll-target="#future-directions-and-emerging-approaches">Future Directions and Emerging Approaches</a>
  <ul class="collapse">
  <li><a href="#machine-learning-and-deep-learning-approaches" id="toc-machine-learning-and-deep-learning-approaches" class="nav-link" data-scroll-target="#machine-learning-and-deep-learning-approaches">Machine Learning and Deep Learning Approaches</a></li>
  <li><a href="#integration-with-structural-prediction" id="toc-integration-with-structural-prediction" class="nav-link" data-scroll-target="#integration-with-structural-prediction">Integration with Structural Prediction</a></li>
  <li><a href="#phylogenetic-context-and-lineage-specific-matrices" id="toc-phylogenetic-context-and-lineage-specific-matrices" class="nav-link" data-scroll-target="#phylogenetic-context-and-lineage-specific-matrices">Phylogenetic Context and Lineage-Specific Matrices</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/preface.html">Bioinformatics</a></li><li class="breadcrumb-item"><a href="../../chapters/bioinformatics/protein_substitution_matrices.html"><span class="chapter-number">41</span>&nbsp; <span class="chapter-title">Scoring Matrices</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">41</span>&nbsp; <span class="chapter-title">Scoring Matrices</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- 
digraph so 
{
    node[ shape = square ];
    { rank = same; 1 2 3 }
    { rank = same; 6 5 4 }
    { rank = same; 7 8 }

    1 -> 2 -> 3;
    3 -> 4;
    6 -> 5 -> 4 [ dir = back ];
    6 -> 7;
    7 -> 8;
} 
-->
<section id="introduction-to-protein-sequence-scoring" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="introduction-to-protein-sequence-scoring">Introduction to Protein Sequence Scoring</h2>
<p>Here’s the thing about protein sequence comparison—it’s vastly more complex than DNA alignment, and that complexity is actually what makes it interesting. When you’re comparing DNA sequences, you’re working with just four nucleotides: <span class="math inline">\(A\)</span>, <span class="math inline">\(C\)</span>, <span class="math inline">\(G\)</span>, and <span class="math inline">\(T\)</span>. Pretty straightforward, right? But proteins? They’re built from twenty different amino acids, and here’s where it gets fascinating: each of those amino acids has its own unique chemical personality.</p>
<div class="cell styled-output" data-fig-width="7" data-fig-height="3" data-fig-format="svg" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-amino-acid-groups" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-amino-acid-groups-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<svg width="672" height="288" viewbox="0.00 0.00 780.25 276.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 272)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-272 776.25,-272 776.25,4 -4,4"></polygon>
<!-- Hydrophobic -->
<g id="node1" class="node">
<title>Hydrophobic</title>
<text text-anchor="start" x="33.24" y="-245" font-family="Times,serif" font-size="20.00"> </text>
<text text-anchor="start" x="38.24" y="-245" font-family="Times,serif" font-weight="bold" font-size="20.00">Hydrophobic:</text>
<text text-anchor="start" x="158.26" y="-245" font-family="Times,serif" font-size="20.00"> </text>
</g>
<!-- Polar uncharged -->
<g id="node2" class="node">
<title>Polar uncharged</title>
<text text-anchor="start" x="18.54" y="-187" font-family="Times,serif" font-size="20.00"> </text>
<text text-anchor="start" x="23.54" y="-187" font-family="Times,serif" font-weight="bold" font-size="20.00">Polar uncharged:</text>
<text text-anchor="start" x="172.97" y="-187" font-family="Times,serif" font-size="20.00"> </text>
</g>
<!-- Hydrophobic&#45;&gt;Polar uncharged -->
<!-- Ala -->
<g id="node6" class="node">
<title>Ala</title>
<polygon fill="#ffe5b4" stroke="#ffe5b4" points="268.25,-268 214.25,-268 214.25,-232 268.25,-232 268.25,-268"></polygon>
<text text-anchor="middle" x="241.25" y="-244" font-family="Times,serif" font-size="20.00">Ala</text>
</g>
<!-- Hydrophobic&#45;&gt;Ala -->
<!-- Positively charged -->
<g id="node3" class="node">
<title>Positively charged</title>
<text text-anchor="start" x="11.88" y="-129" font-family="Times,serif" font-size="20.00"> </text>
<text text-anchor="start" x="16.88" y="-129" font-family="Times,serif" font-weight="bold" font-size="20.00">Positively charged:</text>
<text text-anchor="start" x="179.63" y="-129" font-family="Times,serif" font-size="20.00"> </text>
</g>
<!-- Polar uncharged&#45;&gt;Positively charged -->
<!-- Ser -->
<g id="node14" class="node">
<title>Ser</title>
<polygon fill="#b4d7ff" stroke="#b4d7ff" points="268.25,-210 214.25,-210 214.25,-174 268.25,-174 268.25,-210"></polygon>
<text text-anchor="middle" x="241.25" y="-186" font-family="Times,serif" font-size="20.00">Ser</text>
</g>
<!-- Polar uncharged&#45;&gt;Ser -->
<!-- Negatively charged -->
<g id="node4" class="node">
<title>Negatively charged</title>
<text text-anchor="start" x="8" y="-71" font-family="Times,serif" font-size="20.00"> </text>
<text text-anchor="start" x="13" y="-71" font-family="Times,serif" font-weight="bold" font-size="20.00">Negatively charged:</text>
<text text-anchor="start" x="183.51" y="-71" font-family="Times,serif" font-size="20.00"> </text>
</g>
<!-- Positively charged&#45;&gt;Negatively charged -->
<!-- Lys -->
<g id="node20" class="node">
<title>Lys</title>
<polygon fill="#ffb4b4" stroke="#ffb4b4" points="268.25,-152 214.25,-152 214.25,-116 268.25,-116 268.25,-152"></polygon>
<text text-anchor="middle" x="241.25" y="-128" font-family="Times,serif" font-size="20.00">Lys</text>
</g>
<!-- Positively charged&#45;&gt;Lys -->
<!-- Special -->
<g id="node5" class="node">
<title>Special</title>
<text text-anchor="start" x="59.37" y="-13" font-family="Times,serif" font-size="20.00"> </text>
<text text-anchor="start" x="64.37" y="-13" font-family="Times,serif" font-weight="bold" font-size="20.00">Special:</text>
<text text-anchor="start" x="132.14" y="-13" font-family="Times,serif" font-size="20.00"> </text>
</g>
<!-- Negatively charged&#45;&gt;Special -->
<!-- Asp -->
<g id="node23" class="node">
<title>Asp</title>
<polygon fill="#b4ffb4" stroke="#b4ffb4" points="268.25,-94 214.25,-94 214.25,-58 268.25,-58 268.25,-94"></polygon>
<text text-anchor="middle" x="241.25" y="-70" font-family="Times,serif" font-size="20.00">Asp</text>
</g>
<!-- Negatively charged&#45;&gt;Asp -->
<!-- Gly -->
<g id="node25" class="node">
<title>Gly</title>
<polygon fill="#e0e0e0" stroke="#e0e0e0" points="268.25,-36 214.25,-36 214.25,0 268.25,0 268.25,-36"></polygon>
<text text-anchor="middle" x="241.25" y="-12" font-family="Times,serif" font-size="20.00">Gly</text>
</g>
<!-- Special&#45;&gt;Gly -->
<!-- Val -->
<g id="node7" class="node">
<title>Val</title>
<polygon fill="#ffe5b4" stroke="#ffe5b4" points="340.25,-268 286.25,-268 286.25,-232 340.25,-232 340.25,-268"></polygon>
<text text-anchor="middle" x="313.25" y="-244" font-family="Times,serif" font-size="20.00">Val</text>
</g>
<!-- Ala&#45;&gt;Val -->
<!-- Ala&#45;&gt;Ser -->
<!-- Ile -->
<g id="node8" class="node">
<title>Ile</title>
<polygon fill="#ffe5b4" stroke="#ffe5b4" points="412.25,-268 358.25,-268 358.25,-232 412.25,-232 412.25,-268"></polygon>
<text text-anchor="middle" x="385.25" y="-244" font-family="Times,serif" font-size="20.00">Ile</text>
</g>
<!-- Val&#45;&gt;Ile -->
<!-- Thr -->
<g id="node15" class="node">
<title>Thr</title>
<polygon fill="#b4d7ff" stroke="#b4d7ff" points="340.25,-210 286.25,-210 286.25,-174 340.25,-174 340.25,-210"></polygon>
<text text-anchor="middle" x="313.25" y="-186" font-family="Times,serif" font-size="20.00">Thr</text>
</g>
<!-- Val&#45;&gt;Thr -->
<!-- Leu -->
<g id="node9" class="node">
<title>Leu</title>
<polygon fill="#ffe5b4" stroke="#ffe5b4" points="484.25,-268 430.25,-268 430.25,-232 484.25,-232 484.25,-268"></polygon>
<text text-anchor="middle" x="457.25" y="-244" font-family="Times,serif" font-size="20.00">Leu</text>
</g>
<!-- Ile&#45;&gt;Leu -->
<!-- Cys -->
<g id="node16" class="node">
<title>Cys</title>
<polygon fill="#b4d7ff" stroke="#b4d7ff" points="412.25,-210 358.25,-210 358.25,-174 412.25,-174 412.25,-210"></polygon>
<text text-anchor="middle" x="385.25" y="-186" font-family="Times,serif" font-size="20.00">Cys</text>
</g>
<!-- Ile&#45;&gt;Cys -->
<!-- Met -->
<g id="node10" class="node">
<title>Met</title>
<polygon fill="#ffe5b4" stroke="#ffe5b4" points="556.25,-268 502.25,-268 502.25,-232 556.25,-232 556.25,-268"></polygon>
<text text-anchor="middle" x="529.25" y="-244" font-family="Times,serif" font-size="20.00">Met</text>
</g>
<!-- Leu&#45;&gt;Met -->
<!-- Asn -->
<g id="node17" class="node">
<title>Asn</title>
<polygon fill="#b4d7ff" stroke="#b4d7ff" points="484.25,-210 430.25,-210 430.25,-174 484.25,-174 484.25,-210"></polygon>
<text text-anchor="middle" x="457.25" y="-186" font-family="Times,serif" font-size="20.00">Asn</text>
</g>
<!-- Leu&#45;&gt;Asn -->
<!-- Phe -->
<g id="node11" class="node">
<title>Phe</title>
<polygon fill="#ffe5b4" stroke="#ffe5b4" points="628.25,-268 574.25,-268 574.25,-232 628.25,-232 628.25,-268"></polygon>
<text text-anchor="middle" x="601.25" y="-244" font-family="Times,serif" font-size="20.00">Phe</text>
</g>
<!-- Met&#45;&gt;Phe -->
<!-- Gln -->
<g id="node18" class="node">
<title>Gln</title>
<polygon fill="#b4d7ff" stroke="#b4d7ff" points="556.25,-210 502.25,-210 502.25,-174 556.25,-174 556.25,-210"></polygon>
<text text-anchor="middle" x="529.25" y="-186" font-family="Times,serif" font-size="20.00">Gln</text>
</g>
<!-- Met&#45;&gt;Gln -->
<!-- Trp -->
<g id="node12" class="node">
<title>Trp</title>
<polygon fill="#ffe5b4" stroke="#ffe5b4" points="700.25,-268 646.25,-268 646.25,-232 700.25,-232 700.25,-268"></polygon>
<text text-anchor="middle" x="673.25" y="-244" font-family="Times,serif" font-size="20.00">Trp</text>
</g>
<!-- Phe&#45;&gt;Trp -->
<!-- Tyr -->
<g id="node19" class="node">
<title>Tyr</title>
<polygon fill="#b4d7ff" stroke="#b4d7ff" points="628.25,-210 574.25,-210 574.25,-174 628.25,-174 628.25,-210"></polygon>
<text text-anchor="middle" x="601.25" y="-186" font-family="Times,serif" font-size="20.00">Tyr</text>
</g>
<!-- Phe&#45;&gt;Tyr -->
<!-- Pro -->
<g id="node13" class="node">
<title>Pro</title>
<polygon fill="#ffe5b4" stroke="#ffe5b4" points="772.25,-268 718.25,-268 718.25,-232 772.25,-232 772.25,-268"></polygon>
<text text-anchor="middle" x="745.25" y="-244" font-family="Times,serif" font-size="20.00">Pro</text>
</g>
<!-- Trp&#45;&gt;Pro -->
<!-- Ser&#45;&gt;Thr -->
<!-- Ser&#45;&gt;Lys -->
<!-- Thr&#45;&gt;Cys -->
<!-- Arg -->
<g id="node21" class="node">
<title>Arg</title>
<polygon fill="#ffb4b4" stroke="#ffb4b4" points="340.25,-152 286.25,-152 286.25,-116 340.25,-116 340.25,-152"></polygon>
<text text-anchor="middle" x="313.25" y="-128" font-family="Times,serif" font-size="20.00">Arg</text>
</g>
<!-- Thr&#45;&gt;Arg -->
<!-- Cys&#45;&gt;Asn -->
<!-- His -->
<g id="node22" class="node">
<title>His</title>
<polygon fill="#ffb4b4" stroke="#ffb4b4" points="412.25,-152 358.25,-152 358.25,-116 412.25,-116 412.25,-152"></polygon>
<text text-anchor="middle" x="385.25" y="-128" font-family="Times,serif" font-size="20.00">His</text>
</g>
<!-- Cys&#45;&gt;His -->
<!-- Asn&#45;&gt;Gln -->
<!-- Gln&#45;&gt;Tyr -->
<!-- Lys&#45;&gt;Arg -->
<!-- Lys&#45;&gt;Asp -->
<!-- Arg&#45;&gt;His -->
<!-- Glu -->
<g id="node24" class="node">
<title>Glu</title>
<polygon fill="#b4ffb4" stroke="#b4ffb4" points="340.25,-94 286.25,-94 286.25,-58 340.25,-58 340.25,-94"></polygon>
<text text-anchor="middle" x="313.25" y="-70" font-family="Times,serif" font-size="20.00">Glu</text>
</g>
<!-- Arg&#45;&gt;Glu -->
<!-- Asp&#45;&gt;Glu -->
<!-- Asp&#45;&gt;Gly -->
</g>
</svg>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-amino-acid-groups-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;41.1: Chemical groupings of the 20 standard amino acids. Amino acids with similar chemical properties tend to substitute for each other more readily during evolution.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Some are hydrophobic and want to hide from water, some are charged and love interacting with their surroundings, some are tiny and flexible, others are bulky and rigid. These chemical properties aren’t just biochemical trivia—they fundamentally shape how proteins evolve. When a mutation changes one amino acid to another during evolution, whether that change gets accepted or rejected depends heavily on whether the new amino acid can do the same job as the old one. A mutation that swaps one hydrophobic amino acid for another similar hydrophobic amino acid? Usually fine. A mutation that puts a charged amino acid where a hydrophobic one used to be? That’s probably going to break something. This is why comparing protein sequences requires sophisticated scoring schemes that capture these subtle patterns of amino acid replacement. We can’t just score all matches the same and all mismatches the same—we need scoring systems that understand that leucine to isoleucine is a much more reasonable substitution than tryptophan to aspartic acid. The whole challenge of protein sequence alignment boils down to quantifying these substitution patterns in a way that reflects what actually happens during evolution.</p>
<section id="evolution-as-natures-experiment-in-protein-engineering" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="evolution-as-natures-experiment-in-protein-engineering">Evolution as Nature’s Experiment in Protein Engineering</h3>
<p>Think of evolution as a massive, billion-year experiment in protein engineering. Every time a mutation occurs in a protein-coding gene, nature tests whether that change works. If the new amino acid does the job well enough, the organism survives and reproduces, passing that mutation along. If the change breaks something critical, natural selection eliminates it. This process has been running for billions of years, generating an enormous dataset of which amino acid substitutions work and which don’t. When you compare homologous proteins across different species—say, hemoglobin in humans versus hemoglobin in mice—you’re essentially reading the results of this experiment. The substitutions you observe are the ones that passed nature’s filter. The substitutions you don’t see? Those are the ones that failed. What’s remarkable is that these patterns aren’t random. Conservative substitutions—those swapping one amino acid for another with similar chemical properties—show up all the time because they rarely break anything important. Leucine to valine? Both are hydrophobic, both are roughly similar in size, so this substitution usually preserves protein structure and function. Serine to threonine? Both are small, both are polar, both can form similar hydrogen bonds—again, usually fine. But radical substitutions between chemically different amino acids are rare in the evolutionary record. Try putting an aspartic acid (charged, hydrophilic, small) where a tryptophan (uncharged, hydrophobic, bulky) used to be, and you’ll probably destroy the protein’s ability to fold correctly or carry out its function. Natural selection acts as a filter, keeping the mutations that maintain or improve function while ruthlessly eliminating the ones that cause problems. The protein sequences we observe today represent the survivors—the accumulated substitutions that were functionally acceptable over evolutionary time.</p>
</section>
<section id="quantifying-substitution-patterns" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="quantifying-substitution-patterns">Quantifying Substitution Patterns</h3>
<p>So we’ve established that evolution generates useful data about amino acid substitutions. But how do we turn those observations into actual numbers we can use for sequence alignment? This is where things get mathematically interesting, because the process isn’t as simple as just counting how often each substitution appears. We need to address several subtle challenges. First challenge: distinguishing real evolutionary relationships from coincidence. If you see two sequences both have leucine at the same position, is that because they share a common ancestor (homology), or is it just random chance? Leucine is pretty common, so you’d expect to see it align with itself sometimes even in completely unrelated sequences. Second challenge: accounting for the fact that different amino acids have different background frequencies. Tryptophan is rare in proteins generally—it makes up maybe <span class="math inline">\(1\%\)</span> of all amino acids. Leucine, on the other hand, is abundant at around <span class="math inline">\(10\%\)</span>. So you’ll naturally see more leucine-leucine alignments than tryptophan-tryptophan alignments even in random sequences, just because there’s more leucine to go around. We need to correct for these frequency differences if we want to identify substitutions that are genuinely meaningful rather than just common. Third challenge: as evolutionary distance increases, you get multiple substitutions happening at the same position. What started as an alanine might have mutated to glycine, then later to serine. When we compare these distant sequences, we only see the beginning and end states, not the intermediate steps. We need statistical methods that account for this “saturation” effect. The standard approach to all these challenges involves transforming raw substitution counts into log-odds scores. Here’s the key equation:</p>
<p><span class="math display">\[S(a,b) = \log\left(\frac{q_{ab}}{p_a \cdot p_b}\right)\]</span></p>
<p>where <span class="math inline">\(q_{ab}\)</span> represents the observed frequency of amino acids <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> being aligned in homologous sequences, while <span class="math inline">\(p_a\)</span> and <span class="math inline">\(p_b\)</span> represent the background frequencies of amino acids <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> respectively. The numerator <span class="math inline">\(q_{ab}\)</span> is what we actually observe in related proteins. The denominator <span class="math inline">\(p_a \cdot p_b\)</span> is what we’d expect to see if sequences were just random strings of amino acids with no evolutionary relationship. If <span class="math inline">\(q_{ab}\)</span> is larger than <span class="math inline">\(p_a \cdot p_b\)</span>, the substitution occurs more often than chance would predict, so the log gives us a positive score—evidence of an evolutionary relationship. If <span class="math inline">\(q_{ab}\)</span> is smaller than expected, we get a negative score—this substitution is rare and penalized. This formulation elegantly captures the core insight: substitutions that occur frequently in evolutionarily related sequences, beyond what random chance would produce, are the ones that should get positive scores in our alignment algorithm.</p>
</section>
<section id="the-need-for-multiple-scoring-matrices" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-need-for-multiple-scoring-matrices">The Need for Multiple Scoring Matrices</h3>
<p>Here’s something that might surprise you: there’s no such thing as a single “best” substitution matrix. The substitution patterns you observe between closely related proteins look completely different from those you see between distant relatives, and that means we need different scoring matrices optimized for different evolutionary distances. Let me explain why this matters. Imagine comparing human and chimpanzee hemoglobin—these proteins are extremely similar because humans and chimps diverged recently. In closely related sequences like these, most positions are still identical, and the few substitutions you do see are almost always conservative: leucine to isoleucine, serine to threonine, that kind of thing. These are the “easy” substitutions that happen readily. Now imagine comparing human hemoglobin to sea urchin hemoglobin. These organisms diverged hundreds of millions of years ago, so their sequences have accumulated many more changes. You still see some conservative substitutions, but you also see more radical changes, multiple substitutions at the same position, and the whole picture becomes much more complicated. If you use a scoring matrix optimized for closely related sequences (like BLOSUM80 or PAM40) to compare distant sequences, you’ll fail to detect the relationship because you’re being too picky—you’re penalizing substitutions that are perfectly normal at that evolutionary distance. Conversely, if you use a matrix optimized for distant sequences (like BLOSUM45 or PAM250) to compare closely related sequences, you’ll be too permissive, accepting substitutions and gaps where you should demand near-perfect matches. This trade-off between sensitivity and specificity is fundamental to sequence analysis. Matrices for close relationships are stringent—they strongly penalize most substitutions and reward only highly conservative changes. Great for distinguishing orthologs from paralogs in closely related species, terrible for detecting remote homologs. Matrices for distant relationships are permissive—they accept a much broader range of substitutions. Great for finding distant relatives, but they’ll generate false positives if you use them on closely related sequences. The practical upshot is that choosing the right matrix depends on knowing or estimating the evolutionary distance between your sequences, and having a whole toolkit of matrices optimized for different distances gives you the flexibility to handle whatever comparison you’re doing.</p>
</section>
</section>
<section id="pam-matrices-modeling-evolution-through-time" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="pam-matrices-modeling-evolution-through-time">PAM Matrices: Modeling Evolution Through Time</h2>
<section id="the-evolutionary-model-behind-pam" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-evolutionary-model-behind-pam">The Evolutionary Model Behind PAM</h3>
<p>The Point Accepted Mutation (PAM) matrices represent one of the foundational achievements in computational biology, and they come with a fascinating origin story. Back in the 1970s, Margaret Dayhoff—often called the founding mother of bioinformatics—had a visionary idea: what if we could capture the patterns of protein evolution mathematically and use those patterns to improve sequence analysis? This was revolutionary thinking at a time when most people were still figuring out how to sequence proteins at all. Dayhoff didn’t just develop PAM matrices; she built the first comprehensive protein sequence database (the Atlas of Protein Sequence and Structure), established fundamental methods for sequence comparison, and basically laid the groundwork for the entire field of bioinformatics. Working with punch cards and early computers, she meticulously collected and analyzed protein sequences to extract the evolutionary signal hidden in substitution patterns. Her insight was that evolution leaves quantifiable traces, and if you could measure those traces carefully enough, you could build mathematical models that would let you detect evolutionary relationships that might not be obvious from casual inspection. The PAM model itself rests on a clear conceptual foundation: protein evolution happens through point mutations (changes in individual nucleotides that alter amino acids), and some of these mutations get “accepted” by natural selection while others get rejected. The key word here is “accepted”—we’re not counting all mutations that occur, just the ones that persist in populations because they don’t break the protein badly enough to be lethal. This distinction matters because it means PAM matrices capture functional constraints, not just mutational processes. The basic unit of measurement is the PAM unit itself: one PAM unit corresponds to an evolutionary distance where, on average, one accepted point mutation occurs per 100 amino acid positions. So if two sequences are separated by 1 PAM unit of evolution, you’d expect about <span class="math inline">\(1\%\)</span> of their amino acid positions to differ. Notice that this measures evolutionary time in terms of observed changes, not absolute time—<span class="math inline">\(1\%\)</span> divergence might take a million years in a slowly evolving protein or just thousands of years in a rapidly evolving one.</p>
<p>The mathematical machinery of PAM matrices starts with a mutation probability matrix <span class="math inline">\(M\)</span>. Each element <span class="math inline">\(M_{ij}\)</span> represents the probability that amino acid <span class="math inline">\(i\)</span> mutates to amino acid <span class="math inline">\(j\)</span> over one PAM unit of evolutionary time. The diagonal elements <span class="math inline">\(M_{ii}\)</span> tell you the probability of no change—the chance that amino acid <span class="math inline">\(i\)</span> stays as <span class="math inline">\(i\)</span>. The off-diagonal elements capture substitution probabilities. Since these are probabilities and something has to happen (either change or no change), they must sum to 1:</p>
<p><span class="math display">\[
\sum_{j=1}^{20} M_{ij} = 1
\]</span></p>
<p>for each amino acid <span class="math inline">\(i\)</span>. This matrix <span class="math inline">\(M\)</span> is what we call a stochastic matrix, and it encodes the fundamental evolutionary process—the transition probabilities from one amino acid to another over a small time step.</p>
</section>
<section id="constructing-pam-matrices-from-data" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="constructing-pam-matrices-from-data">Constructing PAM Matrices from Data</h3>
<p>Building a PAM matrix starts with collecting the right kind of data—and this is where Dayhoff’s work was particularly heroic. Remember, this was the 1970s. No automated DNA sequencers, no massive sequence databases, no computational infrastructure. Dayhoff and her team manually collected and aligned protein sequences, working with punch cards and early computers that had less computing power than your phone. The key methodological decision was to focus on very closely related protein sequences—specifically, proteins sharing more than <span class="math inline">\(85\%\)</span> sequence identity. Why so stringent? Because when sequences are that similar, you can be confident that each difference you observe represents a single substitution event. If you used more divergent sequences, you’d risk observing positions that had mutated multiple times, and that would mess up your statistics—you’d be looking at the endpoint of a complex chain of substitutions rather than individual mutation events. This high-similarity threshold was critical for getting accurate estimates of the basic substitution rates. Dayhoff’s insistence on biological accuracy over computational convenience set standards for rigor that still guide bioinformatics research today. Once you have your aligned sequences, the construction process involves some straightforward counting followed by some clever mathematics. Let <span class="math inline">\(A_{ij}\)</span> represent the number of times you observe amino acid <span class="math inline">\(i\)</span> mutate to amino acid <span class="math inline">\(j\)</span> in your dataset. From these counts, you calculate the relative mutability of each amino acid—essentially, how mutation-prone each amino acid is:</p>
<p><span class="math display">\[m_i = \frac{\sum_{j \neq i} A_{ij}}{n_i \cdot c}\]</span></p>
<p>where <span class="math inline">\(n_i\)</span> is the total occurrence of amino acid <span class="math inline">\(i\)</span> in your dataset, and <span class="math inline">\(c\)</span> is a scaling constant chosen so that the average probability of mutation equals <span class="math inline">\(0.01\)</span> (which is what defines 1 PAM unit). Some amino acids are inherently more mutable than others—maybe because their codons are more susceptible to certain mutations, or because changes to them are more often tolerated functionally. This formula captures that variation. Once you have the mutabilities, you construct the actual mutation probability matrix <span class="math inline">\(M\)</span>:</p>
<p><span class="math display">\[
M_{ij} = \begin{cases}
\frac{A_{ij}}{\sum_{k} A_{ik}} \cdot m_i &amp; \text{if } i \neq j \\
1 - m_i &amp; \text{if } i = j
\end{cases}
\]</span></p>
<p>The off-diagonal elements tell you: given that amino acid <span class="math inline">\(i\)</span> is going to mutate, what’s the probability it mutates to <span class="math inline">\(j\)</span> specifically? The diagonal elements tell you the probability of no change. This <span class="math inline">\(M\)</span> matrix represents evolution over a tiny time step—just one PAM unit. To model longer evolutionary distances, we’ll use a clever mathematical trick based on the Markov property.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="480" height="288" viewbox="0.00 0.00 307.53 209.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 205)">
<title>so</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-205 303.53,-205 303.53,4 -4,4"></polygon>
<!-- 1 -->
<g id="node1" class="node">
<title>1</title>
<polygon fill="none" stroke="black" points="86.53,-201 0.99,-201 0.99,-158 86.53,-158 86.53,-201"></polygon>
<text text-anchor="middle" x="43.76" y="-186.7" font-family="Times,serif" font-size="8.00">Collect closely related</text>
<text text-anchor="middle" x="43.76" y="-177.1" font-family="Times,serif" font-size="8.00">protein sequences</text>
<text text-anchor="middle" x="43.76" y="-167.5" font-family="Times,serif" font-size="8.00">(&gt;85% identity)</text>
</g>
<!-- 2 -->
<g id="node2" class="node">
<title>2</title>
<polygon fill="none" stroke="black" points="192.53,-201 106.99,-201 106.99,-158 192.53,-158 192.53,-201"></polygon>
<text text-anchor="middle" x="149.76" y="-186.7" font-family="Times,serif" font-size="8.00">Collect closely related</text>
<text text-anchor="middle" x="149.76" y="-177.1" font-family="Times,serif" font-size="8.00">protein sequences</text>
<text text-anchor="middle" x="149.76" y="-167.5" font-family="Times,serif" font-size="8.00">(&gt;85% identity)</text>
</g>
<!-- 1&#45;&gt;2 -->
<g id="edge1" class="edge">
<title>1-&gt;2</title>
<path fill="none" stroke="black" d="M86.83,-179.5C90,-179.5 93.18,-179.5 96.35,-179.5"></path>
<polygon fill="black" stroke="black" points="96.49,-183 106.49,-179.5 96.49,-176 96.49,-183"></polygon>
</g>
<!-- 3 -->
<g id="node3" class="node">
<title>3</title>
<polygon fill="none" stroke="black" points="298.53,-201 212.99,-201 212.99,-158 298.53,-158 298.53,-201"></polygon>
<text text-anchor="middle" x="255.76" y="-186.7" font-family="Times,serif" font-size="8.00">Collect closely related</text>
<text text-anchor="middle" x="255.76" y="-177.1" font-family="Times,serif" font-size="8.00">protein sequences</text>
<text text-anchor="middle" x="255.76" y="-167.5" font-family="Times,serif" font-size="8.00">(&gt;85% identity)</text>
</g>
<!-- 2&#45;&gt;3 -->
<g id="edge2" class="edge">
<title>2-&gt;3</title>
<path fill="none" stroke="black" d="M192.83,-179.5C196,-179.5 199.18,-179.5 202.35,-179.5"></path>
<polygon fill="black" stroke="black" points="202.49,-183 212.49,-179.5 202.49,-176 202.49,-183"></polygon>
</g>
<!-- 4 -->
<g id="node4" class="node">
<title>4</title>
<polygon fill="none" stroke="black" points="298.53,-122 212.99,-122 212.99,-79 298.53,-79 298.53,-122"></polygon>
<text text-anchor="middle" x="255.76" y="-107.7" font-family="Times,serif" font-size="8.00">Collect closely related</text>
<text text-anchor="middle" x="255.76" y="-98.1" font-family="Times,serif" font-size="8.00">protein sequences</text>
<text text-anchor="middle" x="255.76" y="-88.5" font-family="Times,serif" font-size="8.00">(&gt;85% identity)</text>
</g>
<!-- 3&#45;&gt;4 -->
<g id="edge3" class="edge">
<title>3-&gt;4</title>
<path fill="none" stroke="black" d="M255.76,-157.87C255.76,-150.01 255.76,-140.88 255.76,-132.29"></path>
<polygon fill="black" stroke="black" points="259.26,-132.19 255.76,-122.19 252.26,-132.19 259.26,-132.19"></polygon>
</g>
<!-- 5 -->
<g id="node5" class="node">
<title>5</title>
<polygon fill="none" stroke="black" points="192.53,-122 106.99,-122 106.99,-79 192.53,-79 192.53,-122"></polygon>
<text text-anchor="middle" x="149.76" y="-107.7" font-family="Times,serif" font-size="8.00">Collect closely related</text>
<text text-anchor="middle" x="149.76" y="-98.1" font-family="Times,serif" font-size="8.00">protein sequences</text>
<text text-anchor="middle" x="149.76" y="-88.5" font-family="Times,serif" font-size="8.00">(&gt;85% identity)</text>
</g>
<!-- 5&#45;&gt;4 -->
<g id="edge5" class="edge">
<title>5-&gt;4</title>
<path fill="none" stroke="black" d="M202.97,-100.5C206.14,-100.5 209.32,-100.5 212.49,-100.5"></path>
<polygon fill="black" stroke="black" points="202.83,-97 192.83,-100.5 202.83,-104 202.83,-97"></polygon>
</g>
<!-- 6 -->
<g id="node6" class="node">
<title>6</title>
<polygon fill="none" stroke="black" points="86.53,-122 0.99,-122 0.99,-79 86.53,-79 86.53,-122"></polygon>
<text text-anchor="middle" x="43.76" y="-107.7" font-family="Times,serif" font-size="8.00">Collect closely related</text>
<text text-anchor="middle" x="43.76" y="-98.1" font-family="Times,serif" font-size="8.00">protein sequences</text>
<text text-anchor="middle" x="43.76" y="-88.5" font-family="Times,serif" font-size="8.00">(&gt;85% identity)</text>
</g>
<!-- 6&#45;&gt;5 -->
<g id="edge4" class="edge">
<title>6-&gt;5</title>
<path fill="none" stroke="black" d="M96.97,-100.5C100.14,-100.5 103.32,-100.5 106.49,-100.5"></path>
<polygon fill="black" stroke="black" points="96.83,-97 86.83,-100.5 96.83,-104 96.83,-97"></polygon>
</g>
<!-- 7 -->
<g id="node7" class="node">
<title>7</title>
<polygon fill="none" stroke="black" points="86.53,-43 0.99,-43 0.99,0 86.53,0 86.53,-43"></polygon>
<text text-anchor="middle" x="43.76" y="-28.7" font-family="Times,serif" font-size="8.00">Collect closely related</text>
<text text-anchor="middle" x="43.76" y="-19.1" font-family="Times,serif" font-size="8.00">protein sequences</text>
<text text-anchor="middle" x="43.76" y="-9.5" font-family="Times,serif" font-size="8.00">(&gt;85% identity)</text>
</g>
<!-- 6&#45;&gt;7 -->
<g id="edge6" class="edge">
<title>6-&gt;7</title>
<path fill="none" stroke="black" d="M43.76,-78.87C43.76,-71.01 43.76,-61.88 43.76,-53.29"></path>
<polygon fill="black" stroke="black" points="47.26,-53.19 43.76,-43.19 40.26,-53.19 47.26,-53.19"></polygon>
</g>
<!-- 8 -->
<g id="node8" class="node">
<title>8</title>
<polygon fill="none" stroke="black" points="192.53,-43 106.99,-43 106.99,0 192.53,0 192.53,-43"></polygon>
<text text-anchor="middle" x="149.76" y="-28.7" font-family="Times,serif" font-size="8.00">Collect closely related</text>
<text text-anchor="middle" x="149.76" y="-19.1" font-family="Times,serif" font-size="8.00">protein sequences</text>
<text text-anchor="middle" x="149.76" y="-9.5" font-family="Times,serif" font-size="8.00">(&gt;85% identity)</text>
</g>
<!-- 7&#45;&gt;8 -->
<g id="edge7" class="edge">
<title>7-&gt;8</title>
<path fill="none" stroke="black" d="M86.83,-21.5C90,-21.5 93.18,-21.5 96.35,-21.5"></path>
<polygon fill="black" stroke="black" points="96.49,-25 106.49,-21.5 96.49,-18 96.49,-25"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div id="cell-fig-pam-construction" class="cell styled-output" data-fig-format="svg" data-fig-width="7" data-execution_count="1">
<div class="cell-output cell-output-display">
<div id="fig-pam-construction" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pam-construction-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="protein_substitution_matrices_files/figure-html/fig-pam-construction-output-1.png" width="662" height="758" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pam-construction-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;41.2: PAM matrix construction workflow. Starting from closely related sequences (&gt;85% identity), substitution counts are collected and normalized to build the PAM1 mutation probability matrix. Matrix exponentiation extrapolates to longer evolutionary distances.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="extrapolating-to-higher-pam-distances" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="extrapolating-to-higher-pam-distances">Extrapolating to Higher PAM Distances</h3>
<p>Here’s where the PAM framework becomes really powerful: we can take our PAM1 matrix (built from very closely related sequences) and extrapolate it to model much longer evolutionary distances. The trick is beautifully simple. Remember that <span class="math inline">\(M\)</span> is a matrix of transition probabilities over one PAM unit. What if you want to know what happens over <span class="math inline">\(n\)</span> PAM units? You just multiply the matrix by itself <span class="math inline">\(n\)</span> times:</p>
<p><span class="math display">\[
M^{(n)} = M^n
\]</span></p>
<p>That’s it. Matrix exponentiation. This works because of the Markov property—the probability of being in state <span class="math inline">\(j\)</span> after <span class="math inline">\(n\)</span> steps is the sum over all possible intermediate paths, and matrix multiplication automatically computes exactly that. So <span class="math inline">\(M^{(250)}\)</span> tells you the transition probabilities after 250 PAM units of evolution. This is PAM250, one of the most commonly used matrices, and it corresponds to sequences where approximately <span class="math inline">\(80\%\)</span> of positions have experienced at least one accepted mutation. At that evolutionary distance, you’re comparing quite distantly related proteins—think human versus yeast versions of the same protein. Once you have <span class="math inline">\(M^{(n)}\)</span>, you convert it into actual alignment scores using the log-odds formula:</p>
<p><span class="math display">\[
S^{(n)}_{ij} = 10 \cdot \log_{10}\left(\frac{M^{(n)}_{ij}}{f_j}\right)
\]</span></p>
<p>where <span class="math inline">\(f_j\)</span> is the background frequency of amino acid <span class="math inline">\(j\)</span>. The factor of 10 and the use of base-10 logarithms are historical quirks from the pre-computer era—they yield integer scores that were convenient for manual calculations. There’s nothing fundamental about them; some modern matrices use different scaling factors or base-2 logarithms. What matters is the ratio inside the log: how much more likely is this substitution in related proteins compared to random chance? One consequence of this model is that sequence identity decreases exponentially with PAM distance:</p>
<p><span class="math display">\[
\text{Identity} = \sum_{i=1}^{20} f_i \cdot M^{(n)}_{ii}
\]</span></p>
<p>The diagonal elements <span class="math inline">\(M^{(n)}_{ii}\)</span> represent the probability that amino acid <span class="math inline">\(i\)</span> is still <span class="math inline">\(i\)</span> after <span class="math inline">\(n\)</span> PAM units, weighted by how common that amino acid is. As <span class="math inline">\(n\)</span> increases, these probabilities decrease, and sequence identity drops. At PAM250, you’re down to about <span class="math inline">\(20\%\)</span> identity—close to what we call the “twilight zone” of sequence comparison, where it becomes very hard to distinguish real homology from random similarity.</p>
<div id="cell-fig-pam-identity-decay" class="cell styled-output" data-fig-format="svg" data-fig-width="7" data-execution_count="2">
<div class="cell-output cell-output-display">
<div id="fig-pam-identity-decay" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pam-identity-decay-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="protein_substitution_matrices_files/figure-html/fig-pam-identity-decay-output-1.png" width="663" height="421" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pam-identity-decay-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;41.3: Relationship between PAM distance and expected sequence identity. As evolutionary distance increases, sequence identity decays exponentially. PAM250 corresponds to approximately 20% identity, near the twilight zone of sequence comparison.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="worked-example-constructing-a-pam1-matrix" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="worked-example-constructing-a-pam1-matrix">Worked Example: Constructing a PAM1 Matrix</h3>
<p>To illustrate the construction of PAM matrices, let’s work through a simplified example using a subset of amino acids. Consider a dataset of closely related sequences (&gt;85% identity) where we observe the following substitution counts between four amino acids (A, G, V, L):</p>
<p><strong>Step 1: Count observed substitutions</strong></p>
<p>From our aligned sequences, we observe: - A → G: 30 substitutions - A → V: 10 substitutions - A → L: 5 substitutions - G → V: 8 substitutions - G → L: 4 substitutions - V → L: 25 substitutions</p>
<p>Total occurrences in dataset: - A: 1000 positions - G: 800 positions - V: 600 positions - L: 900 positions</p>
<p><strong>Step 2: Calculate relative mutabilities</strong></p>
<p>The relative mutability <span class="math inline">\(m_i\)</span> for each amino acid represents its propensity to mutate:</p>
<p><span class="math display">\[
m_A = \frac{30 + 10 + 5}{1000 \cdot c} = \frac{45}{1000c}
\]</span></p>
<p><span class="math display">\[
m_G = \frac{30 + 8 + 4}{800 \cdot c} = \frac{42}{800c}
\]</span></p>
<p><span class="math display">\[
m_V = \frac{10 + 8 + 25}{600 \cdot c} = \frac{43}{600c}
\]</span></p>
<p><span class="math display">\[
m_L = \frac{5 + 4 + 25}{900 \cdot c} = \frac{34}{900c}
\]</span></p>
<p>We choose <span class="math inline">\(c\)</span> such that the average mutability equals 0.01 (1 PAM unit). The average mutability weighted by amino acid frequency is:</p>
<p><span class="math display">\[
\bar{m} = \frac{1000 \cdot m_A + 800 \cdot m_G + 600 \cdot m_V + 900 \cdot m_L}{3300} = 0.01
\]</span></p>
<p>Solving for <span class="math inline">\(c\)</span>: <span class="math inline">\(c = 4.8\)</span></p>
<p>This gives us: - <span class="math inline">\(m_A = 0.0094\)</span> - <span class="math inline">\(m_G = 0.0109\)</span> - <span class="math inline">\(m_V = 0.0149\)</span> - <span class="math inline">\(m_L = 0.0079\)</span></p>
<p><strong>Step 3: Construct the PAM1 mutation probability matrix</strong></p>
<p>The mutation probability matrix <span class="math inline">\(M\)</span> has diagonal elements representing no change and off-diagonal elements representing substitutions:</p>
<p><span class="math display">\[
M_{AA} = 1 - m_A = 0.9906
\]</span></p>
<p><span class="math display">\[
M_{AG} = \frac{30}{45} \cdot m_A = 0.0063
\]</span></p>
<p><span class="math display">\[
M_{AV} = \frac{10}{45} \cdot m_A = 0.0021
\]</span></p>
<p><span class="math display">\[
M_{AL} = \frac{5}{45} \cdot m_A = 0.0010
\]</span></p>
<p>Following this pattern for all amino acids:</p>
<p><span class="math display">\[
M = \begin{pmatrix}
0.9906 &amp; 0.0063 &amp; 0.0021 &amp; 0.0010 \\
0.0078 &amp; 0.9891 &amp; 0.0021 &amp; 0.0010 \\
0.0029 &amp; 0.0031 &amp; 0.9851 &amp; 0.0089 \\
0.0013 &amp; 0.0011 &amp; 0.0070 &amp; 0.9921
\end{pmatrix}
\]</span></p>
<p><strong>Step 4: Calculate PAM250 by matrix exponentiation</strong></p>
<p>To obtain PAM250, we calculate <span class="math inline">\(M^{250}\)</span>:</p>
<p><span class="math display">\[
M^{250} = \begin{pmatrix}
0.189 &amp; 0.174 &amp; 0.275 &amp; 0.362 \\
0.217 &amp; 0.221 &amp; 0.269 &amp; 0.293 \\
0.297 &amp; 0.242 &amp; 0.224 &amp; 0.237 \\
0.323 &amp; 0.211 &amp; 0.199 &amp; 0.267
\end{pmatrix}
\]</span></p>
<p><strong>Step 5: Convert to log-odds scoring matrix</strong></p>
<p>Using background frequencies <span class="math inline">\(f_A = 0.303\)</span>, <span class="math inline">\(f_G = 0.242\)</span>, <span class="math inline">\(f_V = 0.182\)</span>, <span class="math inline">\(f_L = 0.273\)</span>:</p>
<p><span class="math display">\[
S_{AA} = 10 \log_{10}\left(\frac{0.189}{0.303}\right) = -2.0
\]</span></p>
<p><span class="math display">\[
S_{AG} = 10 \log_{10}\left(\frac{0.174}{0.242}\right) = -1.4
\]</span></p>
<p><span class="math display">\[
S_{AV} = 10 \log_{10}\left(\frac{0.275}{0.182}\right) = 1.8
\]</span></p>
<p><span class="math display">\[
S_{AL} = 10 \log_{10}\left(\frac{0.362}{0.273}\right) = 1.2
\]</span></p>
<p>The complete PAM250 scoring matrix for our simplified example:</p>
<p><span class="math display">\[
S^{(250)} = \begin{pmatrix}
-2 &amp; -1 &amp; 2 &amp; 1 \\
-1 &amp; -1 &amp; 2 &amp; 0 \\
2 &amp; 1 &amp; 1 &amp; -1 \\
1 &amp; -1 &amp; -1 &amp; 0
\end{pmatrix}
\]</span></p>
<p>This simplified example demonstrates how evolutionary observations are transformed into practical scoring matrices. The positive scores (e.g., A-V: 2) indicate substitutions occurring more frequently than expected by chance, while negative scores indicate rare substitutions.</p>
</section>
<section id="python-implementation-pam-matrix-from-pairwise-alignment" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="python-implementation-pam-matrix-from-pairwise-alignment">Python Implementation: PAM Matrix from Pairwise Alignment</h3>
<p>To make the PAM construction process more concrete, let’s implement it in Python using a single long pairwise alignment. This example shows how to extract substitution counts from an alignment and construct a PAM1 matrix.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter, defaultdict</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_substitutions(seq1, seq2):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Extract substitution counts from a pairwise alignment.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes sequences are aligned and of equal length.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    substitutions <span class="op">=</span> defaultdict(<span class="bu">int</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    aa_counts <span class="op">=</span> Counter()</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a1, a2 <span class="kw">in</span> <span class="bu">zip</span>(seq1, seq2):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a1 <span class="op">!=</span> <span class="st">'-'</span> <span class="kw">and</span> a2 <span class="op">!=</span> <span class="st">'-'</span>:  <span class="co"># Skip gap positions</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            aa_counts[a1] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a1 <span class="op">!=</span> a2:</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Store substitutions symmetrically</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                pair <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>([a1, a2]))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                substitutions[pair] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> substitutions, aa_counts</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_pam1_matrix(seq1, seq2):</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute a PAM1 scoring matrix from a pairwise alignment.</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Example sequences (representing &gt;85% identity alignment)</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># In practice, you would use multiple alignments</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract substitutions and counts</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    substitutions, aa_counts <span class="op">=</span> extract_substitutions(seq1, seq2)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get unique amino acids</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    amino_acids <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">set</span>(aa_counts.keys()))</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    n_aa <span class="op">=</span> <span class="bu">len</span>(amino_acids)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    aa_to_idx <span class="op">=</span> {aa: i <span class="cf">for</span> i, aa <span class="kw">in</span> <span class="bu">enumerate</span>(amino_acids)}</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate total positions and substitution matrix A</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.zeros((n_aa, n_aa))</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (aa1, aa2), count <span class="kw">in</span> substitutions.items():</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        i, j <span class="op">=</span> aa_to_idx[aa1], aa_to_idx[aa2]</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        A[i, j] <span class="op">=</span> count <span class="op">/</span> <span class="dv">2</span>  <span class="co"># Divide by 2 because we count each pair once</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        A[j, i] <span class="op">=</span> count <span class="op">/</span> <span class="dv">2</span>  <span class="co"># Make symmetric</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate relative mutabilities</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    total_positions <span class="op">=</span> <span class="bu">sum</span>(aa_counts.values())</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    mutabilities <span class="op">=</span> np.zeros(n_aa)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, aa <span class="kw">in</span> <span class="bu">enumerate</span>(amino_acids):</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> aa_counts[aa] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>            mutabilities[i] <span class="op">=</span> np.<span class="bu">sum</span>(A[i, :]) <span class="op">/</span> aa_counts[aa]</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scale to 1 PAM unit (1% accepted mutations)</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    scaling_factor <span class="op">=</span> <span class="fl">0.01</span> <span class="op">/</span> np.mean(mutabilities[mutabilities <span class="op">&gt;</span> <span class="dv">0</span>])</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    mutabilities <span class="op">*=</span> scaling_factor</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Construct mutation probability matrix M</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> np.zeros((n_aa, n_aa))</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_aa):</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mutabilities[i] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Off-diagonal elements: mutation probabilities</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_aa):</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">!=</span> j <span class="kw">and</span> np.<span class="bu">sum</span>(A[i, :]) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>                    M[i, j] <span class="op">=</span> (A[i, j] <span class="op">/</span> np.<span class="bu">sum</span>(A[i, :])) <span class="op">*</span> mutabilities[i]</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Diagonal element: probability of no change</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>            M[i, i] <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> mutabilities[i]</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>            M[i, i] <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># No mutations observed</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate background frequencies</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    total_aa <span class="op">=</span> <span class="bu">sum</span>(aa_counts.values())</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>    frequencies <span class="op">=</span> np.array([aa_counts[aa] <span class="op">/</span> total_aa <span class="cf">for</span> aa <span class="kw">in</span> amino_acids])</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to log-odds scoring matrix</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Using PAM convention: S = 10 * log10(M[i,j] / f[j])</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> np.zeros((n_aa, n_aa))</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_aa):</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_aa):</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> M[i, j] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> frequencies[j] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>                S[i, j] <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> np.log10(M[i, j] <span class="op">/</span> frequencies[j])</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>                S[i, j] <span class="op">=</span> <span class="op">-</span><span class="dv">10</span>  <span class="co"># Large negative score for impossible substitutions</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Round to integers</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> np.<span class="bu">round</span>(S).astype(<span class="bu">int</span>)</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S, amino_acids, M, frequencies</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage with a long pairwise alignment</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>seq1 <span class="op">=</span> <span class="st">"ARNDCQEGHILKMFPSTWYVARCDEGHKLMNPQRSTVWYARNDCEGHILKMFPSTWYV"</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>seq2 <span class="op">=</span> <span class="st">"AKNDCQEGHVLKMFPSTWYVARCDEGHRLMNPQRSTVWYAKNDCEGHILKMFASTWYV"</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="co">#       *R-&gt;K     *I-&gt;V           *K-&gt;R     *R-&gt;K       *P-&gt;A</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute PAM1 matrix</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>S_pam1, amino_acids, M_prob, freqs <span class="op">=</span> compute_pam1_matrix(seq1, seq2)</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the scoring matrix</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"PAM1 Scoring Matrix (subset):"</span>)</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   "</span>, <span class="st">"  "</span>.join(<span class="ss">f"</span><span class="sc">{</span>aa<span class="sc">:&gt;3}</span><span class="ss">"</span> <span class="cf">for</span> aa <span class="kw">in</span> amino_acids[:<span class="dv">8</span>]))</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">8</span>, <span class="bu">len</span>(amino_acids))):</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>S_pam1[i,j]<span class="sc">:3d}</span><span class="ss">"</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">8</span>, <span class="bu">len</span>(amino_acids)))]</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>amino_acids[i]<span class="sc">:&gt;3}</span><span class="ss">"</span>, <span class="st">" "</span>.join(row))</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a><span class="co"># Show mutation probability matrix for verification</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Mutation Probability Matrix M (first 4x4):"</span>)</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">4</span>, <span class="bu">len</span>(amino_acids))):</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>M_prob[i,j]<span class="sc">:.4f}</span><span class="ss">"</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">4</span>, <span class="bu">len</span>(amino_acids)))]</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>amino_acids[i]<span class="sc">:&gt;3}</span><span class="ss">"</span>, <span class="st">" "</span>.join(row))</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate PAM250 by matrix exponentiation</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_pam_n(M, n, frequencies):</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute PAM-n matrix by raising M to the nth power"""</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>    M_n <span class="op">=</span> np.linalg.matrix_power(M, n)</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to scoring matrix</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>    n_aa <span class="op">=</span> <span class="bu">len</span>(M)</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    S_n <span class="op">=</span> np.zeros((n_aa, n_aa))</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_aa):</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_aa):</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> M_n[i, j] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> frequencies[j] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>                S_n[i, j] <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> np.log10(M_n[i, j] <span class="op">/</span> frequencies[j])</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>                S_n[i, j] <span class="op">=</span> <span class="op">-</span><span class="dv">10</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">round</span>(S_n).astype(<span class="bu">int</span>)</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute PAM250</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>S_pam250 <span class="op">=</span> compute_pam_n(M_prob, <span class="dv">250</span>, freqs)</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">PAM250 Scoring Matrix (subset):"</span>)</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   "</span>, <span class="st">"  "</span>.join(<span class="ss">f"</span><span class="sc">{</span>aa<span class="sc">:&gt;3}</span><span class="ss">"</span> <span class="cf">for</span> aa <span class="kw">in</span> amino_acids[:<span class="dv">8</span>]))</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">8</span>, <span class="bu">len</span>(amino_acids))):</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>S_pam250[i,j]<span class="sc">:3d}</span><span class="ss">"</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">8</span>, <span class="bu">len</span>(amino_acids)))]</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>amino_acids[i]<span class="sc">:&gt;3}</span><span class="ss">"</span>, <span class="st">" "</span>.join(row))</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a><span class="co"># Analyze substitution patterns</span></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Observed substitutions in alignment:"</span>)</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>subs, _ <span class="op">=</span> extract_substitutions(seq1, seq2)</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (aa1, aa2), count <span class="kw">in</span> <span class="bu">sorted</span>(subs.items(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="op">-</span>x[<span class="dv">1</span>])[:<span class="dv">5</span>]:</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>aa1<span class="sc">}</span><span class="ss"> &lt;-&gt; </span><span class="sc">{</span>aa2<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>count<span class="sc">}</span><span class="ss"> times"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This implementation demonstrates several key concepts:</p>
<ol type="1">
<li><p><strong>Extracting substitutions from alignments</strong>: The code counts how often each amino acid pair is observed in aligned positions, which forms the empirical basis for the PAM matrix.</p></li>
<li><p><strong>Calculating relative mutabilities</strong>: Each amino acid’s tendency to mutate is computed from the observed substitution frequencies, then scaled to represent 1 PAM unit (1% accepted mutations).</p></li>
<li><p><strong>Building the mutation probability matrix</strong>: The matrix M encodes the probability of each amino acid mutating to every other amino acid over one PAM unit of evolutionary time.</p></li>
<li><p><strong>Converting to log-odds scores</strong>: The mutation probabilities are transformed into scores suitable for sequence alignment using the log-odds ratio formula.</p></li>
<li><p><strong>Extrapolating to longer evolutionary distances</strong>: Matrix exponentiation (M^n) models the accumulation of mutations over n PAM units, allowing construction of PAM250 and other matrices.</p></li>
</ol>
<p>The example alignment shows typical patterns: conservative substitutions (R→K, both basic amino acids) occur more frequently than radical changes. The resulting PAM1 matrix will assign positive scores to these common substitutions and negative scores to rare ones.</p>
</section>
<section id="limitations-and-assumptions-of-pam-matrices" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="limitations-and-assumptions-of-pam-matrices">Limitations and Assumptions of PAM Matrices</h3>
<p>Like any model, PAM matrices rest on assumptions, and it’s important to understand where those assumptions might break down. First big assumption: substitution rates stay constant over evolutionary time. In reality, selection pressures change—a protein might be under strong purifying selection for millions of years, then suddenly face relaxed selection after a gene duplication event, then experience positive selection as it adapts to a new function. The PAM model ignores all this temporal variation and assumes evolution proceeds at a steady rate. Second assumption: all positions in a protein evolve at the same rate. This is clearly wrong—active site residues that are critical for catalysis evolve much more slowly than surface loop residues that don’t do much. A mutation in the active site might be lethal; a mutation in a surface loop might be completely neutral. PAM matrices average over all these differences, which means they’re missing important position-specific information. Third assumption: mutations at different positions are independent. In real proteins, mutations are often correlated—you might need a compensatory mutation at position <span class="math inline">\(B\)</span> to tolerate a mutation at position <span class="math inline">\(A\)</span>, because they interact structurally. PAM matrices can’t capture these epistatic effects. Finally, there’s an implicit reversibility assumption: the model assumes that the probability of <span class="math inline">\(a\)</span> substituting to <span class="math inline">\(b\)</span> equals the probability of <span class="math inline">\(b\)</span> substituting to <span class="math inline">\(a\)</span>, when you account for amino acid frequencies. This might not hold if there are directional trends in evolution—for instance, if proteins are generally evolving toward higher or lower GC content in their genes. Despite these limitations, PAM matrices work surprisingly well in practice, which tells you that these assumptions, while not perfect, are reasonable first approximations for many proteins.</p>
</section>
</section>
<section id="blosum-matrices-an-empirical-approach" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="blosum-matrices-an-empirical-approach">BLOSUM Matrices: An Empirical Approach</h2>
<section id="the-blocks-database-foundation" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-blocks-database-foundation">The BLOCKS Database Foundation</h3>
<p>In the 1990s, Steven and Jorja Henikoff developed BLOSUM (BLOcks SUbstitution Matrix) matrices using a fundamentally different philosophy from PAM. Instead of building a model from closely related sequences and extrapolating, they asked: why not just directly observe substitution patterns at the evolutionary distance you care about? BLOSUM matrices are built from the BLOCKS database, which contains multiply aligned conserved regions from protein families. Think of these “blocks” as the parts of proteins that are so functionally important that they stay recognizable even across huge evolutionary distances. These are your active sites, your binding pockets, your critical structural motifs—the regions where evolution is conservative because mutations tend to break things. Each block is an ungapped local alignment, meaning there are no insertions or deletions within the block, just substitutions. This simplifies the statistics considerably because you don’t have to worry about gap penalties or how to count gaps in your substitution frequencies. The brilliant innovation in BLOSUM was the clustering approach. Here’s the problem they solved: sequence databases are biased. If you have 100 sequences in a protein family, but 95 of them are from closely related bacterial species and only 5 are from diverse organisms, your substitution statistics will be dominated by those nearly-identical bacterial sequences. You’ll essentially be counting the same substitutions over and over, which gives you a skewed view of substitution patterns. The Henikoffs’ solution: cluster sequences within each block based on percent identity, then weight each cluster’s contribution to avoid over-representing closely related sequences. If sequences share more than a specified threshold of identity (say, <span class="math inline">\(62\%\)</span> for BLOSUM62), they get clustered together and treated as a single representative sequence. This prevents any particular evolutionary lineage from dominating the statistics and gives you a more balanced view of substitution patterns across diverse proteins.</p>
<div id="cell-fig-blosum-clustering" class="cell styled-output" data-fig-format="svg" data-fig-width="7" data-execution_count="3">
<div class="cell-output cell-output-display">
<div id="fig-blosum-clustering" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-blosum-clustering-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="protein_substitution_matrices_files/figure-html/fig-blosum-clustering-output-1.png" width="665" height="327" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-blosum-clustering-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;41.4: BLOSUM clustering concept. Sequences exceeding the identity threshold are grouped into clusters and downweighted to prevent over-representation. BLOSUM62 uses a 62% identity threshold, while BLOSUM45 uses 45% and BLOSUM80 uses 80%.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="computing-blosum-matrices" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="computing-blosum-matrices">Computing BLOSUM Matrices</h3>
<p>Once you have your blocks with sequences appropriately clustered, the construction process is conceptually straightforward: count amino acid pairs and convert the counts into log-odds scores. But the details matter, especially the weighting scheme. For each column in a block containing <span class="math inline">\(n\)</span> sequences, you could potentially extract <span class="math inline">\(\binom{n}{2} = \frac{n(n-1)}{2}\)</span> amino acid pairs by comparing every sequence to every other sequence. But remember, we’ve clustered sequences to avoid redundancy, so we need to weight each pair’s contribution based on which clusters they come from. Let <span class="math inline">\(c_i\)</span> represent the size of the cluster containing sequence <span class="math inline">\(i\)</span>. The weight of a pairwise comparison between sequences <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is:</p>
<p><span class="math display">\[w_{ij} = \frac{1}{c_i \cdot c_j}\]</span></p>
<p>Think about what this achieves. If both sequences are in large clusters (lots of nearly identical sequences), the weight is small—we’re downweighting this comparison because it’s not giving us much new information. If one or both sequences are in small clusters (unique or rare sequences), the weight is larger. This elegantly solves the redundancy problem. Now you count amino acid pairs across all column positions in all blocks, weighting each observation:</p>
<p><span class="math display">\[q_{ab} = \frac{\sum_{\text{pairs}} w_{ij} \cdot \delta_{ab}(i,j)}{\sum_{\text{all pairs}} w_{ij}}\]</span></p>
<p>where <span class="math inline">\(\delta_{ab}(i,j)\)</span> is an indicator that equals 1 if sequence <span class="math inline">\(i\)</span> has amino acid <span class="math inline">\(a\)</span> and sequence <span class="math inline">\(j\)</span> has amino acid <span class="math inline">\(b\)</span> at the position you’re examining (or vice versa when <span class="math inline">\(a \neq b\)</span>), and 0 otherwise. This gives you <span class="math inline">\(q_{ab}\)</span>, the observed frequency of the <span class="math inline">\((a,b)\)</span> pair in your blocks. To convert this into a log-odds score, you need the expected frequency—what you’d see if amino acids were pairing up randomly with no evolutionary constraint:</p>
<p><span class="math display">\[e_{ab} = \begin{cases}
p_a \cdot p_b \cdot 2 &amp; \text{if } a \neq b \\
p_a^2 &amp; \text{if } a = b
\end{cases}\]</span></p>
<p>where <span class="math inline">\(p_a = q_{aa} + \frac{1}{2}\sum_{b \neq a} q_{ab}\)</span> is the marginal frequency—how often amino acid <span class="math inline">\(a\)</span> appears overall. The factor of 2 when <span class="math inline">\(a \neq b\)</span> accounts for the fact that the pair <span class="math inline">\((a,b)\)</span> is the same as <span class="math inline">\((b,a)\)</span> —the pair is unordered.</p>
</section>
<section id="the-log-odds-scoring-system" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-log-odds-scoring-system">The Log-Odds Scoring System</h3>
<p>With observed and expected frequencies in hand, computing the actual BLOSUM score is straightforward:</p>
<p><span class="math display">\[S_{ab} = \lambda \cdot \log_2\left(\frac{q_{ab}}{e_{ab}}\right)\]</span></p>
<p>where <span class="math inline">\(\lambda\)</span> is a scaling factor chosen to yield convenient integer scores—typically 2 or thereabouts. Notice the use of base-2 logarithms, which gives the scores a nice interpretation: a score of <span class="math inline">\(+1\)</span> means the substitution is twice as likely as expected by chance, while a score of <span class="math inline">\(-1\)</span> means it’s half as likely. A score of <span class="math inline">\(+2\)</span> means four times as likely, <span class="math inline">\(-2\)</span> means one-quarter as likely, and so on. This is more intuitive than the base-10 logs used in PAM matrices. Positive scores indicate favorable substitutions—ones that show up more often in real proteins than random chance would predict. Negative scores penalize rare substitutions. The magnitude tells you how strong the signal is. One useful property of BLOSUM matrices is that you can quantify their information content using relative entropy:</p>
<p><span class="math display">\[H = \sum_{a,b} q_{ab} \cdot \log_2\left(\frac{q_{ab}}{e_{ab}}\right)\]</span></p>
<p>This is expressed in bits and measures how much information you gain about evolutionary relationships from observing a particular amino acid pair versus what you’d expect from random associations. Higher entropy means more specific, informative substitution patterns. Generally, matrices derived from more similar sequences (like BLOSUM80) have higher entropy than those from more divergent sequences (like BLOSUM45), because closely related sequences have more constrained, predictable substitution patterns that deviate more strongly from random expectation.</p>
</section>
<section id="the-blosum-series-and-clustering-thresholds" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-blosum-series-and-clustering-thresholds">The BLOSUM Series and Clustering Thresholds</h3>
<p>The number in a BLOSUM matrix name tells you the clustering threshold used during construction, and understanding this is key to choosing the right matrix. BLOSUM62 clusters sequences at <span class="math inline">\(62\%\)</span> identity—if two sequences in a block share <span class="math inline">\(\geq 62\%\)</span> identity, they’re treated as a single cluster. BLOSUM80 uses an <span class="math inline">\(80\%\)</span> threshold, so only very similar sequences get clustered together. Here’s the counterintuitive part: lower numbers mean matrices suitable for more divergent sequences. Why? Because with a low clustering threshold like <span class="math inline">\(45\%\)</span>, you’re lumping together fairly diverse sequences into clusters, which means your blocks contain a broader range of evolutionary distances. The substitution patterns you extract reflect what happens over longer evolutionary time. With a high threshold like <span class="math inline">\(80\%\)</span>, you’re mostly keeping sequences separate unless they’re very similar, so your substitution patterns reflect shorter evolutionary distances. The matrix properties follow predictable patterns based on this threshold. Low-threshold matrices like BLOSUM45 have lower relative entropy and are permissive—they accept a wider range of substitutions, making them good for detecting remote homologs where the sequence similarity is weak. High-threshold matrices like BLOSUM80 have higher entropy and are stringent—they penalize most substitutions heavily and reward only very conservative changes, making them appropriate for distinguishing closely related sequences. BLOSUM62 sits in the middle and has become the de facto standard because it performs well across a broad range of evolutionary distances, making it a robust default choice when you don’t know in advance how similar your sequences will be. One interesting mathematical detail: you can recover the target frequencies implicit in each BLOSUM matrix:</p>
<p><span class="math display">\[q_{ab} = p_a \cdot p_b \cdot e^{\lambda S_{ab}}\]</span></p>
<p>This reveals that BLOSUM matrices implicitly assume an exponential distribution of evolutionary distances in the training data—a different assumption from the time-structured model of PAM matrices.</p>
</section>
<section id="worked-example-constructing-a-blosum-matrix" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="worked-example-constructing-a-blosum-matrix">Worked Example: Constructing a BLOSUM Matrix</h3>
<p>Let’s construct a simplified BLOSUM matrix from a small block of aligned sequences. Consider the following ungapped alignment block containing five sequences:</p>
<pre><code>Sequence 1: A V L G
Sequence 2: A V M G
Sequence 3: G I L A
Sequence 4: G V L A
Sequence 5: A I M G</code></pre>
<p><strong>Step 1: Apply clustering threshold</strong></p>
<p>Suppose we use a 60% identity threshold (similar to BLOSUM62). Comparing sequences pairwise: - Sequences 1 and 2: 75% identity (3/4 matches) → cluster together - Sequences 3 and 4: 50% identity (2/4 matches) → remain separate - Sequence 5: &lt;60% identity with all others → remains separate</p>
<p>This gives us 4 clusters: - Cluster 1: {Seq1, Seq2} with size <span class="math inline">\(c_1 = 2\)</span> - Cluster 2: {Seq3} with size <span class="math inline">\(c_2 = 1\)</span> - Cluster 3: {Seq4} with size <span class="math inline">\(c_3 = 1\)</span> - Cluster 4: {Seq5} with size <span class="math inline">\(c_4 = 1\)</span></p>
<p><strong>Step 2: Calculate weighted pair frequencies</strong></p>
<p>For each column, we count amino acid pairs with weights. For column 1: - A-A pairs: (1,2) with weight <span class="math inline">\(\frac{1}{2 \times 2} = 0.25\)</span>; (1,5) with weight <span class="math inline">\(\frac{1}{2 \times 1} = 0.5\)</span>; (2,5) with weight <span class="math inline">\(\frac{1}{2 \times 1} = 0.5\)</span> - A-G pairs: (1,3) with weight <span class="math inline">\(\frac{1}{2 \times 1} = 0.5\)</span>; (1,4) with weight <span class="math inline">\(\frac{1}{2 \times 1} = 0.5\)</span>; (2,3) with weight <span class="math inline">\(\frac{1}{2 \times 1} = 0.5\)</span>; (2,4) with weight <span class="math inline">\(\frac{1}{2 \times 1} = 0.5\)</span> - G-G pairs: (3,4) with weight <span class="math inline">\(\frac{1}{1 \times 1} = 1.0\)</span></p>
<p>Total weight for column 1: <span class="math inline">\(0.25 + 0.5 + 0.5 + 0.5 + 0.5 + 0.5 + 0.5 + 1.0 = 4.25\)</span></p>
<p>Continuing for all columns and summing:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Pair</th>
<th>Column 1</th>
<th>Column 2</th>
<th>Column 3</th>
<th>Column 4</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A-A</td>
<td>1.25</td>
<td>0</td>
<td>0</td>
<td>1.0</td>
<td>2.25</td>
</tr>
<tr class="even">
<td>A-G</td>
<td>2.0</td>
<td>0</td>
<td>0</td>
<td>2.0</td>
<td>4.0</td>
</tr>
<tr class="odd">
<td>G-G</td>
<td>1.0</td>
<td>0</td>
<td>0</td>
<td>1.25</td>
<td>2.25</td>
</tr>
<tr class="even">
<td>V-V</td>
<td>0</td>
<td>1.25</td>
<td>0</td>
<td>0</td>
<td>1.25</td>
</tr>
<tr class="odd">
<td>V-I</td>
<td>0</td>
<td>2.0</td>
<td>0</td>
<td>0</td>
<td>2.0</td>
</tr>
<tr class="even">
<td>I-I</td>
<td>0</td>
<td>1.0</td>
<td>0</td>
<td>0</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>L-L</td>
<td>0</td>
<td>0</td>
<td>2.25</td>
<td>0</td>
<td>2.25</td>
</tr>
<tr class="even">
<td>L-M</td>
<td>0</td>
<td>0</td>
<td>2.0</td>
<td>0</td>
<td>2.0</td>
</tr>
<tr class="odd">
<td>M-M</td>
<td>0</td>
<td>0</td>
<td>1.0</td>
<td>0</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<p>Total weight across all pairs: 18.0</p>
<p><strong>Step 3: Calculate observed frequencies</strong></p>
<p><span class="math display">\[q_{AA} = \frac{2.25}{18.0} = 0.125\]</span> <span class="math display">\[q_{AG} = \frac{4.0}{18.0} = 0.222\]</span> <span class="math display">\[q_{GG} = \frac{2.25}{18.0} = 0.125\]</span></p>
<p>And similarly for other pairs.</p>
<p><strong>Step 4: Calculate marginal frequencies</strong></p>
<p><span class="math display">\[p_A = q_{AA} + \frac{1}{2}(q_{AG} + q_{AL} + q_{AM} + ...) = 0.278\]</span> <span class="math display">\[p_G = q_{GG} + \frac{1}{2}(q_{AG} + q_{GL} + q_{GM} + ...) = 0.222\]</span> <span class="math display">\[p_V = 0.181\]</span> <span class="math display">\[p_I = 0.139\]</span> <span class="math display">\[p_L = 0.125\]</span> <span class="math display">\[p_M = 0.055\]</span></p>
<p><strong>Step 5: Calculate expected frequencies and log-odds scores</strong></p>
<p>For A-A: <span class="math display">\[e_{AA} = p_A^2 = 0.278^2 = 0.077\]</span> <span class="math display">\[S_{AA} = 2 \times \log_2\left(\frac{0.125}{0.077}\right) = 2 \times 0.70 = 1.4 \approx 1\]</span></p>
<p>For A-G: <span class="math display">\[e_{AG} = 2 \times p_A \times p_G = 2 \times 0.278 \times 0.222 = 0.123\]</span> <span class="math display">\[S_{AG} = 2 \times \log_2\left(\frac{0.222}{0.123}\right) = 2 \times 0.85 = 1.7 \approx 2\]</span></p>
<p>For L-M: <span class="math display">\[e_{LM} = 2 \times p_L \times p_M = 2 \times 0.125 \times 0.055 = 0.014\]</span> <span class="math display">\[S_{LM} = 2 \times \log_2\left(\frac{0.111}{0.014}\right) = 2 \times 3.0 = 6\]</span></p>
<p><strong>Step 6: Construct the final BLOSUM matrix</strong></p>
<p>After calculating all scores and rounding to integers:</p>
<p><span class="math display">\[\text{BLOSUM} = \begin{array}{c|cccccc}
  &amp; A &amp; G &amp; V &amp; I &amp; L &amp; M \\
\hline
A &amp; 1 &amp; 2 &amp; -2 &amp; -2 &amp; -1 &amp; -2 \\
G &amp; 2 &amp; 1 &amp; -3 &amp; -3 &amp; -2 &amp; -3 \\
V &amp; -2 &amp; -3 &amp; 2 &amp; 3 &amp; 1 &amp; 1 \\
I &amp; -2 &amp; -3 &amp; 3 &amp; 2 &amp; 1 &amp; 1 \\
L &amp; -1 &amp; -2 &amp; 1 &amp; 1 &amp; 2 &amp; 6 \\
M &amp; -2 &amp; -3 &amp; 1 &amp; 1 &amp; 6 &amp; 3 \\
\end{array}\]</span></p>
<p>This example demonstrates how BLOSUM matrices capture actual substitution patterns observed in conserved regions. The high score for L-M (6) reflects the frequent substitution between these hydrophobic residues in our block, while negative scores indicate rare substitutions.</p>
</section>
</section>
<section id="comparative-analysis-of-pam-and-blosum" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="comparative-analysis-of-pam-and-blosum">Comparative Analysis of PAM and BLOSUM</h2>
<section id="theoretical-versus-empirical-approaches" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="theoretical-versus-empirical-approaches">Theoretical Versus Empirical Approaches</h3>
<p>PAM and BLOSUM represent two fundamentally different philosophies for tackling the same problem, and understanding the contrast helps you appreciate the strengths and limitations of each. PAM matrices are model-driven. They start with a theoretical model of how evolution works—mutations accumulate over time following a Markov process—and they build substitution matrices by estimating the model parameters from closely related sequences, then extrapolating to longer time scales through matrix exponentiation. This gives you a coherent mathematical framework with clear interpretability: PAM250 means 250 point accepted mutations per 100 positions. The downside? The whole approach rests on assumptions—constant substitution rates over time, position independence, reversibility—and if those assumptions don’t hold for your sequences, the extrapolation might go wrong. BLOSUM matrices, in contrast, are data-driven and empirical. They skip the modeling step entirely and just directly observe substitution patterns at whatever evolutionary distance is represented in the BLOCKS database. No extrapolation, no evolutionary model, just “here’s what we actually see in real conserved protein regions.” This avoids the assumptions inherent in PAM’s model, but it also means you lose the theoretical elegance and the direct interpretability—BLOSUM62 doesn’t have the same clear evolutionary time interpretation that PAM250 does. In practice, these philosophical differences lead to different performance characteristics. PAM matrices tend to excel when you’re comparing sequences at specific evolutionary distances that match their PAM number. Use PAM250 for sequences around <span class="math inline">\(20\%\)</span> identity, PAM120 for sequences around <span class="math inline">\(40\%\)</span> identity, and so on. They’re tuned for particular distances because of the explicit evolutionary model. BLOSUM matrices are more versatile across a range of distances. BLOSUM62 works well for sequences anywhere from <span class="math inline">\(30\%\)</span> to <span class="math inline">\(70\%\)</span> identity, which is why it’s become the default choice in most sequence alignment tools—you don’t have to know the evolutionary distance in advance to get reasonable results. This broader applicability comes from the diversity of evolutionary distances already present in the blocks used for construction.</p>
<div id="cell-fig-pam-blosum-comparison" class="cell styled-output" data-fig-format="svg" data-fig-width="7" data-execution_count="4">
<div class="cell-output cell-output-display">
<div id="fig-pam-blosum-comparison" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pam-blosum-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="protein_substitution_matrices_files/figure-html/fig-pam-blosum-comparison-output-1.png" width="659" height="275" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pam-blosum-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;41.5: Comparison of PAM250 and BLOSUM62 substitution matrices for a subset of amino acids. While both matrices capture similar biological patterns (high scores for conservative substitutions), they differ in magnitude and specific values due to their different construction methods.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="information-content-and-entropy-considerations" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="information-content-and-entropy-considerations">Information Content and Entropy Considerations</h3>
<p>Information content—measured by relative entropy—tells you how much discriminatory power a substitution matrix has, and it behaves differently for PAM versus BLOSUM matrices. For PAM matrices, information content follows a predictable pattern as you increase the PAM distance:</p>
<p><span class="math display">\[H_{\text{PAM}n} \approx H_{\text{PAM}1} \cdot \left(1 - e^{-\alpha n}\right)\]</span></p>
<p>where <span class="math inline">\(\alpha\)</span> is a decay constant. What this means: information content starts low at PAM1 (because there are almost no substitutions—most positions are identical), increases as you go to PAM50, PAM100, etc. (substitution patterns become more diverse and informative), then plateaus at high PAM distances like PAM250 (saturation—substitutions have occurred so many times that the patterns become less specific). There’s a sweet spot in the middle where information content is maximized. BLOSUM matrices show a different pattern. Information content is inversely related to the clustering threshold. BLOSUM80 has high entropy because you’re looking at closely related sequences with constrained, specific substitution patterns. BLOSUM45 has lower entropy because you’re pooling together more diverse sequences, so the substitution patterns are less specific and closer to random expectation. This creates a fundamental trade-off: high entropy means good specificity (few false positives) but potentially lower sensitivity (might miss true homologs). Low entropy means better sensitivity (can detect weak similarities) but more false positives. Your choice of matrix depends on which error you care more about avoiding.</p>
</section>
<section id="statistical-significance-and-e-values" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="statistical-significance-and-e-values">Statistical Significance and E-values</h3>
<p>Your choice of substitution matrix doesn’t just affect which alignments score highest—it fundamentally changes how you assess statistical significance. When you do a database search, you want to know: is this alignment score good enough to believe it represents a real evolutionary relationship, or could it have arisen by chance? The answer depends on the score distribution, which depends on the matrix. For ungapped alignments, scores follow an extreme value distribution:</p>
<p><span class="math display">\[P(S \geq x) \approx 1 - e^{-Kmn e^{-\lambda x}}\]</span></p>
<p>where <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are the lengths of your sequences, and <span class="math inline">\(K\)</span> and <span class="math inline">\(\lambda\)</span> are parameters specific to the substitution matrix and amino acid composition. Different matrices have different <span class="math inline">\(K\)</span> and <span class="math inline">\(\lambda\)</span> values, which means an alignment score of, say, <span class="math inline">\(+50\)</span> might be highly significant with one matrix but marginal with another. This affects E-value calculations—the expected number of alignments with that score or better that you’d see by chance—and consequently affects which sequences you identify as homologs. To enable fair comparison across different matrices, we use bit scores:</p>
<p><span class="math display">\[S' = \frac{\lambda S - \ln K}{\ln 2}\]</span></p>
<p>Bit scores normalize the raw scores using the matrix-specific parameters, giving you a matrix-independent measure of alignment quality. A bit score of 50 means the same thing regardless of whether you used BLOSUM62 or PAM250. This normalization is crucial when you’re comparing results from different search tools or different matrices to select the best approach for your sequences.</p>
</section>
</section>
<section id="specialized-matrices-and-modern-developments" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="specialized-matrices-and-modern-developments">Specialized Matrices and Modern Developments</h2>
<section id="position-specific-scoring-matrices-pssms" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="position-specific-scoring-matrices-pssms">Position-Specific Scoring Matrices (PSSMs)</h3>
<p>General substitution matrices like BLOSUM62 treat all positions in a protein the same way—they ask “how likely is alanine to substitute for valine?” without regard to where in the protein that substitution occurs. But we know this is an oversimplification. Some positions are highly conserved (active site residues, structural hinge points) where almost any substitution is deleterious. Other positions are variable (surface loops, linker regions) where many substitutions are tolerated. Position-specific scoring matrices (PSSMs) capture this position-by-position variation. Instead of a single matrix for all positions, you build a scoring profile from a multiple sequence alignment where each column (each position) gets its own substitution scores based on what’s observed at that specific position:</p>
<p><span class="math display">\[M_{i,a} = \log\left(\frac{f_{i,a} + \beta p_a}{(1 + \beta)p_a}\right)\]</span></p>
<p>where <span class="math inline">\(f_{i,a}\)</span> is the observed frequency of amino acid <span class="math inline">\(a\)</span> at position <span class="math inline">\(i\)</span> in your alignment, and <span class="math inline">\(\beta\)</span> is a pseudocount parameter that prevents you from assigning zero probability to amino acids that just haven’t been observed yet. This formulation smoothly interpolates between the observed frequencies (when you have lots of data) and background frequencies (when data is scarce). The magic happens when you use PSSMs iteratively, as in PSI-BLAST. You start with a query sequence and a general matrix like BLOSUM62, search a database, and identify homologs. Then you align those homologs and build a PSSM that captures the substitution patterns specific to your protein family. In the next iteration, you search again using this PSSM instead of the general matrix. The PSSM is more sensitive to the specific evolutionary constraints of your family, so you detect more distant homologs. You iterate, refining the PSSM each time, progressively extending your reach into more remote sequence space. This iterative approach has revolutionized remote homology detection, finding relationships that would be invisible to a single-pass search with a general matrix.</p>
</section>
<section id="structure-based-substitution-matrices" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="structure-based-substitution-matrices">Structure-Based Substitution Matrices</h3>
<p>A major limitation of general substitution matrices is that they ignore structural context. An alanine in an alpha-helix deep in the protein core faces very different evolutionary constraints than an alanine in a surface loop exposed to solvent. Structure-based substitution matrices address this by partitioning amino acids according to their structural environment—buried versus exposed, helix versus sheet versus loop—and building separate substitution matrices for each environment:</p>
<p><span class="math display">\[S_{ab}^{(e)} = \log\left(\frac{q_{ab}^{(e)}}{p_a^{(e)} \cdot p_b^{(e)}}\right)\]</span></p>
<p>where the superscript <span class="math inline">\((e)\)</span> denotes a specific structural environment. These matrices reveal fascinating patterns: buried positions strongly favor hydrophobic substitutions and heavily penalize hydrophilic ones (because burying a charged residue disrupts the hydrophobic core). Exposed positions are more permissive, accepting a wider range of substitutions. Helical positions favor helix-forming amino acids like alanine and leucine, while beta-sheet positions favor residues like valine and isoleucine. By using the appropriate environment-specific matrix for each position (if you have structural information or predictions), you can improve alignment accuracy, especially for distantly related proteins where structural constraints are often better conserved than sequence similarity.</p>
</section>
<section id="compositionally-adjusted-matrices" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="compositionally-adjusted-matrices">Compositionally Adjusted Matrices</h3>
<p>Some proteins have weird amino acid compositions that violate the assumptions built into standard matrices. Transmembrane proteins are packed with hydrophobic residues. Prion proteins are loaded with glutamine and asparagine. Proteins from thermophilic organisms have elevated levels of charged residues for stability. If you use a standard matrix with standard background frequencies to align these proteins, you’ll get biased results because the matrix assumes a typical amino acid composition. Compositional adjustment solves this by modifying the matrix based on the actual composition of the sequences you’re comparing:</p>
<p><span class="math display">\[S'_{ab} = S_{ab} + \lambda \log\left(\frac{p'_a p'_b}{p_a p_b}\right)\]</span></p>
<p>where <span class="math inline">\(p'_a\)</span> and <span class="math inline">\(p'_b\)</span> are the observed frequencies in your specific sequences, while <span class="math inline">\(p_a\)</span> and <span class="math inline">\(p_b\)</span> are the background frequencies the matrix was built with. This adjustment effectively recalibrates the matrix to account for compositional bias while preserving the relative substitution preferences—you’re still rewarding biochemically sensible substitutions, but you’re not artificially penalizing amino acids just because they happen to be unusually common or rare in your sequences.</p>
</section>
</section>
<section id="practical-considerations-in-matrix-selection" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="practical-considerations-in-matrix-selection">Practical Considerations in Matrix Selection</h2>
<section id="choosing-matrices-for-specific-applications" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="choosing-matrices-for-specific-applications">Choosing Matrices for Specific Applications</h3>
<p>Choosing the right substitution matrix isn’t just an academic exercise—it can make the difference between finding what you’re looking for and missing it entirely. The choice depends on your biological question and what you know about your sequences. If you’re identifying orthologs between closely related species—say, comparing mouse and rat proteins—you want high specificity. Use stringent matrices like BLOSUM80 or PAM120 that penalize most substitutions heavily. These matrices help you distinguish true orthologs (same gene in different species) from paralogs (different genes from an ancient duplication) by demanding high sequence similarity. False positives are costly here because you might mis-assign function, so you’re willing to be picky. On the other hand, if you’re searching databases for remote homologs—trying to find a distant evolutionary relative of your query protein that might share function or structure despite low sequence identity—you need sensitivity. Use permissive matrices like BLOSUM45 or PAM250 that are more forgiving of substitutions. These matrices won’t penalize chemically dissimilar amino acids as harshly, which lets you detect relationships that have diverged substantially over evolutionary time. The trade-off? More false positives, which means you need to carefully evaluate your hits with statistical tests (E-values) and look for corroborating evidence. A clever strategy employed by some alignment programs is to use different matrices at different stages. During initial pairwise comparisons when you’re casting a wide net, use a sensitive matrix like BLOSUM45 to avoid missing potential homologs. Then during refinement, when you’re trying to get the best possible alignment of sequences you’ve already identified as related, switch to BLOSUM62 or BLOSUM80 for more accurate positioning. This staged approach balances the competing demands of sensitivity and accuracy.</p>
<div id="cell-fig-matrix-performance" class="cell styled-output" data-fig-format="svg" data-fig-width="7" data-execution_count="5">
<div class="cell-output cell-output-display">
<div id="fig-matrix-performance" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-matrix-performance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="protein_substitution_matrices_files/figure-html/fig-matrix-performance-output-1.png" width="663" height="423" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-matrix-performance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;41.6: Optimal matrix selection based on sequence identity. Different substitution matrices perform best at different evolutionary distances. BLOSUM62 offers broad applicability across a wide range of identities, making it a robust default choice.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="gap-penalties-and-matrix-scaling" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="gap-penalties-and-matrix-scaling">Gap Penalties and Matrix Scaling</h3>
<p>Substitution matrices don’t work in isolation—they operate in concert with gap penalties to define your complete scoring scheme, and the balance between substitution scores and gap penalties critically affects what alignments you get. Think of it as a trade-off: would you rather accept a mismatch at a position, or would you rather open a gap (insertion/deletion)? If your gap penalties are too low relative to substitution penalties, the algorithm will insert gaps everywhere, fragmenting your alignment into tiny matching pieces separated by gaps. If gap penalties are too high, the algorithm will force mismatches even at positions where an insertion or deletion would make much more biological sense. The optimal gap penalties depend on which substitution matrix you’re using because different matrices have different score ranges. Empirical benchmarking has established good default values: for BLOSUM62, gap opening penalties of 10-12 and gap extension penalties of 1-2 work well for most proteins. These values strike a balance where gaps get introduced when they genuinely improve the alignment, but not gratuitously. Matrix scaling is another detail that matters more than you might think. All the substitution scores in a matrix can be multiplied by a constant without changing the relative relationships—a scaled matrix produces alignments with the same structure, just different raw scores. But the absolute scale affects numerical precision in alignment algorithms and influences statistical significance calculations. Most modern tools use integer-scaled matrices for computational efficiency (integer arithmetic is faster than floating-point), but the scaling is chosen to preserve the mathematical relationships and dynamic range of the original log-odds scores, so you’re not losing information.</p>
</section>
<section id="performance-evaluation-and-benchmarking" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="performance-evaluation-and-benchmarking">Performance Evaluation and Benchmarking</h3>
<p>How do we know which substitution matrix actually works best? You need carefully curated benchmark datasets where the evolutionary relationships are known—typically from structural data, since proteins with similar structures are reliably homologous even when sequence similarity is low. Databases like HOMSTRAD (Homologous Structure Alignment Database) provide gold-standard alignments based on structural superposition. You can test a substitution matrix by seeing how well it reproduces these known-correct alignments. The key metrics are sensitivity (can you detect true homologs?), specificity (can you avoid false positives?), and alignment accuracy (when you align two sequences, do you get the residue pairings right?). A powerful tool for evaluation is the ROC (Receiver Operating Characteristic) curve, which plots true positive rate versus false positive rate as you vary the score threshold for calling sequences homologous. The area under the ROC curve gives you a single number summarizing matrix performance: values near <span class="math inline">\(1.0\)</span> mean excellent discrimination, values near <span class="math inline">\(0.5\)</span> mean you’re doing no better than random guessing. Extensive benchmarking using ROC analysis has validated BLOSUM62 as a robust general-purpose matrix, while also identifying specific scenarios where other matrices perform better—BLOSUM45 for very remote homologs, BLOSUM80 for close relatives, PAM matrices when you have good estimates of evolutionary distance. Another useful metric for database searching is “coverage versus errors per query”: as you relax your score threshold, you detect more true homologs (increasing coverage), but you also accumulate false positives (errors). The optimal matrix minimizes errors while maximizing coverage, though the exact balance you want depends on your application—is it worse to miss a true homolog or to chase a false lead?</p>
</section>
</section>
<section id="future-directions-and-emerging-approaches" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="future-directions-and-emerging-approaches">Future Directions and Emerging Approaches</h2>
<section id="machine-learning-and-deep-learning-approaches" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="machine-learning-and-deep-learning-approaches">Machine Learning and Deep Learning Approaches</h3>
<p>Recent advances in machine learning have opened new avenues for developing substitution scoring schemes. Deep learning models trained on large sequence databases can learn complex substitution patterns that escape traditional statistical approaches. These models capture higher-order dependencies between positions and can adapt to specific protein families or functional classes.</p>
<p>Neural network architectures like transformers, which have revolutionized natural language processing, show promise for learning context-dependent substitution patterns. These models can potentially capture long-range interactions and correlated mutations that traditional position-independent matrices miss. The challenge lies in interpreting these complex models and extracting biological insights from their learned representations.</p>
</section>
<section id="integration-with-structural-prediction" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="integration-with-structural-prediction">Integration with Structural Prediction</h3>
<p>The recent breakthrough in protein structure prediction by AlphaFold and similar systems creates opportunities for structure-informed substitution matrices. As structural data becomes available for most proteins, substitution patterns can be analyzed in their full three-dimensional context. This integration promises matrices that capture the subtle interplay between sequence and structure evolution.</p>
<p>Contact-dependent substitution matrices represent one promising direction, where substitution scores depend not just on the amino acids being compared but also on their structural neighbors. Such matrices could capture the compensatory mutations that maintain protein stability and the correlated changes that preserve protein-protein interfaces.</p>
</section>
<section id="phylogenetic-context-and-lineage-specific-matrices" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="phylogenetic-context-and-lineage-specific-matrices">Phylogenetic Context and Lineage-Specific Matrices</h3>
<p>The recognition that substitution patterns vary across evolutionary lineages motivates the development of clade-specific matrices. Matrices optimized for vertebrate proteins may not perform optimally for bacterial sequences, reflecting different evolutionary pressures and constraints. The construction of taxonomically focused matrices requires balancing specificity gains against reduced training data.</p>
<p>Time-heterogeneous models that allow substitution patterns to vary across evolutionary time represent another frontier. These models could capture the acceleration of evolution following gene duplication or the different selective pressures operating at different evolutionary epochs. The mathematical and computational challenges of such models are substantial, but they promise more accurate evolutionary inference.</p>
</section>
</section>
<section id="conclusion" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Protein substitution matrices represent one of those foundational achievements in computational biology that’s easy to take for granted because they work so reliably. These matrices transformed the fuzzy, qualitative notion of “these sequences look kinda similar” into precise quantitative frameworks that let you rigorously test evolutionary hypotheses, detect remote homologs, and predict protein function. From Dayhoff’s pioneering work on PAM matrices in the 1970s to the Henikoffs’ empirical BLOSUM approach in the 1990s, substitution matrices have enabled countless discoveries in molecular evolution, structural biology, and functional genomics. The field has progressed from simple statistical models to sophisticated approaches incorporating position-specificity, structural context, and compositional biases. Each advance addresses limitations of previous methods while preserving core insights about what makes certain amino acid substitutions more likely than others. Looking forward, we’re entering an exciting era where massive sequence databases, routine structure prediction, and powerful machine learning methods are opening new possibilities. Deep learning models can potentially capture complex substitution patterns that escape traditional statistical approaches—context dependencies, long-range interactions, and subtle correlations that position-independent matrices miss. Structure-informed matrices can leverage the protein structure prediction revolution to account for three-dimensional constraints. Lineage-specific matrices can capture the fact that substitution patterns differ between prokaryotes, plants, and animals. Despite these advances, the fundamental principles remain constant: we’re trying to capture evolutionary signal, distinguish real homology from chance similarity, and quantify sequence relationships in biologically meaningful ways. Future methods, whether based on transformers or physics-based simulations, will build on the foundation that PAM and BLOSUM established. And the practical impact extends far beyond sequence alignment—substitution matrices inform protein engineering, guide drug design, and underpin phylogenetic inference. Understanding how these matrices work, why they’re constructed the way they are, and how to choose the right one for your problem remains essential knowledge for anyone working with protein sequences. As methods evolve, the core insights about protein evolution encoded in substitution matrices will continue to guide the field.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../chapters/web/ccr5_pwalign/index.html" class="pagination-link" aria-label="CCR5-delta32">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">40</span>&nbsp; <span class="chapter-title">CCR5-delta32</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/web/mrsa_blast_multalign/index.html" class="pagination-link" aria-label="MRSA">
        <span class="nav-page-text"><span class="chapter-number">43</span>&nbsp; <span class="chapter-title">MRSA</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>